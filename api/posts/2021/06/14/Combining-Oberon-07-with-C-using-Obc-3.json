{
  "content": "\n\nCombing Oberon-07 with C using Obc-3\n===================================\n\nBy R. S. Doiel, 2021-06-14\n\nThis post explores integrating C code with an Oberon-07 module use\nMike Spivey's Obc-3 Oberon Compiler.  Last year I wrote a similar post\nfor Karl Landstr√∂m's [OBNC](/blog/2020/05/01/Combining-Oberon-and-C.html).\nThis goal of this post is to document how I created a version of Karl's\nExtension Library that would work with Mike's Obc-3 compiler.\nIf you want to take a shortcut you can see the results on GitHub\nin my [obc-3-libext](https://github.com/rsdoiel/obc-3-libext) repository.\n\nFrom my time with OBNC I've come to rely on three modules from Karl's\nextension library. When trying to port some of my code to use with\nMike's compiler. That's where I ran into a problem with that dependency.\nKarl's modules aren't available. I needed an [extArgs](http://miasap.se/obnc/obncdoc/ext/extArgs.def.html),\nan [extEnv](http://miasap.se/obnc/obncdoc/ext/extEnv.def.html) and\n[extConvert](http://miasap.se/obnc/obncdoc/ext/extConvert.def.html).\n\nMike's own modules that ship with Obc-3 cover allot of common ground\nwith Karl's. They are organized differently. The trivial solution is\nto implement wrapping modules using Mike's modules for implementation.\nThat takes case of extArgs and extEnv.\n\nThe module extConvert is in a another category. Mike's `Conv` module is\nsignificantly minimalist. To solve that case I've create C code to perform\nthe needed tasks based on Karl's examples and used Mike's share library\ncompilation instructions to make it available inside his run time.\n\nBackground material\n-------------------\n\n- [Obc-3 website](https://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler)\n    - [Installing Obc-3](https://spivey.oriel.ox.ac.uk/corner/Installing_OBC_release_3.1)\n    - [Adding primitives to Obc-3](https://spivey.oriel.ox.ac.uk/corner/How_to_add_primitives_to_OBC), this is how you extend Obc-3 with C\n    - [Obc-3.1 Manual](https://spivey.oriel.ox.ac.uk/wiki/images-corner/c/ce/Obcman-3.1.pdf)\n- [Obc-3 at GitHub](http://github.com/Spivoxity/obc-3)\n\n\nDifferences: OBNC and Obc-3\n---------------------------\n\nThe OBNC compiler written by Karl takes the approach of translating\nOberon-07 code to C and then calling the C tool chain to convert that\ninto a   executable.  Karl's compiler is largely written in C\nwith some parts written in Oberon.\n\nMike's takes a different approach. His compiler uses a run time JIT\nand is written mostly in OCaml with some C parts and shell scripting.\nWhen you compile an Oberon program (either Oberon-2 or Oberon-07) using\nMike's compiler you get a bunch of \"*.k\" files that the object code\nfor Mike's thunder virtual machine and JIT.  This can in turn be used\nto create a executable.\n\nFor implementing Oberon procedures in C Karl's expects an empty\nprocedure body. e.g.\n\n```oberon\nPROCEDURE DoMyThing();\nBEGIN\nEND DoMyThing;\n```\n\nWhile Mike has added a \"IS\" phrase to the procedure signature to\nindicate what the C implementation is known as. There is no procedure\nbody in Mike's implementation and the parameters need to map\ndirectly into a C data type.\n\n```oberon\nPROCEDURE DoMyThing() IS \"do_my_thing\";\n```\n\nOf course both compilers have completely different command line options\nand when you're integrating C shared libraries in Mike's you need to\ncall your local CC (e.g. GCC, clang) to create a share library file.\nMike has extended Oberon-07 SYSTEM to include `SYSTEM.LOADLIB()` which\ntakes a string containing the path to the compiler shared library.\n\nIn Karl's own Oberon-07 modules he uses the `.obn` file extension but\nalso accepts `.Mod`.  In Mike's he uses `.m` and also accepts `.Mod`.\nIn this article I will be using `.m` as that simplified the recipe\nof building and integrating the shared C libraries.\n\n\nSimilarities of OBNC and Obc-3\n------------------------------\n\nBoth compilers provide for compiling Oberon-07 code, Mike's requires\nthe `-07` option to be used to switch from Oberon-2. Both offer the\nability to extend reach into the host POSIX system by wrapping\nC shared libraries. Both run on a wide variety of POSIX systems and\nyou can read the source code at your leisure. This last bit is\nimportant.\n\nArgs, extArgs and extEnv.\n-------------------------\n\nMike provides two features in his Args module. The first is access\nto the command line arguments of the compiled program. The\nsecond feature is to provide access to the host environment variables.\nIn Karl's implementation he separates Mikes `Args.GetEvn()` into\na module called `extEnv`. Here's Mike's module definition looks like ---\n\n```oberon\nDEFINITION Args;\n\nVAR argc* : INTEGER; (* this is equavilent to extArgs.count *)\n\nPROCEDURE GetArg*(n: INTEGER; VAR s: ARRAY OF CHAR);\n\nPROCEDURE GetEnv*(name: ARRAY OF CHAR; VAR s: ARRAY OF CHAR);\n\nEND Args.\n```\n\nMy implementation of Karl's `extArgs` needs to look like ---\n\n```oberon\nDEFINITION extArgs;\n\nVAR count*: INTEGER; (* this is the same as Args.argc *)\n\nPROCEDURE Get*(n: INTEGER; VAR arg: ARRAY OF CHAR; VAR res: INTEGER);\n\nEND extArgs.\n```\n\nThis leaves us with a very simple module mimicking Karl's.\n\n```oberon\nMODULE extArgs;\n\nIMPORT Args;\n\nVAR\n  count*: INTEGER;\n\nPROCEDURE Get*(n: INTEGER; VAR arg: ARRAY OF CHAR; VAR res: INTEGER);\nBEGIN\n  Args.GetArg(n + 1, arg);  res := 0;\nEND Get;\n\nBEGIN\n  count := Args.argc - 1;\nEND extArgs.\n```\n\nNOTE: In Mike's approach the zero-th arg is the program name.\nIn Karl's the zero-th arg is the first argument after the program\nname. To get Karl's behavior with Mike's `GetArg()` I need to\nadjust the offsets.\n\nSo far so good. How about implementing Karl's `extEnv`?\n\nWe've already seen Mike's Args so he doesn't have a matching\ndefinition.  Karl's `extEnv` looks like\n\n```oberon\nDEFINITION extEnv;\n\nPROCEDURE Get*(name: ARRAY OF CHAR; VAR value: ARRAY OF CHAR; VAR res: INTEGER);\n\nEND extEnv.\n```\n\nAnd again a simple mapping of features and you have\n\n```oberon\nMODULE extEnv;\n\nIMPORT Args, Strings;\n\nPROCEDURE Get*(name : ARRAY OF CHAR; VAR value : ARRAY OF CHAR; VAR res : INTEGER);\n  VAR i, l1, l2 : INTEGER; val : ARRAY 512 OF CHAR;\nBEGIN\n  l1 := LEN(value) - 1; (* Allow for trailing 0X *)\n  Args.GetEnv(name, val);\n  l2 := Strings.Length(val);\n  IF l2 <= l1 THEN\n    res := 0;\n  ELSE\n    res := l2 - l1;\n  END;\n  i := 0;\n  WHILE (i < l2) & (val[i] # 0X) DO\n      value[i] := val[i];\n      INC(i);\n  END;\n  value[i] := 0X;\nEND Get;\n\nEND extEnv.\n```\n\nextConvert requires more work\n-----------------------------\n\nMike provides a module called `Conv.m` for converting numbers\nto strings.  It is a little minimal for my current purpose.\nThat is easy enough to solve as Mike, like Karl provides a means\nof extending Oberon code with C.  That means I need to write\n`extConvert` as both `extConvert.m` (the Oberon-07 part) and\n`extConvert.c` (the C part).\n\nHere's Karl's definition\n\n```oberon\nDEFINITION extConvert;\n\nPROCEDURE IntToString*(i: INTEGER; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n\nPROCEDURE RealToString*(x: REAL; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n\nPROCEDURE StringToInt*(s: ARRAY OF CHAR; VAR i: INTEGER; VAR done: BOOLEAN);\n\nPROCEDURE StringToReal*(s: ARRAY OF CHAR; VAR x: REAL; VAR done: BOOLEAN);\n\nEND extConvert.\n```\n\nI have implement my `extConvert` as a hybrid of Oberon-07 and calls\nto a C shared library I will create called `extConvert.c`.\n\nThe Oberon file (i.e. extConvert.m)\n\n```oberon\nMODULE extConvert;\n\nIMPORT SYSTEM;\n\nPROCEDURE IntToString*(i: INTEGER; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n  VAR l : INTEGER;\nBEGIN\n  l := LEN(s); done := TRUE;\n  IntToString0(i, s, l);\nEND IntToString;\n\nPROCEDURE IntToString0(i : INTEGER; VAR s : ARRAY OF CHAR; l : INTEGER) IS \"conv_int_to_string\";\n\nPROCEDURE RealToString*(x: REAL; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n  VAR l : INTEGER;\nBEGIN\n  l := LEN(s);\n  RealToString0(x, s, l);\nEND RealToString;\n\nPROCEDURE RealToString0(x: REAL; VAR s: ARRAY OF CHAR; l : INTEGER) IS \"conv_real_to_string\";\n\nPROCEDURE StringToInt*(s: ARRAY OF CHAR; VAR i: INTEGER; VAR done: BOOLEAN);\nBEGIN\n  done := TRUE;\n  StringToInt0(s, i);\nEND StringToInt;\n\nPROCEDURE StringToInt0(s : ARRAY OF CHAR; VAR i : INTEGER) IS \"conv_string_to_int\";\n\nPROCEDURE StringToReal*(s: ARRAY OF CHAR; VAR x: REAL; VAR done: BOOLEAN);\nBEGIN\n  done := TRUE;\n  StringToReal0(s, x);\nEND StringToReal;\n\nPROCEDURE StringToReal0(s: ARRAY OF CHAR; VAR x : REAL) IS \"conv_string_to_real\";\n\nBEGIN\n  SYSTEM.LOADLIB(\"./extConvert.so\");\nEND extConvert.\n```\n\nIf you review Mike's module code you'll see I have followed a similar pattern. Before calling out to C I take care of what house keeping I can in Oberon, then I call a \"0\" version of the function implemented in C. The C implementation are not exported only the wrapping Oberon procedures are.\n\nNotice how the initialization block calls `SYSTEM.LOADLIB(\"./extConvert.so\");` this loads the C shared library so that the Oberon module can call out it it.\n\nThe C code in `extConvert.c` looks very traditional without the macros\nyou'd see in OBNC's implementation. Here's what the C code look like.\n\n```C\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid conv_int_to_string(int i, char *s, int l) {\n  snprintf(s, l, \"%d\", i);\n}\n\nvoid conv_real_to_string(float r, char *s, int l) {\n  snprintf(s, l, \"%f\", r);\n}\n\nvoid conv_real_to_exp_string(float r, char *s, int l) {\n  snprintf(s, l, \"%e\", r);\n}\n\nvoid conv_string_to_int(char *s, int *i) {\n    *i = atoi(s);\n}\n\nvoid conv_string_to_real(char *s, float *r) {\n    *r = atof(s);\n}\n```\n\nThe dance to compile the module and C shared library is very different\nbetween OBNC and Obc-3.  With Obc-3 we compile and skip linking\nthe wrapping Oberon module `extConvert.m`. We compile using CC\nour C shared library. We can then put it all together to test\neverything out in `ConvertTest.m`.\n\n```shell\nobc -07 -c extConvert.m\ngcc -fPIC -shared extConvert.c -o extConvert.so\n```\n\nOur test code program looks like.\n\n```oberon\nMODULE ConvertTest;\n\nIMPORT T := Tests, Convert := extConvert;\n\nVAR ts : T.TestSet;\n\nPROCEDURE TestIntConvs() : BOOLEAN;\n  VAR test, ok : BOOLEAN;\n      expectI, gotI : INTEGER;\n      expectS, gotS : ARRAY 128 OF CHAR;\nBEGIN test := TRUE;\n  gotS[0] := 0X; gotI := 0;\n  expectI := 101;\n  expectS := \"101\";\n\n  Convert.StringToInt(expectS, gotI, ok);\n  T.ExpectedBool(TRUE, ok, \"StringToInt('101', gotI, ok) true\", test);\n  T.ExpectedInt(expectI, gotI, \"StringToInt('101', gotI, ok)\", test);\n\n  Convert.IntToString(expectI, gotS, ok);\n  T.ExpectedBool(TRUE, ok, \"IntToString(101, gotS, ok) true\", test);\n  T.ExpectedString(expectS, gotS, \"IntToString(101, gotS, ok)\", test);\n\n  RETURN test\nEND TestIntConvs;\n\nPROCEDURE TestRealConvs() : BOOLEAN;\n  VAR test, ok : BOOLEAN;\n      expectR, gotR : REAL;\n      expectS, gotS : ARRAY 128 OF CHAR;\nBEGIN test := TRUE;\n  gotR := 0.0; gotS[0] := 0X;\n  expectR := 3.1459;\n  expectS := \"3.145900\";\n\n  Convert.StringToReal(expectS, gotR, ok);\n  T.ExpectedBool(TRUE, ok, \"StringToReal('3.1459', gotR, ok) true\", test);\n  T.ExpectedReal(expectR, gotR, \"StringToReal('3.1459', gotR, ok)\", test);\n\n  Convert.RealToString(expectR, gotS, ok);\n  T.ExpectedBool(TRUE, ok, \"RealToString(3.1459, gotS; ok) true\", test);\n  T.ExpectedString(expectS, gotS, \"RealToString(3.1459, gotS, ok)\", test);\n\n  RETURN test\nEND TestRealConvs;\n\nBEGIN\n  T.Init(ts, \"extConvert\");\n  T.Add(ts, TestIntConvs);\n  T.Add(ts, TestRealConvs);\n  ASSERT(T.Run(ts));\nEND ConvertTest.\n```\n\nWe compile and run our test program use the following commands\n(NOTE: Using Obc-3 you list all the dependent modules to possibly\nbe compiled one the command line along with your program module).\n\n```shell\nobc -07 -o converttest extConvert.m Tests.m ConvertTest.m\n./converttest\n```\n\nSource code for these modules is available on GitHub at\n[github.com/rsdoiel/obc-3-libest](https://github.com/rsdoiel/obc-3-libext)\n\n\nNext & Previous\n---------------\n\n- Next [Revisiting Files](../../11/22/Revisiting-Files.html)\n- Previous [Beyond Oakwood, Modules and Aliases](../../05/16/Beyond-Oakwood-Modules-and-Aliases.html)\n",
  "data": {
    "author": "rsdoiel@gmail.com (R. S. Doiel)",
    "copyright": "copyright (c) 2021, R. S. Doiel",
    "date": "2021-06-14",
    "keywords": [
      "Oberon",
      "Obc-3",
      "C",
      "extArgs",
      "extEnv",
      "extConvert"
    ],
    "license": "https://creativecommons.org/licenses/by-sa/4.0/",
    "number": 19,
    "title": "Combining Oberon-07 with C using Obc-3"
  }
}