{
  "page": 6,
  "total_pages": 6,
  "has_more": false,
  "next_page": null,
  "values": [
    {
      "content": "\n# Installing Deno via Cargo and other options\n\nBy R. S. Doiel, 2024-12-13\n\nI've recently needed to install Deno on several Debian flavored Linux boxes.  I wanted to install Deno using the `cargo install --locked deno` command. Notice the `--locked` option, you need that for Deno. This worked for the recent Ubuntu 22.04 LTS release. I needed alternatives for Ubuntu 20.04 LTS and Raspberry Pi OS.\n\n## Using Cargo\n\nPrerequisites:\n\n- Rust (install with [Rustup](https://rustup.rs))\n- CMake\n- Clang, LLVM dev, Clang DEV and the lld (clang) linker\n- SQLite3 and LibSQLite3 dev\n- pkg config\n- libssh dev, libssl dev\n\nThe Debian flavors I work with are recent (Dec. 2024) Ubuntu 22.04 LTS release[^1].\n\nRecently when I was installing Deno 2.1.4 I got errors about building the `flate2` module. I had forgotten to include the `--locked` option in my cargo command. I found this solution in Deno GitHub issue [9524](https://github.com/denoland/deno/issues/9524).\n\n```shell\nsudo apt install -y build-essential cmake clang libclang-dev llvm-dev lld \\\n                    sqlite3 libsqlite3-dev pkg-config libssh-dev libssl-dev\nrustup update\ncargo install deno --locked\n```\n\n## Other options\n\nFor Ubuntu 20.04 LTS and Raspberry Pi OS, use `curl -fsSL https://deno.land/install.sh | sh` to install.\n\nFor Windows on ARM64 use `iwr https://deno.land/install.ps1 -useb | iex`.\n\n `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`\nOn Raspberry Pi OS I added a `nice` before calling `cargo`. Without the \"nice\" it failed after the \"spin\" module.\n\n[^1]: I failed to install Deno this way on Ubuntu 20.04 LTS, just use the cURL + sh script.\n",
      "data": {
        "abstract": "Notes on setting up a Debian flavored Linux boxes, macOS and Windows to install Deno via `cargo install deno`,\n`curl -fsSL https://deno.land/install.sh | sh` or\n`iwr https://deno.land/install.ps1 -useb | iex`\n",
        "byline": "R. S. Doiel, 2024-12-13",
        "createDate": "2024-12-13",
        "keywords": [
          "rust",
          "deno",
          "cargo",
          "Debian",
          "Linux",
          "windows",
          "macOS"
        ],
        "title": "Installing Deno via Cargo and other options"
      },
      "url": "posts/2024/12/13/installing-via-cargo-etc.json"
    },
    {
      "content": "\n# Deno 2.1.7, Points of Friction\n\nBy R. S. Doiel, 2025-01-26\n\nI have run into a few points of friction in my journey with Deno coming from Go. I miss Go's standard \"io\" and \"bufio\" packages. With the Go code I'm porting TypeScript I'd often need to handle standard input or input from a named file interchangeably. Seems like this should be easy in Deno's TypeScript but there are a few bumps in the road.\n\nHere's the Go idiom I commonly use.\n\n~~~go\nvar err error\ninput := io.Stdin\nif inFilename != \"\" {\n    input, err := os.Open(inFilename)\n    if err !== nil {\n        // ... handle error\n    }\n    defer input.Close();\n}\n// Now I can just pass \"in\" around for processing.\n~~~\n\nConceptually this feels simple though verbose. I can pass around the \"input\" for processing in a way that is agnostic as to file or standard input. This type of Go code works equally on POSIX and Windows.\n\nDeno provide access to [standard input](https://docs.deno.com/api/deno/~/Deno.stdin). Deno supports streamable files. From the docs here's an simple example.\n\n~~~TypeScript\n// If the text \"hello world\" is piped into the script:\nconst buf = new Uint8Array(100);\nconst numberOfBytesRead = await Deno.stdin.read(buf); // 11 bytes\nconst text = new TextDecoder().decode(buf);  // \"hello world\"\n~~~\n\nSetting aside the buffer management code it seems simple and straight forward. It is easy to understand and you could wrap it in a function easily to hide the buffer management part. Yet it doesn't provide the same flexibility as the more verbose Go version. Surely there is an an idiomatic why of doing this in TypeScript already? \n\n## Stability Challenge\n\nDeno currently is a rapidly evolving platform. My first impulse was to reach for packages like `jsr:@std/fs` or `jsr:@sys/fs`. When I search for examples they mostly seem to reference specific versions of \"std/fs\" that are not available via jsr. So what's the \"right\" way to approach this?\n\n## Repl to the rescue.\n\nPoking around in the Deno repl I tried assigning `Deno.stdin` to a local variable. Playing with command line completion I realized it has most of the the methods you would get if you used `Deno.open()` to open a named file.\n\nHere's a little test I ran in the repl after creating a \"hellworld.txt\" text file.\n\n~~~deno\ndeno\nconst stdin = Deno.stdin;\nlet input = Deno.open('helloworld.txt')\nstdin.isTerminal();\ninput.isTerminal();\nstdin.valueOf();\ninput.valueOf();\nDeno.exit(0);\n~~~\n\nThe `valueOf()` reveals their type affiliation. It listed them as `Stdin {}` and `FsFile {}` respectively. I used TypeScript's typing system to let us implement \"mycat.ts\". You can assign multiple types to a variable with a `|` (pipe) symbol in TypeScript. \n\nUsed that result to write a simple cat file implementation.\n\n~~~TypeScript\nasync function catFile() {\n    let input : Stdin | FsFile = Deno.stdin;\n\n    if (Deno.args.length > 0) {\n        input = await Deno.open(Deno.args[0]);\n    }\n\n    const decoder = new TextDecoder();\n\n    // NOTE: the .readable function is available on both types of objects.\n    for await (const chunk of input.readable) {\n        console.log(decoder.decode(chunk));\n    }\n}\n\nif (import.meta.main) catFile();\n~~~\n\nYou can \"run\" this deno to see it in action. Try running it on your \"helloworld.txt\" file.\n\n~~~shell\ndeno run --allow-read mycat.ts helloworld.txt\n~~~\n\nYou can also read from standard input too. Try the command below type in some text then press Ctrl-D or Ctrl-Z if you're on Windows.\n\n~~~shell\ndeno run --allow-read mycat.ts\n~~~\n\nLooks like we have a nice solution. Now I can compile \"mycat.ts\".\n\n## trouble in paradise\n\nWhile you can \"run\" the script you can't compile it. It doesn't pass \"check\". This is the error I get with Deno 2.1.7.\n\n~~~shell\ndeno check mycat.ts\nCheck file:///C:/Users/rsdoi/Sandbox/Writing/Articles/Deno/mycat.ts\nerror: TS2304 [ERROR]: Cannot find name 'Stdin'.\n    let input : Stdin | FsFile = Deno.stdin;\n                ~~~~~\n    at file:///C:/Users/rsdoi/Sandbox/Writing/Articles/Deno/mycat.ts:3:17\n\nTS2552 [ERROR]: Cannot find name 'FsFile'. Did you mean 'File'?\n    let input : Stdin | FsFile = Deno.stdin;\n                        ~~~~~~\n    at file:///C:/Users/rsdoi/Sandbox/Writing/Articles/Deno/mycat.ts:3:25\n\n    'File' is declared here.\n    declare var File: {\n                ~~~~\n        at asset:///lib.deno.web.d.ts:622:13\n\nFound 2 errors.\n~~~\n\nIt seems like what works in the repl should also compile but that's isn't the case. I have an open question on Deno's discord help channel and am curious to find the \"correct\" way to handle this problem.\n\n## Update 2025-01-26, 5:00PM\n\nI heard back on Deno Discord channel for help.  With the help of [crowlKat](https://github.com/crowlKats) sorted the problem out.\n\nThe compile and runnable version of [mycat.ts](mycat.ts) looks like this.\n\n~~~typescript\nasync function main() {\n    let input : Deno.FsFile | any = Deno.stdin;\n\n    if (Deno.args.length > 0) {\n        input = await Deno.open(Deno.args[0]);\n    }\n\n    const decoder = new TextDecoder();\n\n    // NOTE: the .readable function is available on both types of objects.\n    for await (const chunk of input.readable) {\n        console.log(decoder.decode(chunk));\n    }\n}\n\nif (import.meta.main) main();\n~~~\n\nThe \"any\" type feels a little ugly but since I am assinging the default value is `Deno.stdin` it covers that case where the `Deno.FsFile` covers the case of a name file.  Where does this leave me? I have a nice clean idiom that does what I want for interacting with standard input or a file stream.  Not necessarily the fast thing on the planet but it works.\n\n\n",
      "data": {
        "abstract": "A short discussion of working with file input in TypeScript+Deno coming from the\nperspective of Go's idiomatic use of io buffers.\n",
        "byline": "R. S. Doiel",
        "createdDate": "2025-01-26",
        "keywords": [
          "deno",
          "text",
          "input"
        ],
        "title": "Deno 2.1.7, Points of Friction"
      },
      "url": "posts/2025/01/26/points_of_friction.json"
    },
    {
      "content": "\n# Deno 2.1.7, Project Idioms\n\nI've noticed a collection of file and code idioms I've been used in my recent Deno+TypeScript projects at work. I've captured them here as a future reference.\n\n## Project files\n\nMy project generally have the following files, these are derived from the [CodeMeta](https://codemeta.github.io) file using [CMTools](https://caltechlibrary.github.io/CMTools).\n\ncodemeta.json\n: Primary source of project metadata, used to generate various files\n\nCITATION.cff\n: used by GitHub for citations. version, dateModified, datePublished and releaseNotes\n\n\nabout.md\n: A project about page. This is generated based on the codemeta.json file.\n\nREADME.md, README\n: A general read me describing the project and pointing to INSTALL.md, user_manual.md as appropriate\n\nINSTALL.md\n: These are boiler plate description of how to install and compile the software\n\nuser_manual.md\n: This is an index document, a table of contents. It points to other document including Markdown versions of the man page(s).\n\nFor TypeScript projects I also include a following\n\nversion.ts\n: This hold project version information used in the TypeScript co-debase. It is generated from the codemeta.json via CMTools.\n\nhelptext.ts\n: This is where I place a function, `fmtHelp()`, for rendering response to the \"help\" command line option.\n\nI'm currently ambivalent about \"main.ts\" file which is created by `deno init`. My ambivalent is that most of my projects wind up producing more than one program from a shared code base. a single \"main.ts\" doesn't really fit that situation.\n\nThe command line tool will have a TypeScript with it's name. Inside this file I'll have a main function and use the Deno idiom `if (import.meta.main) main();` to invoke it. I don't generally put the command line  TypeScript in my \"mod.ts\" file since it's not going to work in a browser or be useful outside my specific project.\n\nmod.ts\n: I usually re-export modules here that maybe useful outside my project (or in the web browser).\n\ndeps.ts\n: I use this if there are allot of files consistently being imported across the project, otherwise I skip it.\n\n## What I put in Main\n\nI use the main function to define command line options, handle parameters such as data input, output and errors. It usually invokes a primary function modeled in the rest of the project code.\n\nHere is an example Main for a simple \"cat\" like program.\n\n~~~TypeScript\nimport { parseArgs } from \"jsr:@std/cli\";\nimport { licenseText, releaseDate, releaseHash, version } from \"./version.ts\";\nimport { fmtHelp, helpText } from \"./helptext.ts\";\n\nconst appName = \"mycat\";\n\nasync function main() {\n  const app = parseArgs(Deno.args, {\n    alias: {\n      help: \"h\",\n      license: \"l\",\n      version: \"v\",\n    },\n    default: {\n      help: false,\n      version: false,\n      license: false,\n    },\n  });\n  const args = app._;\n\n  if (app.help) {\n    console.log(fmtHelp(helpText, appName, version, releaseDate, releaseHash));\n    Deno.exit(0);\n  }\n  if (app.license) {\n    console.log(licenseText);\n    Deno.exit(0);\n  }\n  if (app.version) {\n    console.log(`${appName} ${version} ${releaseHash}`);\n    Deno.exit(0);\n  }\n\n  let input: Deno.FsFile | any = Deno.stdin;\n\n  // handle case of many file names\n  if (args.length > 1) {\n    for (const arg of args) {\n      input = await Deno.open(`${arg}`);\n      for await (const chunk of input.readable) {\n        const decoder = new TextDecoder();\n        console.log(decoder.decode(chunk));\n      }\n    }\n    Deno.exit(0);\n  }\n  if (args.length > 0) {\n    input = await Deno.open(Deno.args[0]);\n  }\n  for await (const chunk of input.readable) {\n    const decoder = new TextDecoder();\n    console.log(decoder.decode(chunk));\n  }\n}\n\nif (import.meta.main) main();\n~~~\n\n## helptext.ts\n\nThe following is an example of the [helptext.ts](helptext.ts) file for the demo [mycat.ts](mycat.ts).\n\n```TypeScript\nexport function fmtHelp(\n  txt: string,\n  appName: string,\n  version: string,\n  releaseDate: string,\n  releaseHash: string,\n): string {\n  return txt.replaceAll(\"{app_name}\", appName).replaceAll(\"{version}\", version)\n    .replaceAll(\"{release_date}\", releaseDate).replaceAll(\n      \"{release_hash}\",\n      releaseHash,\n    );\n}\n\nexport const helpText =\n  `%{app_name}(1) user manual | version {version} {release_hash}\n% R. S. Doiel\n% {release_date}\n\n# NAME\n\n{app_name}\n\n# SYNOPSIS\n\n{app_name} FILE [FILE ...] [OPTIONS]\n\n# DESCRIPTION\n\n{app_name} implements a \"cat\" like program.\n\n# OPTIONS\n\nOptions come as the last parameter(s) on the command line.\n\n-h, --help\n: display help\n\n-v, --version\n: display version\n\n-l, --license\n: display license\n\n\n# EXAMPLES\n~~~shell\n{app_name} README.md\n{app_name} README.md INSTALL.md\n~~~\n`;\n```\n\n## Generating version.ts\n\nThe [version.ts](version.ts) is generated form two files, [codemeta.json] and [LICENSE] using the CMTools, `cmt` command.\n\n~~~\ncmt codemeta.json veresion.ts\n~~~\n",
      "data": {
        "abstract": "Notes on some of the file and code idioms I'm using with Deno+TypeScript projects.",
        "author": "R. S. Doiel",
        "byline": "R. S. Doiel",
        "createDate": "2025-01-29",
        "keywords": [
          "Deno",
          "TypeScript",
          "Projects"
        ],
        "title": "Deno 2.1.7, Project Idioms"
      },
      "url": "posts/2025/01/29/project_idioms.json"
    },
    {
      "content": "\n# Working with Structured Data in Deno and TypeScript\n\nOne of the features in Go that I miss in TypeScript is Go's [DSL](https://en.wikipedia.org/wiki/Domain-specific_language \"Domain Specific Language\") for expressing data representations.  Adding JSON, YAML and XML support in Go is simple. Annotating a struct with a string expression. There is no equivalent feature in TypeScript. How do easily support multiple representations in TypeScript?\n\nLet's start with JSON. TypeScript has `JSON.stringify()` and `JSON.parse()`. So getting to JSON representation is trivial, just call the stringify method. Going from text to populated object is done with `JSON.parse`. But there is a catch.\n\nLet's take a simple object I'm defining called \"ObjectN\". The object has a single attribute \"n\". \"n\" holds a number. The initial values is set to zero. What happens when I instantiate my ObjectN then assign it the result from `JSON.parse()`.\n\n~~~TypeScript\nclass ObjectN {\n    n: number = 0;\n    addThree(): number {\n        return this.n + 3;\n    }\n}\nlet src = `{\"n\": 1}`;\nlet o: ObjectN = new ObjectN();\no = JSON.parse(src);\n// NOTE: This will fail, addThree method isn't available.\nconsole.log(o.addThree());\n~~~\n\nHuston, we have a problem. No \"addThree\" method. That is because JSON doesn't include method representation. What we really want to do is inspect the object returned by `JSON.parse()` and set the values in our ObjectN accordingly. Let's add a method called `fromObject()`.\n(type the following into the Deno REPL).\n\n~~~TypeScript\nclass ObjectN {\n    n: number = 0;\n    addThree(): number {\n        return this.n + 3;\n    }\n    fromObject(o: {[key: string]: any}): boolean {\n        if (o.n === undefined) {\n            return false;\n        }\n        // Validate that o.n is a number before assigning it.\n        const n = (new Number(o.n)).valueOf();\n        if (isNaN(n)) {\n            return false;\n        }\n        this.n = n;\n        return true;\n    }\n}\nlet src = `{\"n\": 1}`;\nlet o: ObjectN = new ObjectN();\nconsole.log(o.addThree());\no.fromObject(JSON.parse(src));\nconsole.log(o.addThree());\n~~~\n\nNow when we run this code we should see a \"3\" and then a \"4\" output. Wait, `o.fromObject(JSON.parse(src));` looks weird. Why not put `JSON.parse()` inside \"fromObject\"? Why not renamed it \"parse\"?\n\nI want to support many types of data conversion like YAML or XML. I can use my \"fromObject\" method with the result of produced from `JSON.parse()`, `yaml.parse()` and `xml.parse()`. One function works with the result of all three. Try adding this.\n\n~~~TypeScript\nimport * as yaml from 'jsr:@std/yaml';\nimport * as xml from \"jsr:@libs/xml\";\nsrc = `n: 2`;\no.fromObject(yaml.parse(src));\nconsole.log(o.addThree());\nsrc = `<n>3</n>`;\no.fromObject(xml.parse(src));\nconsole.log(o.addThree());\n~~~\n\nThat works!\n\nStill it would be nice to have a \"parse\" method too. How do I do that without winding up with a \"parseJSON()\", \"parseYAML()\" and \"parseXML()\"? What I really want is a \"parseWith\" method which accepts the text and a parse function. TypeScript expects type information about the function being passed. I solve that problem by including a \"ObjectParseType\" definition that works across the three parsing objects -- JSON, yaml and xml.\n\n~~~TypeScript\nimport * as yaml from 'jsr:@std/yaml';\nimport * as xml from \"jsr:@libs/xml\";\n\n// This defines my expectations of the parse function provide by JSON, yaml and xml.\ntype ObjectParseType = (arg1: string, arg2?: any) => {[key: string]: any} | unknown;\n\nclass ObjectN {\n    n: number = 0;\n    addThree(): number {\n        return this.n + 3;\n    }\n    fromObject(o: {[key: string]: any}) : boolean {\n        if (o.n === undefined) {\n            return false;\n        }\n        // Validate that o.n is a number before assigning it.\n        const n = (new Number(o.n)).valueOf();\n        if (isNaN(n)) {\n            return false;\n        }\n        this.n = n;\n        return true;\n    }\n    parseWith(s: string, fn: ObjectParseType): boolean {\n        return this.fromObject(fn(s) as unknown as {[key: string]: any});\n    }\n}\n\nlet o: ObjectN = new ObjectN();\nconsole.log(`Initial o.addThree() -> ${o.addThree()}`);\nconsole.log(`o.toString() -> ${o.toString()}`);\n\nlet src = `{\"n\": 1}`;\no.parseWith(src, JSON.parse);\nconsole.log(`parse with JSON, o.addThree() -> ${o.addThree()}`);\nconsole.log(`JSON.stringify(o) -> ${JSON.stringify(o)}`);\n\nsrc = `n: 2`;\no.parseWith(src, yaml.parse);\nconsole.log(`parse with yaml, o.addThree() -> ${o.addThree()}`);\nconsole.log(`yaml.stringify(o) -> ${yaml.stringify(o)}`);\n\nsrc = `<?xml version=\"1.0\"?>\n<n>3</n>`;\no.parseWith(src, xml.parse);\nconsole.log(`parse with xml, o.addThree() -> ${o.addThree()}`);\nconsole.log(`xml.stringify(o) -> ${xml.stringify(o)}`);\n~~~\n\nAs long as the parse method returns an object I can now update my ObjectN instance\nfrom the attributes of the object expressed as JSON, YAML, or XML strings. I like this approach because I can add validation and normalization in my \"fromObject\" method and use for any parse method that confirms to how JSON, YAML or XML parse works. The coding cost is the \"ObjectParseType\" type definition and the \"parseWith\" method boiler plate and defining a class specific \"fromObject\". Supporting new representations does require changes to my class definition at all.\n",
      "data": {
        "abstract": "A short discourse on working with structured data in TypeScript and easily\nconverting from JSON, YAML and XML representations.\n",
        "createDate": "2025-02-03",
        "keywords": [
          "Deno",
          "TypeScript",
          "Structured Data"
        ],
        "title": "Working with Structured Data in Deno and TypeScript"
      },
      "url": "posts/2025/02/03/working_with_structured_data.json"
    },
    {
      "content": "\n# Book review, \"Man and the Computer\"\n\nBy R. S. Doiel, 2025-02-10\n\nOpen Library has a wonderful collection of classic Computer related texts. This is a review of one of them.  \"Man and the Computer\" was written by [John G. Kemeny](https://en.wikipedia.org/wiki/John_G._Kemeny) and published in 1972. The book covers the evolution of the Dartmouth Time Sharing System (DTSS) and BASIC[^1].\n\n[^1]: Prof. Kemeny was co-developer of BASIC along with [Thomas Kurtz](https://en.wikipedia.org/wiki/Thomas_E._Kurtz) The author, Kemeny, as a math professor at Dartmouth and eventual became president of the university.\n\nIt is an interesting weekend read. You can read the text at [Open Library](https://openlibrary.org/books/OL5282840M/Man_and_the_computer). The book is short (160 pages or so). It is written for casual reading like a talk given to a small group. \n\nThe first part goes into the innovations that resulted for the undergraduate students who used, developed and extended the systems. The later part of the book covers what the implications of the system had been by the 1970s and what it suggestions for the future through 1990. Given that the book was written before DARPAnet, before Internet and before “Personal Computers” a surprising amount of the  Kemeny's predictions were on target and remaining relevant today. He anticipated Open Access and Cloud Computing and the benefits the were possible. My take away is it is a charming reflection of where computing was at for Dartmouth and its alumni in the start of the 1970s.\n\nStepping back to a bigger picture of computing in the 1960s and 1970s the book does have blind spots.  This is not surprising because the communications were so much more restrictive before the Internet in terms of technical exchange in computing. It is no wonder that there is but one line that mentions the innovations in time-sharing that occurred at RAND with the [Johniac Open Shop System](https://en.wikipedia.org/wiki/JOSS) (aka. JOSS-1, JOSS-2). They system have some parallels with the early DTSS/BASIC incarnations and may have preceded by as much as a few years[^2]. JOSS lead to other systems like CAL, PIL/I, FOCAL and MUMPs. The later, like JOSS, bare similarities to what would be developed at Dartmouth in the form of BASIC.\n\n[^2]: JOSS dates from approximately 1963 and DTSS was released in 1964. Kemeny was published in research memorandum in 1953 and probably talked about his ideas. https://en.wikipedia.org/wiki/JOSS\n\nIt is quite reasonable for this text to the have these blind spots. First it was not intended to be a history of computing (see the Preface of the book) but rather a high level look at what the promise was for people who could work interactively with a computer. I feel it gives insights into the early era where computing access was rapidly increasing and the sense of promise that carried. Well worth the reading time if you're a hobbyist or arm chair computer history buff.\n",
      "data": {
        "abstract": "A book review of a vintage computer publication, \"Man and the Computer\" by\nJohn G. Kemeny, published 1972, ISBN: 0684130092\nRead at the Open Library, <https://openlibrary.org/books/OL5282840M/Man_and_the_computer> \n",
        "author": "R. S. Doiel",
        "byline": "R. S. Doiel, 2025-02-10",
        "createDate": "2025-02-10",
        "keywords": [
          "book review",
          "computing",
          "basic",
          "time-sharing",
          "John G. Kemeny"
        ],
        "series": "books",
        "title": "Book review, \"Man and the Computer\""
      },
      "url": "posts/2025/02/10/Man_and_the_Computer.json"
    },
    {
      "content": "\n# Setting up my Raspberry Pi 500, a Portable Workstation\n\nBy R. S. Doiel, 2025-02-14\n\nI'm  writing this on a newly setup Raspberry Pi 500. So far I'm impressed. I was sceptical about moving from my Pi 400 but when it died I was forced to upgrade. It has been worth it.\n\nI've now had a chance to install the various pieces of software I regularly use. Even do some web browsing with it. Image some SD cards for a RISC OS project I'm working on. It feels much quicker than my Pi 400. I think the speed increase is in part the faster CPU but I suspect the program I am running is taking advantage of the 8 Gig RAM instead of the old 4. As I've testing this machine out I noticed I had stopped asking myself the question about launching more than one large program at a time (e.g. my browser is running and being used as I type this in VS Code). When I tried VS Code on my Pi 4B+ and 400 it just felt too sluggish. I'm typing this review in VS Code now on the Pi 500 is keeping up OK.\n\nWhen I purchased the Pi-500 and I also decided to go with the new Raspberry Pi Monitor. Together I have a complete portable workstation. While my previous powered WaveShare monitor was higher resolution the Pi Monitor it  also used allot more power.  With the combination of Pi Monitor and Pi-500 I am now contemplating exploring power consumption so I can find a one battery to power the monitor and Pi-500.\n\nHere's the spec and pricing for this new machine. Some parts I didn't purchase because I already owned them (e.g. the 27W Pi power supply) but I have included the list prices for those who might be interested.\n\nItem                                List Price    Notes                   \n----------------------------------  ------------  -----------------------\nRaspberry Pi 500 unit               $90.00        included  32G SD card  \nRaspberry Pi 27W Power supply       $13.65        used existing one      \nRaspberry Pi Mouse                  $9.25         used existing one      \nMicro HDMI to standard HDMI cable   $5.75         used existing one      \nRaspberry Pi Monitor                $100.00                              \nRaspberry Pi 15W Power supply       $8.00         for monitor            \nRaspberry Pi 128G SD Card           $16.95        upgraded storage       \n\n\n## Software Setup\n\nI created an \"image\" on my 128G SD Card using the Raspberry Pi Imager on another computer.  The imager lets you setup initial user account, WiFi configuration and whether you want SSH services running the first boot. I like using the vanilla 64 bit Raspberry Pi OS distribution. I picked the one for the Raspberry Pi 5 series.\n\nWhen I booted the Pi-500 connected to the Pi Monitor it seemed to cause the screen to cycle through and Pi splash page a few times. Once it completed its first boot it hasn't done that again. I am assuming that was some negotiation between the monitor and the Pi. After a quick click around test I rebooted the machine by doing a full shutdown and power off and the power back up.\n\n### Development and Writing Software\n\nI am planning to use the Pi-500 as a light weight development machine and as a machine for preparing updates for my blog. I installed the additional software below.\n\n- Pandoc 3 via installed via deb package from Pandoc GitHub releases\n- Rust installed via Rustup\n- PageFind installed via Cargo\n- Flatlake installed via Cargo\n- htmlq installed via Cargo\n- ncal installed via Cargo\n- Deno installed via website using CURL\n- Go installed via website's tar ball\n- jq installed via apt\n- SQLite3, libsqlite3-dev installed via apt\n- Hunspell and US English dictionary installed via apt\n\nThe \"build-essential\" package was already installed. I noticed that Git and GNU Make were immediately available with my first boot.\n\nI this setup as a portable  workstation. It feels quick and snappy but is small enough to toss in computer bag. I did test compile a few things. It is possible to peg the CPU but then again it's a little machine after all. I didn't get any warning lights or notifications like I used to on the Pi-400.\n\nWith a connection to my home WiFi network (not a fast connection) it took me about an hour or so to download and install all my extras. This was quicker than the last time I setup a Pi. Some of the time saved was the better hardware and net work performance but much of the time saved was due to the fact that I did not have to compile software from scratch. That was a change from the last time I setup a Pi up.  I guess  Pi and aarch64 processors are common enough that projects are now including it in their regular builds.\n\nIf  I pickup the right capacity battery I suspect I will have a lovely deconstructed Laptop to use as a portable workstation.\n\n",
      "data": {
        "abstract": "Quick notes on configuring a Raspberry Pi 500 as a portable workstation along with a price list.\n",
        "author": "R. S. Doiel",
        "byline": "R. S. Doiel, 2025-02-14",
        "dateCreated": "2025-02-14",
        "keywords": [
          "Raspberry Pi",
          "Workstation",
          "Review"
        ],
        "title": "Setting up my Raspberry Pi 500, a Portable Workstation"
      },
      "url": "posts/2025/02/14/Review_Pi-500_as_portable_workstation.json"
    },
    {
      "content": "",
      "data": {},
      "url": "posts/footer.json"
    },
    {
      "content": "\n### Recent Posts\n\n- [Build a Static Web Server with Deno](/blog/2025/06/30/Build_a_Static_Web_Server.md), 2025-06-30\n- [Rethinking REST](/blog/2025/06/07/Rethinking-REST.md), 2025-06-07\n- [PowerShell and Edit for macOS, Linux and Windows](/blog/2025/06/05/PowerShell_and_Edit.md), 2025-06-05\n- [A quick note on types in Deno+TypeScript](/blog/2025/05/25/a_quick_notes_on_types.md), 2025-05-25\n- [New Life for Fielded Search](/blog/2025/04/10/New_Life_for_Fielded_Search.md), 2025-04-10\n- [LLM first impressions a few weeks in](/blog/2025/03/30/LLM_first_impressions_a_few_weeks_in.md), 2025-03-30\n- [Building Web Components using Large Language Models](/blog/2025/03/13/Building_Web_Component_using_an_LLM.md), 2025-03-13\n- [Setting up my Raspberry Pi 500, a Portable Workstation](/blog/2025/02/14/Review_Pi-500_as_portable_workstation.md), 2025-02-14\n- [Book review, \"Man and the Computer\"](/blog/2025/02/10/Man_and_the_Computer.md), 2025-02-10\n- [Working with Structured Data in Deno and TypeScript](/blog/2025/02/03/working_with_structured_data.md), 2025-02-03\n- [Moving beyond git template repositories with CodeMeta](/blog/2025/01/31/moving_beyond_git_templates.md), 2025-01-31\n- [Deno 2.1.7, Project Idioms](/blog/2025/01/29/project_idioms.md), 2025-01-29\n- [Deno 2.1.7, Points of Friction](/blog/2025/01/26/points_of_friction.md), 2025-01-26\n\n2024\n----\n\n - 12-13, [Installing Deno via Cargo and other options](/blog/2024/12/13/installing-via-cargo-etc.md)\n - 12-06, [When Deno+TypeScript, when Go?](/blog/2024/12/06/when_deno_when_go.md)\n - 11-21, [Transpiling & Bundling with Emit](/blog/2024/11/21/transpiling-and-bundling-with-emit.md)\n - 11-20, [Raspberry Pi 4 & 400 Power Supply Issues](/blog/2024/11/20/power-supply-issues.md)\n - 11-06, [Rust tools for Web Work](/blog/2024/11/06/rust-tools-for-web-work.md)\n - 10-31, [SQLite3 json_patch is a jewel](/blog/2024/10/31/sqlite3_json_patch.md)\n - 10-31, [Limit and offset for row pruning](/blog/2024/10/31/limit_and_offset_for_row_pruning.md)\n - 10-18, [Quick tour of Deno 2.0.2](/blog/2024/10/18/a-quick-tour-of-deno-2.md)\n - 07-08, [Web GUI and Deno](/blog/2024/07/08/webgui_and_deno.md)\n - 07-03, [Transpiling with Deno](/blog/2024/07/03/transpiling_with_deno.md)\n - 06-14, [Bootstrapping a Text Oriented Web](/blog/2024/06/14/tow_bootstraping.md)\n - 06-08, [RISC OS 5.30, GCC 4.7 and Hello World](/blog/2024/06/08/riscos_gcc_and_hello.md)\n - 06-04, [Exploring RISC OS 5.30 on a Raspberry Pi Zero W](/blog/2024/06/04/exploring_riscos.md)\n - 05-10, [A quick review of Raspberry Pi Connect](/blog/2024/05/10/quick-review-rpi-connect.md)\n - 05-10, [Building Lagrange on Raspberry Pi OS](/blog/2024/05/10/building-lagrange-on-pi-os.md)\n - 04-25, [Getting Started with Miranda](/blog/2024/04/25/getting-started.md)\n - 02-25, [A Text Oriented Web](/blog/2024/02/25/text_oriented_web.md)\n - 02-23, [Two missing features from HTML5, an enhanced form.enctype and a list input type](/blog/2024/02/23/enhanced_form_handling.md)\n - 02-01, [Installing pgloader from source](/blog/2024/02/01/installing-pgloader-from-source.md)\n - 01-31, [vis for vi and fun](/blog/2024/01/31/vis-for-vi-and-fun.md)\n - 01-04, [Updated recipe, compiling PostgREST 12.0.2 (M1)](/blog/2024/01/04/updated-recipe-compiling-postgrest_v12.0.2.md)\n\n2023\n----\n\n - 12-23, [Finding Bluesky RSS feeds](/blog/2023/12/23/finding-blue-sky-rss-feeds.md)\n - 12-07, [RSS and my web experience](/blog/2023/12/07/rss-and-my-web-experience.md)\n - 11-17, [Postgres Quick Notes, take two](/blog/2023/11/17/PostgreSQL-Quick-Notes.md)\n - 10-18, [Building A to Z list pages in Pandoc](/blog/2023/10/18/A-to-Z-lists.md)\n - 10-06, [Skimmer](/blog/2023/10/06/concept.md)\n - 07-05, [Quick recipe, compiling PostgREST (M1)](/blog/2023/07/05/quick-recipe-compiling-PostgREST-M1.md)\n - 07-05, [Quick recipe, compiling Pandoc (M1)](/blog/2023/07/05/quick-recipe-compiling-Pandoc-M1.md)\n - 05-20, [gsettings command](/blog/2023/05/20/gsettings-commands.md)\n - 03-10, [First Personal Search Engine Prototype](/blog/2023/03/10/first-prototype-pse.md)\n - 03-07, [Prototyping a personal search engine](/blog/2023/03/07/prototyping-a-personal-search-engine.md)\n - 01-03, [SQL query to CSV, a missing datatool](/blog/2023/01/03/sql-to-csv-a-missing-datatool.md)\n\n2022\n----\n\n - 12-12, [Go and MySQL timestamps](/blog/2022/12/12/Go-and-MySQL-Timestamps.md)\n - 12-05, [Progress and time remaining](/blog/2022/12/05/progress-and-time-remaining.md)\n - 11-28, [Pandoc, Pagefind and Make](/blog/2022/11/28/pandoc-pagefind-and-make.md)\n - 11-21, [Initial Impressions of Pagefind](/blog/2022/11/21/initial-impressions-pagefind.md)\n - 11-18, [Browser based site search](/blog/2022/11/18/browser-side-site-search.md)\n - 11-17, [Revealing the Pandoc AST](/blog/2022/11/17/revealing-pandoc-ast.md)\n - 11-11, [Twitter's pending implosion](/blog/2022/11/11/Twitter-implosion.md)\n - 11-07, [Compiling Pandoc from source](/blog/2022/11/07/compiling-pandoc-from-source.md)\n - 11-01, [Installing Cargo/Rust on Raspberry Pi 400](/blog/2022/11/01/installing-cargo-rust-r400.md)\n - 11-01, [feeds, formats and plain text](/blog/2022/11/01/Feeds-formats-and-plain-text.md)\n - 10-18, [7:30 AM, Oberon Language: A minimum SYSTEM module](/blog/2022/10/18/Wishlist-Oberon-in-2023-2022-10-18_070730.md)\n - 10-16, [Wish list for Oberon in 2023](/blog/2022/10/16/Wishlist-Oberon-in-2023.md)\n - 10-10, [7:30 AM, Gopher: Setup](/blog/2022/10/10/getting-things-setup-2022-10-10_070730.md)\n - 10-09, [Getting things setup](/blog/2022/10/09/getting-things-setup.md)\n - 09-28, [Thinking about Gopher](/blog/2022/09/28/thinking-about-gopher.md)\n - 09-27, [Rust development notes](/blog/2022/09/27/rust-development-notes.md)\n - 09-26, [7:30 AM, Golang: pttk](/blog/2022/09/26/golang-development-2022-09-26_070730.md)\n - 09-19, [12:30 PM, SQL: Postgres](/blog/2022/09/19/rosette-notes-2022-09-19_121230.md)\n - 09-19, [PostgreSQL dump and restore](/blog/2022/09/19/PostgreSQL-Dump-and-Restore.md)\n - 08-30, [Ordering front matter](/blog/2022/08/30/Ordering-Frontmatter.md)\n - 08-26, [10:30 AM, SQL: Postgres](/blog/2022/08/26/rosette-notes-2022-08-26_101030.md)\n - 08-26, [Postgres 14 on Ubuntu 22.04 LTS](/blog/2022/08/26/postgres-14-on-ubuntu-22.04-LTS.md)\n - 08-24, [12:00 PM, SQL: Postgres](/blog/2022/08/24/rosette-notes-2022-08-24_121200.md)\n - 08-24, [A Quick into to PL/pgSQL](/blog/2022/08/24/plpgsql-quick-intro.md)\n - 08-22, [11:30 AM, SQL: Postgres](/blog/2022/08/22/rosette-notes-2022-08-22_111130.md)\n - 08-19, [Rosette Notes: Postgres and MySQL](/blog/2022/08/19/rosette-notes.md)\n - 08-15, [PTTK and STN](/blog/2022/08/15/golang-development.md)\n - 08-15, [5:45 PM, Golang: ptdk,  stngo](/blog/2022/08/15/golang-development-2022-08-15_170545.md)\n - 08-14, [5:00 PM, Golang: pdtk,  stngo](/blog/2022/08/14/golang-development-2022-08-14_170500.md)\n - 08-12, [4:30 PM, Golang: stngo](/blog/2022/08/12/golang-development-2022-08-12_160430.md)\n - 07-30, [Turbo Oberon, the dream](/blog/2022/07/30/Turbo-Oberon.md)\n - 07-27, [Artemis Project Status, 2022](/blog/2022/07/27/Artemis-Status-Summer-2022.md)\n - 02-18, [Installing Golang from source on RPi-OS for arm64](/blog/2022/02/18/Installing-Go-from-Source-RPiOS-arm64.md)\n\n2021\n----\n\n - 12-18, [Notes on setting up a Mid-2010 Mac Mini](/blog/2021/12/18/Notes-on-setting-up-a-2010-Mac-Mini.md)\n - 11-27, [Setting up FreeDOS 1.3rc4 with Qemu](/blog/2021/11/27/FreeDOS-1.3rc4-with-Qemu.md)\n - 11-26, [Portable Conversions (Integers)](/blog/2021/11/26/Portable-Conversions-Integers.md)\n - 11-22, [Revisiting Files](/blog/2021/11/22/Revisiting-Files.md)\n - 06-14, [Combining Oberon-07 with C using Obc-3](/blog/2021/06/14/Combining-Oberon-07-with-C-using-Obc-3.md)\n - 05-16, [Beyond Oakwood, Modules and Aliases](/blog/2021/05/16/Beyond-Oakwood-Modules-and-Aliases.md)\n - 04-25, [Ofront on Raspberry Pi OS](/blog/2021/04/25/Ofront-on-Rasberry-Pi-OS.md)\n - 04-16, [Updating Schema in SQLite3](/blog/2021/04/16/Updating-Schema-in-SQLite3.md)\n - 04-02, [A2 Oberon on VirtualBox 6.1](/blog/2021/04/02/A2-Oberon-on-VirtualBox-6.1.md)\n - 03-17, [ETH Oberon System 3 on VirtualBox 6.1](/blog/2021/03/17/NativeOberon-VirtualBox.md)\n\n2020\n----\n\n - 12-24, [RetroFlag GPi Case Setup](/blog/2020/12/24/gpi-case-setup.md)\n - 11-27, [Dates](/blog/2020/11/27/Dates.md)\n - 11-27, [Dates & Clock](/blog/2020/11/27/Dates-and-Clock.md)\n - 11-27, [Clock](/blog/2020/11/27/Clock.md)\n - 11-27, [Chars](/blog/2020/11/27/Chars.md)\n - 11-11, [Pandoc & Metadata](/blog/2020/11/11/Pandoc-Metadata.md)\n - 11-09, [Pandoc Partials](/blog/2020/11/09/Pandoc-Partials.md)\n - 10-31, [Software Tools, Filters](/blog/2020/10/31/Filters.md)\n - 10-19, [Assembling Pages](/blog/2020/10/19/Assemble-pages.md)\n - 10-03, [Oberon to Markdown](/blog/2020/10/03/Oberon-to-markdown.md)\n - 09-29, [Software Tools, Getting Started](/blog/2020/09/29/Software-Tools-1.md)\n - 08-15, [Portable Oberon-07](/blog/2020/08/15/Portable-Oberon-07.md)\n - 07-08, [Words Matter](/blog/2020/07/08/words-matter.md)\n - 07-07, [Procedures in records](/blog/2020/07/07/Procedures-in-records.md)\n - 06-20, [Procedures as parameters](/blog/2020/06/20/Procedures-as-parameters.md)\n - 05-25, [Dynamic types](/blog/2020/05/25/Dynamic-types.md)\n - 05-09, [Oberon-07 and the file system](/blog/2020/05/09/Oberon-07-and-the-filesystem.md)\n - 05-06, [Compiling OBNC on macOS](/blog/2020/05/06/Compiling-OBNC-on-macOS.md)\n - 05-01, [Combining Oberon-07 and C with OBNC](/blog/2020/05/01/Combining-Oberon-and-C.md)\n - 04-19, [Oberon Loops and Conditions](/blog/2020/04/19/Mostly-Oberon-Loops-and-Conditions.md)\n - 04-18, [Oberon Basic Types](/blog/2020/04/18/Mostly-Oberon-Basic-Types.md)\n - 04-12, [Oberon Modules and Procedures](/blog/2020/04/12/Mostly-Oberon-Modules.md)\n - 04-11, [Mostly Oberon](/blog/2020/04/11/Mostly-Oberon.md)\n\n2019\n----\n\n - 07-28, [FreeDOS 1.2 to Oberon System 3](/blog/2019/07/28/freedos-to-oberon-system-3.md)\n\n2018\n----\n\n - 07-22, [Review: Software Tools in Pascal](/blog/2018/07/22/software-tools-in-pascal.md)\n - 03-11, [Accessing Go from Julia](/blog/2018/03/11/accessing-go-from-julia.md)\n - 02-24, [Go based Python modules](/blog/2018/02/24/go-based-python-modules.md)\n - 02-19, [Go, Bleve and Library oriented software](/blog/2018/02/19/go-bleve-and-libraries.md)\n\n2017\n----\n\n - 12-18, [Raspbian Stretch on DELL E4310 Laptop](/blog/2017/12/18/raspbian-stretch-on-amd64.md)\n - 12-10, [Harvesting my Gists from GitHub](/blog/2017/12/10/harvesting-my-gists-from-github.md)\n - 10-20, [NodeJS, NPM, Electron](/blog/2017/10/20/node-npm-electron.md)\n - 06-16, [Cross compiling Go 1.8.3 for Pine64 Pinebook](/blog/2017/06/16/cross-compiling-go.md)\n\n2016\n----\n\n - 09-20, [Android, Termux and Dev Environment](/blog/2016/09/20/Android-Termux-Dev-environment.md)\n - 08-16, [From Markdown and Bash to mkpage](/blog/2016/08/16/From-Markdown-and-Bash-to-mkpage.md)\n - 08-15, [Exploring Bash for Windows 10 Pro](/blog/2016/08/15/Setting-up-Go-under-Bash-for-Windows-10.md)\n - 07-04, [How to make a Pi-Top more Raspbian](/blog/2016/07/04/How-To-Make-A-PiTop-More-Raspbian.md)\n - 05-30, [Instant Articles, Accelerated Mobile Pages, Twitter Cards and Open Graph](/blog/2016/05/30/amp-cards-and-open-graph.md)\n - 05-28, [OPML to Markdown and back](/blog/2016/05/28/OPML-to-Markdown-and-back.md)\n\n",
      "data": {
        "title": "Robert's ramblings"
      },
      "url": "posts/index.json"
    },
    {
      "content": "",
      "data": {},
      "url": "posts/nav.json"
    }
  ]
}