{
  "page": 5,
  "total_pages": 6,
  "has_more": true,
  "next_page": "posts/all/page-6.json",
  "values": [
    {
      "content": "\n# Deno 2.1.7, Project Idioms\n\nI've noticed a collection of file and code idioms I've been used in my recent Deno+TypeScript projects at work. I've captured them here as a future reference.\n\n## Project files\n\nMy project generally have the following files, these are derived from the [CodeMeta](https://codemeta.github.io) file using [CMTools](https://caltechlibrary.github.io/CMTools).\n\ncodemeta.json\n: Primary source of project metadata, used to generate various files\n\nCITATION.cff\n: used by GitHub for citations. version, dateModified, datePublished and releaseNotes\n\n\nabout.md\n: A project about page. This is generated based on the codemeta.json file.\n\nREADME.md, README\n: A general read me describing the project and pointing to INSTALL.md, user_manual.md as appropriate\n\nINSTALL.md\n: These are boiler plate description of how to install and compile the software\n\nuser_manual.md\n: This is an index document, a table of contents. It points to other document including Markdown versions of the man page(s).\n\nFor TypeScript projects I also include a following\n\nversion.ts\n: This hold project version information used in the TypeScript co-debase. It is generated from the codemeta.json via CMTools.\n\nhelptext.ts\n: This is where I place a function, `fmtHelp()`, for rendering response to the \"help\" command line option.\n\nI'm currently ambivalent about \"main.ts\" file which is created by `deno init`. My ambivalent is that most of my projects wind up producing more than one program from a shared code base. a single \"main.ts\" doesn't really fit that situation.\n\nThe command line tool will have a TypeScript with it's name. Inside this file I'll have a main function and use the Deno idiom `if (import.meta.main) main();` to invoke it. I don't generally put the command line  TypeScript in my \"mod.ts\" file since it's not going to work in a browser or be useful outside my specific project.\n\nmod.ts\n: I usually re-export modules here that maybe useful outside my project (or in the web browser).\n\ndeps.ts\n: I use this if there are allot of files consistently being imported across the project, otherwise I skip it.\n\n## What I put in Main\n\nI use the main function to define command line options, handle parameters such as data input, output and errors. It usually invokes a primary function modeled in the rest of the project code.\n\nHere is an example Main for a simple \"cat\" like program.\n\n~~~TypeScript\nimport { parseArgs } from \"jsr:@std/cli\";\nimport { licenseText, releaseDate, releaseHash, version } from \"./version.ts\";\nimport { fmtHelp, helpText } from \"./helptext.ts\";\n\nconst appName = \"mycat\";\n\nasync function main() {\n  const app = parseArgs(Deno.args, {\n    alias: {\n      help: \"h\",\n      license: \"l\",\n      version: \"v\",\n    },\n    default: {\n      help: false,\n      version: false,\n      license: false,\n    },\n  });\n  const args = app._;\n\n  if (app.help) {\n    console.log(fmtHelp(helpText, appName, version, releaseDate, releaseHash));\n    Deno.exit(0);\n  }\n  if (app.license) {\n    console.log(licenseText);\n    Deno.exit(0);\n  }\n  if (app.version) {\n    console.log(`${appName} ${version} ${releaseHash}`);\n    Deno.exit(0);\n  }\n\n  let input: Deno.FsFile | any = Deno.stdin;\n\n  // handle case of many file names\n  if (args.length > 1) {\n    for (const arg of args) {\n      input = await Deno.open(`${arg}`);\n      for await (const chunk of input.readable) {\n        const decoder = new TextDecoder();\n        console.log(decoder.decode(chunk));\n      }\n    }\n    Deno.exit(0);\n  }\n  if (args.length > 0) {\n    input = await Deno.open(Deno.args[0]);\n  }\n  for await (const chunk of input.readable) {\n    const decoder = new TextDecoder();\n    console.log(decoder.decode(chunk));\n  }\n}\n\nif (import.meta.main) main();\n~~~\n\n## helptext.ts\n\nThe following is an example of the [helptext.ts](helptext.ts) file for the demo [mycat.ts](mycat.ts).\n\n```TypeScript\nexport function fmtHelp(\n  txt: string,\n  appName: string,\n  version: string,\n  releaseDate: string,\n  releaseHash: string,\n): string {\n  return txt.replaceAll(\"{app_name}\", appName).replaceAll(\"{version}\", version)\n    .replaceAll(\"{release_date}\", releaseDate).replaceAll(\n      \"{release_hash}\",\n      releaseHash,\n    );\n}\n\nexport const helpText =\n  `%{app_name}(1) user manual | version {version} {release_hash}\n% R. S. Doiel\n% {release_date}\n\n# NAME\n\n{app_name}\n\n# SYNOPSIS\n\n{app_name} FILE [FILE ...] [OPTIONS]\n\n# DESCRIPTION\n\n{app_name} implements a \"cat\" like program.\n\n# OPTIONS\n\nOptions come as the last parameter(s) on the command line.\n\n-h, --help\n: display help\n\n-v, --version\n: display version\n\n-l, --license\n: display license\n\n\n# EXAMPLES\n~~~shell\n{app_name} README.md\n{app_name} README.md INSTALL.md\n~~~\n`;\n```\n\n## Generating version.ts\n\nThe [version.ts](version.ts) is generated form two files, [codemeta.json] and [LICENSE] using the CMTools, `cmt` command.\n\n~~~\ncmt codemeta.json veresion.ts\n~~~\n",
      "data": {
        "abstract": "Notes on some of the file and code idioms I'm using with Deno+TypeScript projects.",
        "author": "R. S. Doiel",
        "byline": "R. S. Doiel",
        "createDate": "2025-01-29",
        "keywords": [
          "Deno",
          "TypeScript",
          "Projects"
        ],
        "title": "Deno 2.1.7, Project Idioms"
      },
      "url": "posts/2025/01/29/project_idioms.json"
    },
    {
      "content": "\n# Deno 2.1.7, Points of Friction\n\nBy R. S. Doiel, 2025-01-26\n\nI have run into a few points of friction in my journey with Deno coming from Go. I miss Go's standard \"io\" and \"bufio\" packages. With the Go code I'm porting TypeScript I'd often need to handle standard input or input from a named file interchangeably. Seems like this should be easy in Deno's TypeScript but there are a few bumps in the road.\n\nHere's the Go idiom I commonly use.\n\n~~~go\nvar err error\ninput := io.Stdin\nif inFilename != \"\" {\n    input, err := os.Open(inFilename)\n    if err !== nil {\n        // ... handle error\n    }\n    defer input.Close();\n}\n// Now I can just pass \"in\" around for processing.\n~~~\n\nConceptually this feels simple though verbose. I can pass around the \"input\" for processing in a way that is agnostic as to file or standard input. This type of Go code works equally on POSIX and Windows.\n\nDeno provide access to [standard input](https://docs.deno.com/api/deno/~/Deno.stdin). Deno supports streamable files. From the docs here's an simple example.\n\n~~~TypeScript\n// If the text \"hello world\" is piped into the script:\nconst buf = new Uint8Array(100);\nconst numberOfBytesRead = await Deno.stdin.read(buf); // 11 bytes\nconst text = new TextDecoder().decode(buf);  // \"hello world\"\n~~~\n\nSetting aside the buffer management code it seems simple and straight forward. It is easy to understand and you could wrap it in a function easily to hide the buffer management part. Yet it doesn't provide the same flexibility as the more verbose Go version. Surely there is an an idiomatic why of doing this in TypeScript already? \n\n## Stability Challenge\n\nDeno currently is a rapidly evolving platform. My first impulse was to reach for packages like `jsr:@std/fs` or `jsr:@sys/fs`. When I search for examples they mostly seem to reference specific versions of \"std/fs\" that are not available via jsr. So what's the \"right\" way to approach this?\n\n## Repl to the rescue.\n\nPoking around in the Deno repl I tried assigning `Deno.stdin` to a local variable. Playing with command line completion I realized it has most of the the methods you would get if you used `Deno.open()` to open a named file.\n\nHere's a little test I ran in the repl after creating a \"hellworld.txt\" text file.\n\n~~~deno\ndeno\nconst stdin = Deno.stdin;\nlet input = Deno.open('helloworld.txt')\nstdin.isTerminal();\ninput.isTerminal();\nstdin.valueOf();\ninput.valueOf();\nDeno.exit(0);\n~~~\n\nThe `valueOf()` reveals their type affiliation. It listed them as `Stdin {}` and `FsFile {}` respectively. I used TypeScript's typing system to let us implement \"mycat.ts\". You can assign multiple types to a variable with a `|` (pipe) symbol in TypeScript. \n\nUsed that result to write a simple cat file implementation.\n\n~~~TypeScript\nasync function catFile() {\n    let input : Stdin | FsFile = Deno.stdin;\n\n    if (Deno.args.length > 0) {\n        input = await Deno.open(Deno.args[0]);\n    }\n\n    const decoder = new TextDecoder();\n\n    // NOTE: the .readable function is available on both types of objects.\n    for await (const chunk of input.readable) {\n        console.log(decoder.decode(chunk));\n    }\n}\n\nif (import.meta.main) catFile();\n~~~\n\nYou can \"run\" this deno to see it in action. Try running it on your \"helloworld.txt\" file.\n\n~~~shell\ndeno run --allow-read mycat.ts helloworld.txt\n~~~\n\nYou can also read from standard input too. Try the command below type in some text then press Ctrl-D or Ctrl-Z if you're on Windows.\n\n~~~shell\ndeno run --allow-read mycat.ts\n~~~\n\nLooks like we have a nice solution. Now I can compile \"mycat.ts\".\n\n## trouble in paradise\n\nWhile you can \"run\" the script you can't compile it. It doesn't pass \"check\". This is the error I get with Deno 2.1.7.\n\n~~~shell\ndeno check mycat.ts\nCheck file:///C:/Users/rsdoi/Sandbox/Writing/Articles/Deno/mycat.ts\nerror: TS2304 [ERROR]: Cannot find name 'Stdin'.\n    let input : Stdin | FsFile = Deno.stdin;\n                ~~~~~\n    at file:///C:/Users/rsdoi/Sandbox/Writing/Articles/Deno/mycat.ts:3:17\n\nTS2552 [ERROR]: Cannot find name 'FsFile'. Did you mean 'File'?\n    let input : Stdin | FsFile = Deno.stdin;\n                        ~~~~~~\n    at file:///C:/Users/rsdoi/Sandbox/Writing/Articles/Deno/mycat.ts:3:25\n\n    'File' is declared here.\n    declare var File: {\n                ~~~~\n        at asset:///lib.deno.web.d.ts:622:13\n\nFound 2 errors.\n~~~\n\nIt seems like what works in the repl should also compile but that's isn't the case. I have an open question on Deno's discord help channel and am curious to find the \"correct\" way to handle this problem.\n\n## Update 2025-01-26, 5:00PM\n\nI heard back on Deno Discord channel for help.  With the help of [crowlKat](https://github.com/crowlKats) sorted the problem out.\n\nThe compile and runnable version of [mycat.ts](mycat.ts) looks like this.\n\n~~~typescript\nasync function main() {\n    let input : Deno.FsFile | any = Deno.stdin;\n\n    if (Deno.args.length > 0) {\n        input = await Deno.open(Deno.args[0]);\n    }\n\n    const decoder = new TextDecoder();\n\n    // NOTE: the .readable function is available on both types of objects.\n    for await (const chunk of input.readable) {\n        console.log(decoder.decode(chunk));\n    }\n}\n\nif (import.meta.main) main();\n~~~\n\nThe \"any\" type feels a little ugly but since I am assinging the default value is `Deno.stdin` it covers that case where the `Deno.FsFile` covers the case of a name file.  Where does this leave me? I have a nice clean idiom that does what I want for interacting with standard input or a file stream.  Not necessarily the fast thing on the planet but it works.\n\n\n",
      "data": {
        "abstract": "A short discussion of working with file input in TypeScript+Deno coming from the\nperspective of Go's idiomatic use of io buffers.\n",
        "byline": "R. S. Doiel",
        "createdDate": "2025-01-26",
        "keywords": [
          "deno",
          "text",
          "input"
        ],
        "title": "Deno 2.1.7, Points of Friction"
      },
      "url": "posts/2025/01/26/points_of_friction.json"
    },
    {
      "content": "\n### Recent Posts\n\n- [Setting up my Raspberry Pi 500, a Portable Workstation](/blog/2025/02/14/Review_Pi-500_as_portable_workstation.md), 2025-02-14\n- [Book review, \"Man and the Computer\"](/blog/2025/02/10/Man_and_the_Computer.md), 2025-02-10\n- [Working with Structured Data in Deno and TypeScript](/blog/2025/02/03/working_with_structured_data.md), 2025-02-03\n- [Moving beyond git template repositories with CodeMeta](/blog/2025/01/31/moving_beyond_git_templates.md), 2025-01-31\n- [Deno 2.1.7, Project Idioms](/blog/2025/01/29/project_idioms.md), 2025-01-29\n- [Deno 2.1.7, Points of Friction](/blog/2025/01/26/points_of_friction.md), 2025-01-26\n\n2024\n----\n\n - 12-13, [Installing Deno via Cargo and other options](/blog/2024/12/13/installing-via-cargo-etc.md)\n - 12-06, [When Deno+TypeScript, when Go?](/blog/2024/12/06/when_deno_when_go.md)\n - 11-21, [Transpiling & Bundling with Emit](/blog/2024/11/21/transpiling-and-bundling-with-emit.md)\n - 11-20, [Raspberry Pi 4 & 400 Power Supply Issues](/blog/2024/11/20/power-supply-issues.md)\n - 11-06, [Rust tools for Web Work](/blog/2024/11/06/rust-tools-for-web-work.md)\n - 10-31, [SQLite3 json_patch is a jewel](/blog/2024/10/31/sqlite3_json_patch.md)\n - 10-31, [Limit and offset for row pruning](/blog/2024/10/31/limit_and_offset_for_row_pruning.md)\n - 10-18, [Quick tour of Deno 2.0.2](/blog/2024/10/18/a-quick-tour-of-deno-2.md)\n - 07-08, [Web GUI and Deno](/blog/2024/07/08/webgui_and_deno.md)\n - 07-03, [Transpiling with Deno](/blog/2024/07/03/transpiling_with_deno.md)\n - 06-14, [Bootstrapping a Text Oriented Web](/blog/2024/06/14/tow_bootstraping.md)\n - 06-08, [RISC OS 5.30, GCC 4.7 and Hello World](/blog/2024/06/08/riscos_gcc_and_hello.md)\n - 06-04, [Exploring RISC OS 5.30 on a Raspberry Pi Zero W](/blog/2024/06/04/exploring_riscos.md)\n - 05-10, [A quick review of Raspberry Pi Connect](/blog/2024/05/10/quick-review-rpi-connect.md)\n - 05-10, [Building Lagrange on Raspberry Pi OS](/blog/2024/05/10/building-lagrange-on-pi-os.md)\n - 04-25, [Getting Started with Miranda](/blog/2024/04/25/getting-started.md)\n - 02-25, [A Text Oriented Web](/blog/2024/02/25/text_oriented_web.md)\n - 02-23, [Two missing features from HTML5, an enhanced form.enctype and a list input type](/blog/2024/02/23/enhanced_form_handling.md)\n - 02-01, [Installing pgloader from source](/blog/2024/02/01/installing-pgloader-from-source.md)\n - 01-31, [vis for vi and fun](/blog/2024/01/31/vis-for-vi-and-fun.md)\n - 01-04, [Updated recipe, compiling PostgREST 12.0.2 (M1)](/blog/2024/01/04/updated-recipe-compiling-postgrest_v12.0.2.md)\n\n2023\n----\n\n - 12-23, [Finding Bluesky RSS feeds](/blog/2023/12/23/finding-blue-sky-rss-feeds.md)\n - 12-07, [RSS and my web experience](/blog/2023/12/07/rss-and-my-web-experience.md)\n - 11-17, [Postgres Quick Notes, take two](/blog/2023/11/17/PostgreSQL-Quick-Notes.md)\n - 10-18, [Building A to Z list pages in Pandoc](/blog/2023/10/18/A-to-Z-lists.md)\n - 10-06, [Skimmer](/blog/2023/10/06/concept.md)\n - 07-05, [Quick recipe, compiling PostgREST (M1)](/blog/2023/07/05/quick-recipe-compiling-PostgREST-M1.md)\n - 07-05, [Quick recipe, compiling Pandoc (M1)](/blog/2023/07/05/quick-recipe-compiling-Pandoc-M1.md)\n - 05-20, [gsettings command](/blog/2023/05/20/gsettings-commands.md)\n - 03-10, [First Personal Search Engine Prototype](/blog/2023/03/10/first-prototype-pse.md)\n - 03-07, [Prototyping a personal search engine](/blog/2023/03/07/prototyping-a-personal-search-engine.md)\n - 01-03, [SQL query to CSV, a missing datatool](/blog/2023/01/03/sql-to-csv-a-missing-datatool.md)\n\n2022\n----\n\n - 12-12, [Go and MySQL timestamps](/blog/2022/12/12/Go-and-MySQL-Timestamps.md)\n - 12-05, [Progress and time remaining](/blog/2022/12/05/progress-and-time-remaining.md)\n - 11-28, [Pandoc, Pagefind and Make](/blog/2022/11/28/pandoc-pagefind-and-make.md)\n - 11-21, [Initial Impressions of Pagefind](/blog/2022/11/21/initial-impressions-pagefind.md)\n - 11-18, [Browser based site search](/blog/2022/11/18/browser-side-site-search.md)\n - 11-17, [Revealing the Pandoc AST](/blog/2022/11/17/revealing-pandoc-ast.md)\n - 11-11, [Twitter's pending implosion](/blog/2022/11/11/Twitter-implosion.md)\n - 11-07, [Compiling Pandoc from source](/blog/2022/11/07/compiling-pandoc-from-source.md)\n - 11-01, [Installing Cargo/Rust on Raspberry Pi 400](/blog/2022/11/01/installing-cargo-rust-r400.md)\n - 11-01, [feeds, formats and plain text](/blog/2022/11/01/Feeds-formats-and-plain-text.md)\n - 10-18, [7:30 AM, Oberon Language: A minimum SYSTEM module](/blog/2022/10/18/Wishlist-Oberon-in-2023-2022-10-18_070730.md)\n - 10-16, [Wish list for Oberon in 2023](/blog/2022/10/16/Wishlist-Oberon-in-2023.md)\n - 10-10, [7:30 AM, Gopher: Setup](/blog/2022/10/10/getting-things-setup-2022-10-10_070730.md)\n - 10-09, [Getting things setup](/blog/2022/10/09/getting-things-setup.md)\n - 09-28, [Thinking about Gopher](/blog/2022/09/28/thinking-about-gopher.md)\n - 09-27, [Rust development notes](/blog/2022/09/27/rust-development-notes.md)\n - 09-26, [7:30 AM, Golang: pttk](/blog/2022/09/26/golang-development-2022-09-26_070730.md)\n - 09-19, [12:30 PM, SQL: Postgres](/blog/2022/09/19/rosette-notes-2022-09-19_121230.md)\n - 09-19, [PostgreSQL dump and restore](/blog/2022/09/19/PostgreSQL-Dump-and-Restore.md)\n - 08-30, [Ordering front matter](/blog/2022/08/30/Ordering-Frontmatter.md)\n - 08-26, [10:30 AM, SQL: Postgres](/blog/2022/08/26/rosette-notes-2022-08-26_101030.md)\n - 08-26, [Postgres 14 on Ubuntu 22.04 LTS](/blog/2022/08/26/postgres-14-on-ubuntu-22.04-LTS.md)\n - 08-24, [12:00 PM, SQL: Postgres](/blog/2022/08/24/rosette-notes-2022-08-24_121200.md)\n - 08-24, [A Quick into to PL/pgSQL](/blog/2022/08/24/plpgsql-quick-intro.md)\n - 08-22, [11:30 AM, SQL: Postgres](/blog/2022/08/22/rosette-notes-2022-08-22_111130.md)\n - 08-19, [Rosette Notes: Postgres and MySQL](/blog/2022/08/19/rosette-notes.md)\n - 08-15, [PTTK and STN](/blog/2022/08/15/golang-development.md)\n - 08-15, [5:45 PM, Golang: ptdk,  stngo](/blog/2022/08/15/golang-development-2022-08-15_170545.md)\n - 08-14, [5:00 PM, Golang: pdtk,  stngo](/blog/2022/08/14/golang-development-2022-08-14_170500.md)\n - 08-12, [4:30 PM, Golang: stngo](/blog/2022/08/12/golang-development-2022-08-12_160430.md)\n - 07-30, [Turbo Oberon, the dream](/blog/2022/07/30/Turbo-Oberon.md)\n - 07-27, [Artemis Project Status, 2022](/blog/2022/07/27/Artemis-Status-Summer-2022.md)\n - 02-18, [Installing Golang from source on RPi-OS for arm64](/blog/2022/02/18/Installing-Go-from-Source-RPiOS-arm64.md)\n\n2021\n----\n\n - 12-18, [Notes on setting up a Mid-2010 Mac Mini](/blog/2021/12/18/Notes-on-setting-up-a-2010-Mac-Mini.md)\n - 11-27, [Setting up FreeDOS 1.3rc4 with Qemu](/blog/2021/11/27/FreeDOS-1.3rc4-with-Qemu.md)\n - 11-26, [Portable Conversions (Integers)](/blog/2021/11/26/Portable-Conversions-Integers.md)\n - 11-22, [Revisiting Files](/blog/2021/11/22/Revisiting-Files.md)\n - 06-14, [Combining Oberon-07 with C using Obc-3](/blog/2021/06/14/Combining-Oberon-07-with-C-using-Obc-3.md)\n - 05-16, [Beyond Oakwood, Modules and Aliases](/blog/2021/05/16/Beyond-Oakwood-Modules-and-Aliases.md)\n - 04-25, [Ofront on Raspberry Pi OS](/blog/2021/04/25/Ofront-on-Rasberry-Pi-OS.md)\n - 04-16, [Updating Schema in SQLite3](/blog/2021/04/16/Updating-Schema-in-SQLite3.md)\n - 04-02, [A2 Oberon on VirtualBox 6.1](/blog/2021/04/02/A2-Oberon-on-VirtualBox-6.1.md)\n - 03-17, [ETH Oberon System 3 on VirtualBox 6.1](/blog/2021/03/17/NativeOberon-VirtualBox.md)\n\n2020\n----\n\n - 12-24, [RetroFlag GPi Case Setup](/blog/2020/12/24/gpi-case-setup.md)\n - 11-27, [Dates](/blog/2020/11/27/Dates.md)\n - 11-27, [Dates & Clock](/blog/2020/11/27/Dates-and-Clock.md)\n - 11-27, [Clock](/blog/2020/11/27/Clock.md)\n - 11-27, [Chars](/blog/2020/11/27/Chars.md)\n - 11-11, [Pandoc & Metadata](/blog/2020/11/11/Pandoc-Metadata.md)\n - 11-09, [Pandoc Partials](/blog/2020/11/09/Pandoc-Partials.md)\n - 10-31, [Software Tools, Filters](/blog/2020/10/31/Filters.md)\n - 10-19, [Assembling Pages](/blog/2020/10/19/Assemble-pages.md)\n - 10-03, [Oberon to Markdown](/blog/2020/10/03/Oberon-to-markdown.md)\n - 09-29, [Software Tools, Getting Started](/blog/2020/09/29/Software-Tools-1.md)\n - 08-15, [Portable Oberon-07](/blog/2020/08/15/Portable-Oberon-07.md)\n - 07-08, [Words Matter](/blog/2020/07/08/words-matter.md)\n - 07-07, [Procedures in records](/blog/2020/07/07/Procedures-in-records.md)\n - 06-20, [Procedures as parameters](/blog/2020/06/20/Procedures-as-parameters.md)\n - 05-25, [Dynamic types](/blog/2020/05/25/Dynamic-types.md)\n - 05-09, [Oberon-07 and the file system](/blog/2020/05/09/Oberon-07-and-the-filesystem.md)\n - 05-06, [Compiling OBNC on macOS](/blog/2020/05/06/Compiling-OBNC-on-macOS.md)\n - 05-01, [Combining Oberon-07 and C with OBNC](/blog/2020/05/01/Combining-Oberon-and-C.md)\n - 04-19, [Oberon Loops and Conditions](/blog/2020/04/19/Mostly-Oberon-Loops-and-Conditions.md)\n - 04-18, [Oberon Basic Types](/blog/2020/04/18/Mostly-Oberon-Basic-Types.md)\n - 04-12, [Oberon Modules and Procedures](/blog/2020/04/12/Mostly-Oberon-Modules.md)\n - 04-11, [Mostly Oberon](/blog/2020/04/11/Mostly-Oberon.md)\n\n2019\n----\n\n - 07-28, [FreeDOS 1.2 to Oberon System 3](/blog/2019/07/28/freedos-to-oberon-system-3.md)\n\n2018\n----\n\n - 07-22, [Review: Software Tools in Pascal](/blog/2018/07/22/software-tools-in-pascal.md)\n - 03-11, [Accessing Go from Julia](/blog/2018/03/11/accessing-go-from-julia.md)\n - 02-24, [Go based Python modules](/blog/2018/02/24/go-based-python-modules.md)\n - 02-19, [Go, Bleve and Library oriented software](/blog/2018/02/19/go-bleve-and-libraries.md)\n\n2017\n----\n\n - 12-18, [Raspbian Stretch on DELL E4310 Laptop](/blog/2017/12/18/raspbian-stretch-on-amd64.md)\n - 12-10, [Harvesting my Gists from GitHub](/blog/2017/12/10/harvesting-my-gists-from-github.md)\n - 10-20, [NodeJS, NPM, Electron](/blog/2017/10/20/node-npm-electron.md)\n - 06-16, [Cross compiling Go 1.8.3 for Pine64 Pinebook](/blog/2017/06/16/cross-compiling-go.md)\n\n2016\n----\n\n - 09-20, [Android, Termux and Dev Environment](/blog/2016/09/20/Android-Termux-Dev-environment.md)\n - 08-16, [From Markdown and Bash to mkpage](/blog/2016/08/16/From-Markdown-and-Bash-to-mkpage.md)\n - 08-15, [Exploring Bash for Windows 10 Pro](/blog/2016/08/15/Setting-up-Go-under-Bash-for-Windows-10.md)\n - 07-04, [How to make a Pi-Top more Raspbian](/blog/2016/07/04/How-To-Make-A-PiTop-More-Raspbian.md)\n - 05-30, [Instant Articles, Accelerated Mobile Pages, Twitter Cards and Open Graph](/blog/2016/05/30/amp-cards-and-open-graph.md)\n - 05-28, [OPML to Markdown and back](/blog/2016/05/28/OPML-to-Markdown-and-back.md)\n\n",
      "data": {
        "title": "Robert's ramblings"
      },
      "url": "posts/index.json"
    },
    {
      "content": "\n# Transpiling & Bundling with Emit\n\nOne of the nice features of Deno is native TypeScript support.  One of the selling strength though is that the same source can run both server side and browser side.  The challenge is that TypeScript does not have native TypeScript support. This is easy to remedy using Deno's [emit](https://jsr.io/@deno/emit) module.\n\nThe emit module supports to important functions, `transpile` and `bundle`. Both will render your TypeScript as JavaScript in a browser friendly manner. The `transpile` function turns a single TypeScript file into an equivalent JavaScript file. Bundle can do that with a TypeScript and all the files it imports so you have a self contained JavaScript file with everything you need.\n\n<!-- The emit module website shows how to write a short TypeScript program to transpile and bundle.  When you combine that with a Deno task it is trivial to automatically make that happen. -->\n\n\nHere's what my `transpile.ts` looks like.\n\n~~~typescript\nimport { transpile } from \"jsr:@deno/emit\";\nimport * as path from \"jsr:@std/path\";\n\n/* Transpile directory_client.ts to JavaScript and render it to \n   htdocs/js/directory_client.js */\nconst js_path = path.join(\"htdocs\", \"js\");\nconst js_name = path.join(js_path, \"directory_client.js\");\nconst url = new URL(\"./directory_client.ts\", import.meta.url);\nconst result = await transpile(url);\nconst code = await result.get(url.href);\n\nawait Deno.mkdir(js_path, { mode: 0o775, recursive: true });\nDeno.writeTextFile(js_name, code);\n~~~\n\nYou can run that with the following long command line.\n\n~~~shell\ndeno run --allow-import --allow-env --allow-read --allow-write --allow-net transpile.ts\n~~~\n\nOf course you can easily turn this into a [Deno task](https://docs.deno.com/runtime/reference/cli/task_runner/).\n\nIf our `directory_client.ts` file contained other modules you can instead use the `bundle` function.  Here's an example of bundling our `directory_client.ts` saving the result as `htdocs/modules/directory_client.js`.\n\n~~~typescript\n/**\n * bundle.ts is an example of \"bundling\" the type script file directory_client.ts\n * into a module and writing it to htdocs/modules.\n */\nimport { bundle } from \"jsr:@deno/emit\";\n\nconst js_path = path.join(\"htdocs\", \"modules\");\nconst js_name = path.join(js_path, \"directory_client.js\");\nconst result = await bundle(\"./directory_client.ts\");\nconst { code } = result;\nawait Deno.mkdir(js_path, { mode: 0o775, recursive: true });\nawait Deno.writeTextFile(js_name, code);\n~~~\n\nYou can run that with the following long command line.\n\n~~~shell\ndeno run --allow-import --allow-env --allow-read --allow-write --allow-net bundle.ts\n~~~\n\nThe bundle will contain the transpiled TypeScript from `directory_client.ts` but also any modules that `directory_client.ts` relied on. If you don't want to include the imported modules then you can set the value of `recursive` to false.\n",
      "data": {
        "abstract": "A brief discussion of using the Deno emit module to transpile and bundle\nTypeScript.\n",
        "byline": "R. S. Doiel, 2024-11-21",
        "keywords": [
          "Deno",
          "TypeScript",
          "transpile",
          "bundle"
        ],
        "title": "Transpiling & Bundling with Emit"
      },
      "url": "posts/2024/11/21/transpiling-and-bundling-with-emit.json"
    },
    {
      "content": "\n# Two missing features from HTML5, an enhanced form.enctype and a list input type\n\n## Robert's wish list for browsers and web forms handling\n\nBy R. S. Doiel, 2024-02-23\n\nI wish the form element supported a `application/json` encoding type and there was such a thing as a `list-input` element.\n\nI've been thinking about how we can get back to basic HTML documents and move away from JavaScript required to render richer web forms. When web forms arrived on scene in the early 1990s they included a few basic input types. Over the years a few have been added but by and large the data model has remained relatively flat. The exception being the select element with `multiple` attribute set. I believe we are being limited by the original choice of urlencoding web forms and then resort to JavaScript to address it's limitations.\n\nWhat does the encoding of a web form actually look like?  The web generally encodes the form using urlencoding. It presents a stream of key value pairs where the keys are the form's input names and the values are the value of the input element. With a multi-select element the browser simply repeats the key and adds the next value in the selection list to that key.  In Go you can describe this simple data structure as a `map[string][]string`[^1]. Most of the time a key points to a single element array of string but sometimes it can have multiple elements using that key and then the array expands to accommodate. Most of the time we don't think about this as web developers. The library provided with your programming language decodes the form into a more programmer friendly representation. But still I believe this simple urlencoding has held us back. Let me illustrate the problem through a series of simple form examples.\n\n[^1]: In English this could be described as \"a map using a string to point at a list of strings\" with \"string\" being a sequence of letters or characters.\n\nHere's an example of a simple form with a multi select box. It is asking for your choice of ice cream flavors.\n\n~~~html\n<form method=\"POST\">\n  <label for=\"ice-cream-flavors\">Choose your ice cream flavors:</label>\n  <select id=\"ice-cream-flavors\" name=\"ice-cream-flavors\" multiple >\n    <option value=\"Chocolate\">Chocolate</option>\n    <option value=\"Coconut\">Cocunut</option>\n    <option value=\"Mint\">Mint</option>\n    <option value=\"Strawberry\">Strawberry</option>\n    <option value=\"Vanilla\">Vanilla</option>\n    <option value=\"Banana\">Banana</option>\n    <option value=\"Peanut\">Peanut</option>\n  </select>\n  <p>\n  <input type=\"submit\"> <input type=\"reset\">\n</form>\n~~~\n\nBy default your web browser will packaged this up and send it using \"application/x-www-form-urlencoded\". If you select \"Coconut\" and \"Strawberry\" then the service receiving your data will get an encoded document that looks like this.\n\n~~~urlencoding\nice-cream-flavors=Coconut&ice-cream-flavors=Strawberry\n~~~\n\nThe ampersands separate the key value pairs. The fact that \"ice-cream-flavors\" name repeats means that the key \"ice-cream-flavors\" will point to an array of values.  In pretty printed JSON representation is a little clearer.\n\n~~~json\n{\n    \"ice-cream-flavors\": [ \"Coconut\", \"Strawberry\" ]\n}\n~~~\n\nSo far so good. Zero need to enhance the spec. It works and has worked for a very long time. Stability is a good thing. Let's elaborate a little further.  I've added a dish choice for the ice cream, \"Sugar Cone\" and \"Waffle Bowl\". That web form looks like.\n\n~~~html\n<form method=\"POST\">\n<label for=\"ice-cream-flavors\">Select the flavor for each scoop of ice cream:</label>\n<select id=\"ice-cream-flavors\" name=\"ice-cream-flavors\" multiple>\n  <option value=\"Chocolate\">Chocolate</option>\n  <option value=\"Coconut\">Cocunut</option>\n  <option value=\"Mint\">Mint</option>\n  <option value=\"Strawberry\">Strawberry</option>\n  <option value=\"Vanilla\">Vanilla</option>\n  <option value=\"Banana\">Banana</option>\n  <option value=\"Peanut\">Peanut</option>\n</select>\n<p>\n<fieldset>\n  <legend>Pick your delivery dish</legend>\n  <div>\n    <input type=\"radio\" id=\"sugar-cone\" name=\"ice-cream-dish\" value=\"sugar-cone\" />\n    <label for=\"sugar-cone\">Sugar Cone</label>\n  </div>\n  <div>\n    <input type=\"radio\" id=\"waffle-bowl\" name=\"ice-cream-dish\" value=\"waffle-bowl\" />\n    <label for=\"waffle-bowl\">Waffle Bowl</label>\n  </div>\n</fieldset>\n<input type=\"submit\"> <input type=\"reset\">\n</form>\n~~~\n\nIf we select \"Banana\" and \"Peanut\" flavors served in a \"Waffle Bowl\" the encoded document would reach the web service looking something like this.\n\n~~~urlencoded\nice-cream-flavors=Banana&ice-cream-flavors=Peanut&ice-cream-dish=waffle-cone\n~~~\n\nThat's not too bad. Again this is the state of web form for ages now. In JSON it could be represented as the following.\n\n~~~json\n{\n    \"ice-cream-flavors\": [ \"Banana\", \"Peanut\" ],\n    \"ice-cream-dish\": \"waffle-cone\"\n}\n~~~\n\nThis is great we have a simple web form that can collect a single ice cream order.  But what if we want to actually place several individual ice cream orders as one order? Today we have two choices, multiple web forms that accumulate the orders (circa 2000) or use JavaScript create a web UI that can handle list of form elements. Both have their drawbacks.\n\nIn the case of the old school approach changing web pages just to update an order can be slow and increase uncertainty about your current order. That is why the JavaScript approach has come to be more common. But that JavaScript approach comes at a huge price. It's much more complex, we've seen a dozens of libraries and frameworks that have come and gone trying to manage that complexity in various ways.\n\nIf we supported JSON encoded from submission directly in the web browser I think we'd make a huge step forward. It could decouple the JavaScript requirement. That would avoid much of the cruft that we ship down to the web browser today because we can't manage lists of things without resorting to JavaScript.\n\nLet's pretend there was a new input element type called \"list-input\". A \"list-input\" element can contain any combination of today's basic form elements. Here's my hypothetical `list-input` based from example. In it we're going to select the ice cream flavors and the dish format (cone, bowl) as before but have them accumulate in a list. That form could be expressed in HTML similar to my mock up below.\n\n~~~html\n<form>\n  <label for=\"ice-cream-order\">Place your next order, press submit when you have all of them.</label>\n  <list-input id=\"ice-cream-order\" name=\"ice-cream-order\">\n    <label for=\"ice-cream-flavor\">Select the flavor for each scoop of ice cream:</label>\n    <select id=\"ice-cream-flavor\" name=\"ice-cream-flavor\" multiple>\n      <option value=\"Chocolate\">Chocolate</option>\n      <option value=\"Coconut\">Cocunut</option>\n      <option value=\"Mint\">Mint</option>\n      <option value=\"Strawberry\">Strawberry</option>\n      <option value=\"Vanilla\">Vanilla</option>\n      <option value=\"Banana\">Banana</option>\n      <option value=\"Peanut\">Peanut</option>\n    </select>\n  <p>\n  <fieldset>\n    <legend>Pick your delivery dish</legend>\n    <div>\n      <input type=\"radio\" id=\"sugar-cone\" name=\"ice-cream-dish\" value=\"sugar-cone\" />\n      <label for=\"sugar-cone\">Sugar Cone</label>\n    </div>\n    <div>\n      <input type=\"radio\" id=\"waffle-bowl\" name=\"ice-cream-dish\" value=\"waffle-bowl\" />\n      <label for=\"waffle-bowl\">Waffle Bowl</label>\n    </div>\n  </fieldset>\n  </list-input>\n  <input type=\"submit\"> <input type=\"reset\">\n</form>\n~~~\n\nWith two additional lines of HTML the input form can now support a list of individual ice cream orders. Assuming only urlencoding is supported then how does that get encoded and sent to the web server? Here is an example set of orders\n\n1. vanilla ice cream with a sugar cone\n2. chocolate with a waffle bowl\n\n~~~urlencoded\nice-cream-flavors=Vanilla&ice-cream-flavors=Chocolate&ice-cream-dish=sugar-cone&ice-cream-dish=waffle-bowl\n~~~\n\nWhich flavor goes with which dish?  That's the problem with urlencoding a list in your web form. We just can't keep the data alignment manageable.  What if the web browser used JSON encoding? \n\n~~~json\n[\n  {\n      \"ice-cream-flavors\": [ \"Vanilla\" ],\n      \"ice-cream-dish\": \"sugar-cone\"\n  },\n  {\n      \"ice-cream-flavors\": [ \"Chocolate\" ],\n      \"ice-cream-dish\": \"waffle-bowl\"\n  }\n~~~\n\nSuddenly the alignment problem goes away. There is precedence for controlling behavior of the web browser submission through the `enctype` attribute. File upload was addressed by adding support for `multipart/form-data`.  In 2024 and for over the last decade it has been common practice in web services to support JSON data submission. I believe it is time that the web browser also supports this directly. This would allow us to decouple the necessity of using JavaScript in browser as we require today. The form elements already map well to a JSON encoding. If JSON encoding was enabled then adding a element like my \"list-input\" would make sense.  Otherwise we remain stuck in a world where hypertext markup language remains very limited and can't live without JavaScript.\n\n",
      "data": {
        "author": "R. S. Doiel",
        "keywords": [
          "html",
          "web forms",
          "encoding"
        ],
        "title": "Two missing features from HTML5, an enhanced form.enctype and a list input type"
      },
      "url": "posts/2024/02/23/enhanced_form_handling.json"
    },
    {
      "content": "\n# Installing Deno via Cargo and other options\n\nBy R. S. Doiel, 2024-12-13\n\nI've recently needed to install Deno on several Debian flavored Linux boxes.  I wanted to install Deno using the `cargo install --locked deno` command. Notice the `--locked` option, you need that for Deno. This worked for the recent Ubuntu 22.04 LTS release. I needed alternatives for Ubuntu 20.04 LTS and Raspberry Pi OS.\n\n## Using Cargo\n\nPrerequisites:\n\n- Rust (install with [Rustup](https://rustup.rs))\n- CMake\n- Clang, LLVM dev, Clang DEV and the lld (clang) linker\n- SQLite3 and LibSQLite3 dev\n- pkg config\n- libssh dev, libssl dev\n\nThe Debian flavors I work with are recent (Dec. 2024) Ubuntu 22.04 LTS release[^1].\n\nRecently when I was installing Deno 2.1.4 I got errors about building the `flate2` module. I had forgotten to include the `--locked` option in my cargo command. I found this solution in Deno GitHub issue [9524](https://github.com/denoland/deno/issues/9524).\n\n```shell\nsudo apt install -y build-essential cmake clang libclang-dev llvm-dev lld \\\n                    sqlite3 libsqlite3-dev pkg-config libssh-dev libssl-dev\nrustup update\ncargo install deno --locked\n```\n\n## Other options\n\nFor Ubuntu 20.04 LTS and Raspberry Pi OS, use `curl -fsSL https://deno.land/install.sh | sh` to install.\n\nFor Windows on ARM64 use `iwr https://deno.land/install.ps1 -useb | iex`.\n\n `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`\nOn Raspberry Pi OS I added a `nice` before calling `cargo`. Without the \"nice\" it failed after the \"spin\" module.\n\n[^1]: I failed to install Deno this way on Ubuntu 20.04 LTS, just use the cURL + sh script.\n",
      "data": {
        "abstract": "Notes on setting up a Debian flavored Linux boxes, macOS and Windows to install Deno via `cargo install deno`,\n`curl -fsSL https://deno.land/install.sh | sh` or\n`iwr https://deno.land/install.ps1 -useb | iex`\n",
        "byline": "R. S. Doiel, 2024-12-13",
        "createDate": "2024-12-13",
        "keywords": [
          "rust",
          "deno",
          "cargo",
          "Debian",
          "Linux",
          "windows",
          "macOS"
        ],
        "title": "Installing Deno via Cargo and other options"
      },
      "url": "posts/2024/12/13/installing-via-cargo-etc.json"
    },
    {
      "content": "\n# Postgres Quick Notes, take two\n\nBy R. S. Doiel, 2023-11-17\n\nWhat follows is some quick notes to remind me of the things I do when\nI setup a new instance of PostgreSQL on the various machines I work with.\n\n## Installation approach\n\nIf possible I install Postgres with the system's package manager or follow\nthe directions suggested for installation on the [Postgres website](https://postgres.org).\n\n### macOS and Postgres\n\nFor macOS that's not the route I take if possible is to install via [Postgres App](https://postgresapp.com/).\nThis provides a very nice setup of developing with Postgres on macOS and also allows you to easily\ntest multiple versions of Postgres.  It is not as convenient in the Mac Mini headless configuration\nI also use Postgres on macOS in. In that case I use Mac Ports' package manager to install Postgres.\nUnfortunately just using ports command isn't enough to get running. What follows is my notes on the\nadditional steps I've taken to get things working.\n\nInstall the version of Postgres you want (e.g. PostgreSQL 16) via ports\n\n1. install postgresql16, postgresql16-server, postgres_select\n2. make sure the postgres version is selected using the ports command\n3. make a directory for the default postgres db\n4. make sure the default db directory is owned by the postgres user\n5. run the initialization scripts provided by the posts installer\n6. use the ports command to load the plist\n7. start up the server, make sure the log file is writable\n\nHere's the commands I type in the shell\n\n~~~shell\nsudo port install postgresql16-server postgresql16 postgresql_select\n# Answer y to the prompt\n# After the install completes Ports will suggest the following to complete the process.\nsudo port select postgresql postgresql16\nsudo mkdir -p /opt/local/var/db/postgresql16/defaultdb\nsudo chown postgres:postgres /opt/local/var/db/postgresql16/defaultdb\nsudo -u postgres /bin/sh -c 'cd /opt/local/var/db/postgresql16 && /opt/local/lib/postgresql16/bin/initdb -D /opt/local/var/db/postgresql16/defaultdb'\nsudo port load postgresql16-server\nsudo -u postgres /bin/sh -c '/opt/local/lib/postgresql16/bin/pg_ctl -D /opt/local/var/db/postgresql16/defaultdb -l /opt/local/var/log/postgresql16/postgres.log start'\n~~~\n\n## Database users setup\n\nThis applies to most Postgres installations I do because I am using them to\ndevelop software solutions. In a production setting you'd want a more conservative\nsecurity approach.\n\n1. Make sure you can connect as the postgres user\n2.  For each developer\n    a. Use the Postgres createuser tool to create superuser account(s)\n    b. Use the Postgres createdb tool to create databases for those account(s)\n\nHere's the commands I type in the shell\n\n~~~shell\nsudo -u postgres psql\n~~~\n\nWhen in the psql shell you should be able to use the slash commands like\n\n\\\\l\n: list the databases\n\n\\\\dt\n: list the tables in the database\n\n\\\\d TABLE\\_NAME\n: list the schema for TABLE\\_NAME\n\n\\\\q\n: quit the psql shell\n\nAssuming we have a working Postgres I now create superuser accounts for\ndevelopment and databases that match the username.\n\n~~~shell\nsudo -u postgres createuser --interactive $USER\ncreatedb $USER\n~~~\n\nI should now be able to run the psql shell without specifying the\npostgres username.\n\n~~~shell\npsql\n~~~\n",
      "data": {
        "abstract": "A collection of quick notes for setting and Postgres for development.",
        "byline": "R. S. Doiel, 2023-11-17",
        "keywords": [
          "postgres"
        ],
        "title": "Postgres Quick Notes, take two"
      },
      "url": "posts/2023/11/17/PostgreSQL-Quick-Notes.json"
    },
    {
      "content": "\n# RSS and my web experience\n\nby R. S. Doiel, 2023-12-07\n\nI agree with [Dave Winer](http://scripting.com/2023/12/07/140505.html?title=whyWeWantFeedsInBluesky), Blue Sky should support RSS. Most web systems benefit from supporting RSS. RSS is a base level inter-opt for web software like HTML and JSON can be. While I may not be typical I am an example of a web user who experiences much of the web via RSS. I read blog and site content via RSS. I \"follow\" my friends and colleagues via RSS. This is true when they blog or when they post in a Mastodon community.  I track academic repositories content for [ETH Zurich Research](https://www.rc-blog.ethz.ch/en/feed) and [Caltech](https://feeds.library.caltech.edu/recent/combined.html) via RSS feeds. I check the weather via NOAA's [RSS feed](https://www.weather.gov/rss).  News sites often syndicate still via RSS and then Podcasts, if they are actual Podcasts are distributed via RSS.  All this is to say I think RSS is not dead. It remains easy to render can can be easy to consume.  If a website doesn't provide it it is possible to generate it yourself[1] or find a service to use that does[2]. RSS remains key to how I experience and use the web in 2023.\n\n[1]: Go libraries like [Colly](https://go-colly.org/) and [Gofeeds](https://github.com/mmcdole/gofeed) make it possible to roll your own like the one in skimmer\n\n[2]: https://firesky.tv/ is an example of a service that provides RSS for Bluesky via its raw API, [html2rss](https://html2rss.github.io/) is service that producing RSS feeds for popular sites that don't include them\n\nMy personal approach to feeds is very much tailored to me. It's probably overkill for most people but it works with my vision and cognitive limitations. He's the steps I take in feed reading. They essentially decompose a traditional feed reader and allow for more flexibility for my reading pleasure.\n\n1. Maintain a list of feeds in a simple text file\n2. Harvest those feeds with [skimmer](https://rsdoiel.github.io/skimmer), Skimmer stores the items in an [SQLite3](https://sqlite.org)\n3. I filter the items using SQL and SQLite3 or via an interactive mode provided by Skimmer\n4. Render saved items to Markdown with [skim2md](https://rsdoiel.github.io/skimmer/skim2md.1.html)\n5. Use [Pandoc](https://pandoc.org) to render the Markdown and view Firefox\n\nThe nice thing about this approach is that I can easily script it with Bash or even a Windows bat. I can easily maintain separate lists and separate databases for personal and work related material.  A bonus is the database items can also serve as a corpus for a personal search engine too. If you want to save maintain a public reading list this setup is ideal too. Of course the list of curated items can be transformed into their own RSS feed as well.\n\n[Skimmer](https://rsdoiel.github.io/skimmer/skimmer.1.html) is a deconstructed feed reader. Does that make it post modern feed reader?  Skimmer processes a list of feeds I follow and saves the results in an SQLite 3 database. That database can be used to filter the feeds and flag items as \"saved\". Typically I filter by timestamps. Saved items can be processed with `skim2md` to render a markdown document. `skim2md` has an option to include a \"save to pocket\" button for each item in the output. I use Pandoc to render the page then view that result in Firefox. At my leisure I read the web page and press the \"Save to pocket\" button any item I want to read later. It's a very comfortable experience.\n\nSkimmer lead me to think about a personal news page for myself and family. Skimmer lets me curate separate lists organized around themes. These can then be rendered to individual pages like pages of a newspaper. This has been captured in an experimental project I call [Antenna](https://rsdoiel.github.io/antenna). It even includes a feed search feature thanks to [PageFind](https://pagefind.app)\n",
      "data": {
        "abstract": "RSS is alive and kicking and Bluesky should support it too. Explore my recipe for reading web news.",
        "byline": "R. S. Doiel, 2023-12-07",
        "created": "2023-12-07",
        "keywords": [
          "RSS",
          "Feeds",
          "Social Media",
          "news"
        ],
        "numnber": 1,
        "series": "Simplification and the Web",
        "title": "RSS and my web experience"
      },
      "url": "posts/2023/12/07/rss-and-my-web-experience.json"
    },
    {
      "content": "\n# Find Bluesky RSS Feeds\n\nWith the update to [1.60](https://bsky.app/profile/bsky.app/post/3kh5rjl6bgu2i) of Bluesky we can now follow people on Bluesky via RSS feeds. This makes things much more convienient for me. \nThe RSS feed is visible via the HTML markup on a person's profile page (which are now public). E.g. My Bluesky profile page is\nat <https://bsky.app/profile/rsdoiel.bsky.social> and if you look at that pages HTML markup you'll see a link element in the head\n\n```html\n <link rel=\"alternate\" type=\"application/rss+xml\" href=\"/profile/did:plc:nbdlhw2imk2m2yqhwxb5ycgy/rss\">\n```\n\nThat's the RSS feed. So now if you want to follow you can expand the URL to \n\n```\nhttps://bsky.app/profile/did:plc:nbdlhw2imk2m2yqhwxb5ycgy/rss\n```\n\nAnd use if via your feed reader. This is a sweat feature. It allows me to move my reading from visiting the website\nto getting updates via my feed reader.\n\n\n",
      "data": {
        "byline": "R. S. Doiel, 2023-12-23",
        "keywords": [
          "bluesky",
          "rss"
        ],
        "title": "Finding Bluesky RSS feeds"
      },
      "url": "posts/2023/12/23/finding-blue-sky-rss-feeds.json"
    },
    {
      "content": "\n\nFreeDOS to Oberon System 3\n==========================\n\nBy R. S. Doiel, 2019-07-28\n\n>    UPDATE: (2021-02-26, RSD) Under VirtualBox 6.1 these\n>    instructions still fail. My hope is to revise these \n>    instructions when I get it all sorted out.\n>\n>    Many links such as the ftp site at ETH Oberon are \n>    no more. I've updated this page to point at Wayback machine\n>    or included content in here where I cannot find it else where.\n>\n>    UPDATE: (2021-02-19, RSD) Under VirtualBox 6.1 these instructions \n>    fail. For VirtualBox I’ve used FreeDOS 1.3rc3 Live CD installing \n>    the “Plain DOS” without problems.\n>\n>    UPDATE: (2021-03-16, RSD) After reviewing my post, correcting\n>    some mistakes I finally was able to get FreeDOS up and running\n>    on VirtualBox 6.1. This allows NativeOberon 2.3.6 to be brought\n>    up by booting the \"oberon0.dsk\" virtual floppy and following\n>    the instructions included. You need to know how to use\n>    the Oberon mouse and the way commands work in Oberon.\n\nWhat follows are notes on getting a FreeDOS 1.2[^1] and \nthen Native Oberon[^2] running under VirtualBox 6.0. You might \nwonder why these two are together. While it was\neasy to run the Native Oberon installation process that process\nassumes you have a properly partitioned hard disk and VirtualBox\nseems to skip that process. I found taking advantage of FreeDOS\nsimplified things for me.\n\nMy goal was running Oberon System 3, but setting up a Virtual Box\nwith FreeDOS 1.2 gave me a virtual machine that functions like a \n1999 era PC. From there all the steps in the Oberon instructions\njust worked.\n\n## Creating FreeDOS 1.2 Virtual Box\n\nI've been doing a bit if computer history reading and decided to\nbring up some older systems as a means to understand where\nthings were.  The first computers I had access to were 8080, 8086\nmachines running MS DOS based. My first computer programming language\nwas Turbo Pascal. Feeling a bit nostalgic I thought it would be\ninteresting to use it again and see what I remembered from the days\nof old. While PC and MS DOS no longer exist as commercial productions\nan wonderful group of Open Source hackers have brought new life into\nDOS with FreeDOS 1.2[^3]. You'll find many of your old familiar commands\nbut also some nice improvements. You can even run it under VirtualBox\nwhich is what I proceeded to do.\n\n### VirtualBox 6.0 setup\n\nThe [FreeDOS](https://freedos.org) website includes a CD ROM image\nthat you can use to install it. There are couple small hitches though\nto get it working under VirtualBox. First go to the [download](https://freedos.org/download) page and download the [CDROM \"standard\" installer\"](http://www.freedos.org/download/download/FD12CD.iso).\n\nWhile that is downloading you can setup your VirtualBox machine.\nFirst to remember is DOS compared to today's operating systems is\nfrugal in its hardware requirements. As a result I picked very modest\nsettings for my virtual machine. \n\n1. Launch VirtualBox\n2. From the menu, pick Machine then pick new\n3. Name your machine (e.g. \"FreeDOS 1.2\"), select the type: \"Other\" and Operating system of \"DOS\"\n4. Set memory size as you like, I just accepted the default 32MB\n5. Hard disk, pick \"Create a virtual hard disc now\"\n6. Hard disk file type, pick \"VHD (Virtual Hard Disk)\"\n7. Storage on physical hard disk, I picked Dynamically allocated both either is fine\n8. File location and size, I accepted the default location and size\n9. Before starting my FreeDOS box I made a couple of changes using \"settings\" menu icon\n    a. Display, I picked bumped memory up to 128M and picked VBoxSVGA with 33D acceleration (for games)\n    b. Storage, I added a second floppy drive (empty)\n    c. Network, I picked attached to NAT\n10. When looking at my virtual machine's detail page I clicked on the Optical drive (empty), click \"choose disc image\" and pointed at the downloaded installed CD\n11. Click Start.\n12. At \"Welcome to FreeDOS 1.2\" blue screen, hit TAB key\n13. You will see a line that begins with a boot instruction. Add a space than add the word \"raw\" (without quotes) press enter\n14. Follow the install instructions, when you get to \"Drive C: does not appear to be partitioned\" dialog, pick \"Yes - Partition drive C:\"\n15. On the next screen pick \"Yes - Please reboot now\"\n16. When at the \"Welcome to FreeDOS 1.2\" screen hit TAB again\n17. Once again add a space and type \"raw\" to the command then press enter\n18. Pick \"Yes - continue with the installation\"\n19. Pick \"Yes - Please erase and format drive C:\"\n20. At this point its a normal FreeDOS install\n21. When the install is done and reboots \"eject\" the virtual CD form the \"Optical Drive\" in the VirtualBox panel, then choose \"boot from system disk\",you now should have a working FreeDOS on VirtualBox\n\n## Native Oberon System 3 on Virtual Box\n\nNative Oberon can be found at http://www.ethoberon.ethz.ch/native/.\nThere is a related ftp site[^4] where you can download the necessary\nfiles for the stand alone version. \n\nHere's the steps I used in my Mac to download Native Oberon and\ninto a file on my desktop called \"NativeOberon-Standalone\". Open\nthe macOS Terminal application. I assume you've got a Unix\ncommand called [wget](https://en.wikipedia.org/wiki/Wget)\nalready installed[^5].\n\n> NOTE: The ETH ftp server is no more. I've included Web Archive\n> links and links to my own copies of the files needed to\n> install Native Oberon 2.3.6 in the paragraphs that follow.\n> RSD, 2021-03-16\n\n```bash\n\n    cd\n    mkdir -p Desktop/NativeOberon-Standalone\n    cd Desktop/NativeOberon-Standalone\n    wget ftp://ftp.ethoberon.ethz.ch/ETHOberon/Native/StdAlone/\n\n```\n\nClone your FreeDOS Box first. You'll want to do a \"Full Clone\". You'll\nalso want to \"remove\" any optical disks or floppies. You do that from\nthe virtual boxes' detail page and clicking on the drive and picking the\n\"Remove disk from virtual drive\" in the popup menu.\n\nAt this point we have a a virtual machine that is very similar to an \n1999 era PC installed with MS DOS.  [Native Oberon](http://web.archive.org/web/20190929033749/http://www.ethoberon.ethz.ch/native/) Normally you'd\ninstall [Native Oberon via 1.44MB floppy disks](/blog/2019/07/28/NativeOberon-StnAlone-2.3.6.zip \"Zip file of individual floppies\"). \nWe can simulate that with our Virtual machine.\nIn the folder of you downloaded there is disc called \"oberon0.dsk\". That\ncan go in our first floppy drive. But how to we get the rest of the \nfiles onto a virtual floppies? This wasn't obvious to me at first.\n\nThe Oberon install disks were organized as follows\n\n| PACKAGE    | FILENAME     | SIZE  | DSK   |\n| ---------- | ------------ | ----- | ----- |\n| Oberon-0      | [oberon0.dsk](oberon0.dsk \"boot disk\")  |          | 0 | \n| Gadgets       | [gadgets.arc](gadgets1.arc \"a modified gadgets.arc to fit 1.4 floppy\")  | 1.4  2.9 | 1 | \n| Documentation | [docu.arc](docu.arc \"documentation\")     | 1.3  2.5 | 2 | \n| Applications  | [apps.arc](apps.arc \"applications\")     | 1.3  2.8 | 3 | \n| Tutorials     | [tutorial.arc](tutorial.arc \"tutorial\") | 0.3  0.8 | 4 | \n| Pr3Fonts      | [pr3fonts.arc](pr3fonts.arc \"fonts\") | 0.3  0.6 | 4 | \n| Pr6Fonts      | [pr6fonts.arc](pr6fonts.arc \"fonts\") | 0.5  1.8 | 4 | \n| Source1       | [source1.arc](source1.arc \"Source Code\")  | 0.9  2.5 | 5 | \n| Source2       | [source2.arc](source2.arc \"Source Code\")  | 1.2  3.5 | 6 | \n| Source3       | [source3.arc](source3.arc \"Source Code\")  | 0.6  1.7 | 7 | \n\n\nIt turns out you can create 1.44MB Fat16 disc images from the\nVirtual Box 6.0 floppy drive link.  When you click on the floppy\ndrive in the details page you have a choice that includes \"create a new floppy disc\". Select this, find the disc a filename like \"disk1\". Click\non the virtual floppy disk in the Virtual Box and \"remove\"\nthe disc then create disk2, disk3, etc. In each the empty disc image\nfiles places the files from the table above. These image files can then\nbe opened on your host operating system and files copied to them. \nIt's a tedious process but this gives you something the Oberon System \ncan read and install from. Originally I just put all the files into an \nISO CD ROM image but I could not figure out how to mount that from this\nversion of Oberon. Now when you start up your Oberon V3 virtual machine\nyou can install the rest of the software like Gadgets.\n\n\n[^1]: FreeDOS is an Open Source implementation of PC/MS DOC\n\n[^2]: Native Oberon is a 1990's version of Oberon System running on i386\n\n[^3]: Download FreeDOS from http://freedos.org/download\n\n[^4]: Download Native Oberon Stand Alone from [ftp://ftp.ethoberon.ethz.ch/ETHOberon/Native/StdAlone](NativeOberon-StdAlone-2.3.6.zip \"Zip of what used to be available in that directory at ftp.ethoberon.ethz.ch\")\n\n[^5]: wget is easily installed with [HomeBrew](https://brew.sh/) or [Mac Ports](https://www.macports.org/)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2018, R. S. Doiel",
        "date": "2019-07-28",
        "keywords": [
          "FreeDOS",
          "Oberon System"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "FreeDOS 1.2 to Oberon System 3",
        "updated": "2021-03-16"
      },
      "url": "posts/2019/07/28/freedos-to-oberon-system-3.json"
    },
    {
      "content": "\nBeyond Oakwood, Modules and Aliases\n===================================\n\nBy R. S. Doiel, 2021-05-16\n\nOakwood is the name used to refer to an early Oberon language\nstandardization effort in the late 20th century.  It's the name\nof a hotel where compiler developers and the creators of Oberon\nand the Oberon System met to discuss compatibility. The lasting\ninfluence on the 21st century Oberon-07 language can be seen\nin the standard set of modules shipped with POSIX based Oberon-07\ncompilers like\n[OBNC](https://miasap.se/obnc/), [Vishap Oberon Compiler](https://github.com/vishaps/voc) and the \n[Oxford Oberon Compiler](http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler).\n\nThe Oakwood guidelines described a minimum expectation for\na standard set of modules to be shipped with compilers.\nThe modules themselves are minimalist in implementation.\nMinimalism can assist in easing the learning curve\nand encouraging a deeper understanding of how things work.\n\nThe Oberon-07 language is smaller than the original Oberon language\nand the many dialects that followed.  I think of Oberon-07 as the\ndistillation of all previous innovation.  It embodies the\nspirit of \"Simple but not simpler than necessary\". Minimalism is\na fit description of the adaptions of the Oakwood modules for \nOberon-07 in the POSIX environment.\n\n\nWhen simple is too simple\n-------------------------\n\nSometimes I want more than the minimalist module.  A good example\nis standard [Strings](https://miasap.se/obnc/obncdoc/basic/Strings.def.html)\nmodule.  Thankfully you can augment the standard modules with your own.\nIf you are creative you can even create a drop in replacement.\nThis is what I wound up doing with my \"Chars\" module.\n\nIn the spirit of \"Simple but no simpler\" I originally kept Chars \nvery minimal. I only implemented what I missed most from Strings.\nI got down to a handful of functions for testing characters,\ntesting prefixes and suffixes as well as trim procedures. It was\nall I included in `Chars` was until recently.\n\nOver the last couple of weeks I have been reviewing my own Oberon-07\ncode in my personal projects.  I came to understand that\nin my quest for minimalism I had fallen for \"too simple\".\nThis was evidenced by two observations.  Everywhere I had used\nthe `Strings` module I also included `Chars`. It was boiler plate.\nThe IMPORT sequence was invariably a form of --\n\n~~~\n    IMPORT Strings, Chars, ....\n~~~\n\nOn top of that I found it distracting to see `Chars.*` and `Strings.*`\ncomingled and operating on the same data. If felt sub optimal. It\nfelt baroque. That got me thinking.\n\n> What if Chars included the functionality of Strings?\n\nI see two advantages to merging Chars and Strings. First I\nonly need to include one module instead of two. The second\nis my code becomes more readable. I think that is because\nexpanding Strings to include new procedures and constants allows\nfor both the familiar and for evolution. The problem is renaming\n`Chars.Mod` to `Strings.Mod` implies I'm supplying the standard\n`Strings` module. Fortunately Oberon provides a mechanism for\nsolving this problem. The solution Oberon provides is to allow\nmodule names to be aliased.  Look at my new import statement.\n\n~~~\n    IMPORT Strings := Chars, ...\n~~~\n\nIt is still minimal but at the same time shows `Chars` is going\nto be referenced as `Strings`. By implication `Chars` provides\nthe functionality `Strings` but is not the same as `Strings`.\nMy code reads nicely.  I don't loose the provenance of what\nis being referred to by `Strings` because it is clearly \nprovided in the IMPORT statement.\n\nIn my new [implementation](Chars.Mod) I support all the standard\nprocedures you'd find in an Oakwood compliant `Strings`.  I've\nincluded additional additional constants and functional procedures\nlike `StartsWith()` and `EndsWith()` and a complement of trim\nprocedures like `TrimLeft()`, `TrimRight()`, `Trim()`.\n`TrimPrefix()`, and `TrimSuffix()`.\n\nHere's how `Chars` definition stacks up as rendered by the\nobncdoc tool.\n\n```\n(* Chars.Mod - A module for working with CHAR and \n   ARRAY OF CHAR data types.\n\nCopyright (C) 2020, 2021 R. S. Doiel <rsdoiel@gmail.com>\nThis Source Code Form is subject to the terms of the\nMozilla PublicLicense, v. 2.0. If a copy of the MPL was\nnot distributed with thisfile, You can obtain one at\nhttp://mozilla.org/MPL/2.0/. *)\nDEFINITION Chars;\n\n(*\nChars.Mod provides a modern set of procedures for working\nwith CHAR and ARRAY OF CHAR. It is a drop in replacement\nfor the Oakwood definition \nStrings module.\n\nExample:\n\n    IMPORT Strings := Chars;\n\nYou now have a Strings compatible Chars module plus all the Chars\nextra accessible through the module alias of Strings. *)\n\nCONST\n  (* MAXSTR is exported so we can use a common\n     max string size easily *)\n  MAXSTR = 1024;\n  (* Character constants *)\n  EOT = 0X;\n  TAB = 9X;\n  LF  = 10X;\n  FF  = 11X;\n  CR  = 13X;\n  SPACE = \" \";\n  DASH  = \"-\";\n  LODASH = \"_\";\n  CARET = \"^\";\n  TILDE = \"~\";\n  QUOTE = 34X;\n\n  (* Constants commonly used characters to quote things.  *)\n  QUOT   = 34X;\n  AMP    = \"&\";\n  APOS   = \"'\";\n  LPAR   = \")\";\n  RPAR   = \"(\";\n  AST    = \"*\";\n  LT     = \"<\";\n  EQUALS = \"=\";\n  GT     = \">\";\n  LBRACK = \"[\";\n  RBRACK = \"]\";\n  LBRACE = \"}\";\n  RBRACE = \"{\";\n\nVAR\n  (* common cutsets, ideally these would be constants *)\n  spaces : ARRAY 6 OF CHAR;\n  punctuation : ARRAY 33 OF CHAR;\n\n(* InRange -- given a character to check and an inclusive range of\n    characters in the ASCII character set. Compare the ordinal values\n    for inclusively. Return TRUE if in range FALSE otherwise. *)\nPROCEDURE InRange(c, lower, upper : CHAR) : BOOLEAN;\n\n(* InCharList checks if character c is in list of chars *)\nPROCEDURE InCharList(c : CHAR; list : ARRAY OF CHAR) : BOOLEAN;\n\n(* IsUpper return true if the character is an upper case letter *)\nPROCEDURE IsUpper(c : CHAR) : BOOLEAN;\n\n(* IsLower return true if the character is a lower case letter *)\nPROCEDURE IsLower(c : CHAR) : BOOLEAN;\n\n(* IsDigit return true if the character in the range of \"0\" to \"9\" *)\nPROCEDURE IsDigit(c : CHAR) : BOOLEAN;\n\n(* IsAlpha return true is character is either upper or lower case letter *)\nPROCEDURE IsAlpha(c : CHAR) : BOOLEAN;\n\n(* IsAlphaNum return true is IsAlpha or IsDigit *)\nPROCEDURE IsAlphaNum (c : CHAR) : BOOLEAN;\n\n(* IsSpace returns TRUE if the char is a space, tab, carriage return or line feed *)\nPROCEDURE IsSpace(c : CHAR) : BOOLEAN;\n\n(* IsPunctuation returns TRUE if the char is a non-alpha non-numeral *)\nPROCEDURE IsPunctuation(c : CHAR) : BOOLEAN;\n\n(* Length returns the length of an ARRAY OF CHAR from zero to first\n    0X encountered. [Oakwood compatible] *)\nPROCEDURE Length(source : ARRAY OF CHAR) : INTEGER;\n\n(* Insert inserts a source ARRAY OF CHAR into a destination \n    ARRAY OF CHAR maintaining a trailing 0X and truncating if\n    necessary [Oakwood compatible] *)\nPROCEDURE Insert(source : ARRAY OF CHAR; pos : INTEGER; VAR dest : ARRAY OF CHAR);\n\n(* AppendChar - this copies the char and appends it to\n    the destination. Returns FALSE if append fails. *)\nPROCEDURE AppendChar(c : CHAR; VAR dest : ARRAY OF CHAR) : BOOLEAN;\n\n(* Append - copy the contents of source ARRAY OF CHAR to end of\n    dest ARRAY OF CHAR. [Oakwood complatible] *)\nPROCEDURE Append(source : ARRAY OF CHAR; VAR dest : ARRAY OF CHAR);\n\n(* Delete removes n number of characters starting at pos in an\n    ARRAY OF CHAR. [Oakwood complatible] *)\nPROCEDURE Delete(VAR source : ARRAY OF CHAR; pos, n : INTEGER);\n\n(* Replace replaces the characters starting at pos with the\n    source ARRAY OF CHAR overwriting the characters in dest\n    ARRAY OF CHAR. Replace will enforce a terminating 0X as\n    needed. [Oakwood compatible] *)\nPROCEDURE Replace(source : ARRAY OF CHAR; pos : INTEGER; VAR dest : ARRAY OF CHAR);\n\n(* Extract copies out a substring from an ARRAY OF CHAR into a dest\n    ARRAY OF CHAR starting at pos and for n characters\n    [Oakwood compatible] *)\nPROCEDURE Extract(source : ARRAY OF CHAR; pos, n : INTEGER; VAR dest : ARRAY OF CHAR);\n\n(* Pos returns the position of the first occurrence of a pattern\n    ARRAY OF CHAR starting at pos in a source ARRAY OF CHAR. If\n    pattern is not found then it returns -1 *)\nPROCEDURE Pos(pattern, source : ARRAY OF CHAR; pos : INTEGER) : INTEGER;\n\n(* Cap replaces each lower case letter within source by an uppercase one *)\nPROCEDURE Cap(VAR source : ARRAY OF CHAR);\n\n(* Equal - compares two ARRAY OF CHAR and returns TRUE\n    if the characters match up to the end of string,\n    FALSE otherwise. *)\nPROCEDURE Equal(a : ARRAY OF CHAR; b : ARRAY OF CHAR) : BOOLEAN;\n\n(* StartsWith - check to see of a prefix starts an ARRAY OF CHAR *)\nPROCEDURE StartsWith(prefix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR) : BOOLEAN;\n\n(* EndsWith - check to see of a prefix starts an ARRAY OF CHAR *)\nPROCEDURE EndsWith(suffix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR) : BOOLEAN;\n\n(* Clear - resets all cells of an ARRAY OF CHAR to 0X *)\nPROCEDURE Clear(VAR a : ARRAY OF CHAR);\n\n(* Shift returns the first character of an ARRAY OF CHAR and shifts the\n    remaining elements left appending an extra 0X if necessary *)\nPROCEDURE Shift(VAR source : ARRAY OF CHAR) : CHAR;\n\n(* Pop returns the last non-OX element of an ARRAY OF CHAR replacing\n    it with an OX *)\nPROCEDURE Pop(VAR source : ARRAY OF CHAR) : CHAR;\n\n(* TrimLeft - remove the leading characters in cutset\n    from an ARRAY OF CHAR *)\nPROCEDURE TrimLeft(cutset : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimRight - remove tailing characters in cutset from\n    an ARRAY OF CHAR *)\nPROCEDURE TrimRight(cutset : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* Trim - remove leading and trailing characters in cutset\n    from an ARRAY OF CHAR *)\nPROCEDURE Trim(cutset : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimLeftSpace - remove leading spaces from an ARRAY OF CHAR *)\nPROCEDURE TrimLeftSpace(VAR source : ARRAY OF CHAR);\n\n(* TrimRightSpace - remove the trailing spaces from an ARRAY OF CHAR *)\nPROCEDURE TrimRightSpace(VAR source : ARRAY OF CHAR);\n\n(* TrimSpace - remove leading and trailing space CHARS from an \n    ARRAY OF CHAR *)\nPROCEDURE TrimSpace(VAR source : ARRAY OF CHAR);\n\n(* TrimPrefix - remove a prefix ARRAY OF CHAR from a target \n    ARRAY OF CHAR *)\nPROCEDURE TrimPrefix(prefix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimSuffix - remove a suffix ARRAY OF CHAR from a target\n    ARRAY OF CHAR *)\nPROCEDURE TrimSuffix(suffix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimString - remove cutString from beginning and end of ARRAY OF CHAR *)\nPROCEDURE TrimString(cutString : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\nEND Chars.\n```\n\nMy new `Chars` module has proven to be both more readable\nand more focused in my projects. I get all the functionality\nof `Strings` and the additional functionality I need in my own\nprojects. This improved the focus in my other modules and I think\nmaintained the spirit of \"Simple but not simpler\".\n\n+ [Chars.Mod](Chars.Mod)\n\nUPDATE: The current version of my `Chars` module can be found in \nmy [Artemis](https://github.com/rsdoiel/Artemis) repository. The\nrepository includes additional code and modules suitable to working\nwith Oberon-07 in a POSIX envinronment.\n\n### Next, Previous\n\n+ Next [Combining Oberon-07 with C using Obc-3](/blog/2021/06/14/Combining-Oberon-07-with-C-using-Obc-3.html)\n+ Prev [Dates & Clocks](/blog/2020/11/27/Dates-and-Clock.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-05-16",
        "keywords": [
          "Oberon",
          "Modules",
          "Oakwood",
          "Strings",
          "Chars"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 18,
        "title": "Beyond Oakwood, Modules and Aliases"
      },
      "url": "posts/2021/05/16/Beyond-Oakwood-Modules-and-Aliases.json"
    },
    {
      "content": "\nRevisiting Files\n================\n\nBy R. S. Doiel, 2021-11-22\n\nIn October I had an Email exchange with Algojack regarding a buggy example in [Oberon-07 and the file system](../../../2020/05/09/Oberon-07-and-the-filesystem.html). The serious bug was extraneous non-printable characters appearing a plain text file containing the string \"Hello World\". The trouble with the example was a result of my misreading the Oakwood guidelines and how **Files.WriteString()** is required to work. The **Files.WriteString()** procedure is supposed to write every element of a string to a file. This __includes the trailing Null character__. The problem for me is **Files.WriteString()** litters plain text files with tailing nulls. What I should have done was write my own **WriteString()** and **WriteLn()**. The program [HelloworldFile](./HelloworldFile.Mod) below is a more appropriate solution to writing strings and line endings than relying directly on **Files**. In a future post I will explorer making this more generalized in a revised \"Fmt\" module.\n\n~~~\nMODULE HelloworldFile;\n\nIMPORT Files, Strings;\n\nCONST OberonEOL = 1; UnixEOL = 2; WindowsEOL = 3;\n\nVAR\n  (* holds the eol marker type to use in WriteLn() *)\n  eolType : INTEGER;\n  (* Define a file handle *)\n    f : Files.File;\n  (* Define a file rider *)\n    r : Files.Rider;\n\nPROCEDURE WriteLn(VAR r : Files.Rider);\nBEGIN\n  IF eolType = WindowsEOL THEN\n    (* A DOS/Windows style line ending, LFCR *)\n    Files.Write(r, 13);\n    Files.Write(r, 10);\n  ELSIF eolType = UnixEOL THEN\n     (* Linux/macOS style line ending, LF *)\n     Files.Write(r, 10);\n  ELSE\n    (* Oberon, RISC OS style line ending, CR *)\n    Files.Write(r, 13);\n  END;\nEND WriteLn;\n\nPROCEDURE WriteString(VAR r : Files.Rider; s : ARRAY OF CHAR);\n  VAR i : INTEGER;\nBEGIN\n  i := 0;\n  WHILE i < Strings.Length(s) DO\n    Files.Write(r, ORD(s[i]));\n    INC(i);\n  END;\nEND WriteString;\n\nBEGIN\n  (* Set the desired eol type to use *)\n  eolType := UnixEOL;\n  (* Create our file, New returns a file handle *)\n  f := Files.New(\"helloworld.txt\"); ASSERT(f # NIL);\n  (* Register our file with the file system *)\n  Files.Register(f);\n  (* Set the position of the rider to the beginning *)\n  Files.Set(r, f, 0);\n  (* Use the rider to write out \"Hello World!\" followed by a end of line *)\n  WriteString(r, \"Hello World!\");\n  WriteLn(r);\n  (* Close our modified file *)\n  Files.Close(f);\nEND HelloworldFile.\n~~~\n\nI have two new procedures \"WriteString\" and \"WriteLn\". These mimic the parameters found in the Files module. The module body is a bit longer.\n\nCompare this to a simple example of \"Hello World\" using the **Out** module.\n\n~~~\nMODULE HelloWorld;\n\nIMPORT Out;\n\nBEGIN\n  Out.String(\"Hello World\");\n  Out.Ln;\nEND HelloWorld.\n~~~\n\nLook at the difference is in the module body. I need to setup our file and rider as well as pick the type of line ending to use in \"WriteLn\". The procedures doing the actual work look very similar, \"String\" versus \"WriteString\" and \"Ln\" versus \"WriteLn\".  \n\n\nLine ends vary between operating systems. Unix-like systems usually use a line feed. DOS/Windows systems use a carriage return and line feed. Oberon Systems use only a carriage return. If we're going to the trouble of re-creating our \"WriteString\" and \"WriteLn\" procedures it also makes sense to handle the different line ending options.  In this case I've chosen to use an INTEGER variable global to the module called \"eolType\". I have a small set of constants to indicate which line ending is needed. In \"WriteLn\" I use that value as a guide to which line ending to use with the rider writing to the file.\n\nThe reason I chose this approach is because I want my writing procedures to use the same procedure signatures as the \"Files\" module. In a future post I will explore type conversion and a revised implementation of my \"Fmt\" module focusing on working with plain text files.\n\nAside from our file setup and picking an appropriate end of line marker the shape of the two programs look very similar.\n\nReferences and resources\n------------------------\n\nYou can see a definition of the [Files](https://miasap.se/obnc/obncdoc/basic/Files.def.html \"My example module definition is based on the on Karl created in OBNC\") at Karl Landström's documentation for his compiler along with the definitions for [In](https://miasap.se/obnc/obncdoc/basic/In.def.html) and [Out](https://miasap.se/obnc/obncdoc/basic/Out.def.html).\n\n\nNext & Previous\n---------------\n\n- Next [Portable Conversions (Integers)](../../11/26/Portable-Conversions-Integers.html)\n- Prev [Combining Oberon-07 with C using Obc-3](../../06/14/Combining-Oberon-07-with-C-using-Obc-3.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-11-12",
        "keywords": [
          "Oberon",
          "Files",
          "plain text"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 20,
        "title": "Revisiting Files"
      },
      "url": "posts/2021/11/22/Revisiting-Files.json"
    },
    {
      "content": "\nSetting up FreeDOS 1.3rc4 with Qemu\n-----------------------------------\n\nBy R. S. Doiel, 2021-11-27\n\nIn this article I'm going explore setting up FreeDOS with Qemu\non my venerable Dell 4319 running Raspberry Pi Desktop OS (Debian\nGNU/Linux).  First step is to download FreeDOS \"Live CD\" in the\n1.3 RC4 release. See http://freedos.org/download/ for that.\n\nInstalling Qemu\n---------------\n\nI needed to install Qemu in my laptop. It runs the Raspberry Pi\nDesktop OS (i.e. Debian with Raspberry Pi UI). I choose to install\nthe \"qemu-system\" package since I will likely use qemu for other\nthings besides FreeDOS. The qemu-system package contains all the\nvarious systems I might want to emulate in other projects as well\nas several qemu utilities that are handy.  Here's the full sequence\nof `apt` commands I ran (NOTE: these included making sure my laptop\nwas up to date before I installed qemu-system).\n\n~~~\nsudo apt update\nsudo apt upgrade\nsudo apt install qemu-system\n~~~\n\nNow that I had the software available it was time to figure out\nhow to actually knit things together and run FreeDOS.\n\n\nObtaining FreeDOS 1.3rc4\n------------------------\n\nBefore I get started I create a folder in my home directory\nfor running everything. You can name it what you want\nbut I called mine `FreeDOS_13` and changed into that folder\nfor the work in this article.\n\n~~~\nmkdir FreeDOS_13\ncd FreeDOS_13\n~~~\n\nI initially tried the CD images but ran into odd problems with\nqemu (possibly due to my lack of experience with qemu).\nAfter looking at that various options the USB Full release\nseemed like a good choice. It comes both as an image you can\n\"burn\" to your USB drive both also as a \"vmdk\" file used with\nemulators.\n\n~~~\ncurl -L -O https://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/distributions/1.3/previews/1.3-rc4/FD13-FullUSB.zip\nunzip FD13-FullUSB.zip\n~~~\n\nAt this point you should see the FreeDOS \"vmdk\" file, and \"img\" file and readme files if you list the directory out. I'm going to use the \"vmdk\" file to install FreeDOS on my virtual harddrive freedos.img.\n\n~~~\nls -l \n~~~\n\nPrepping my virtual machine\n---------------------------\n\nA virtual machine is not just a CPU and some random\naccess memory. A machine can include storage devices. For\nthe retro \"DOS\" experience you might looking virtual devices\nfor a \"harddrive\", \"floppy drive\" and \"CD-ROM drive\". \nQemu provides a tool called `qemu-img` for creating \nthese types of virtual devices.\n\nThe basic command is `qemu-img` using the \"create\" option with\nsome parameters.  The parameter are filename and size (see\n`man qemu-img` for gory details). I am calling my virtual\nharddrive \"freedos.img\".  With `qemu-img` the size can be\nspecified with a suffix like \"K\" for kilobytes,  \"M\" for\nmegabytes and \"G\" for gigabytes. DOS is a minimal requirements\na small (by today's standards) 750 megabyte harddrive seems\nappropriate.\n\n~~~\nqemu-img create freedos.img 750M\n~~~\n\nFor my purposes I need a harddrive so I stopped there. You\ncan always create other drives and then restart your virtual\nmachine with the appropriate options.\n\nBring up my FreeDOS box\n-----------------------\n\nNow I was ready to boot from installation media and install\nFreeDOS 1.3rc4 on my virtual harddrive.  For that I\nuse a \"qemu\" command for the system I want to emulate.\nI picked `qemu-system-i386` (see can see\nthe gory details of that command using `man qemu-system-i386`).\nTo install FreeDOS I'm going to boot from the vmdk file \nprovided for the purpose of installation. I then use the FreeDOS\ninstaller to make my freedos.img file bootable with all the\nDOS software I want to play with.\n\n~~~\nqemu-system-i386 \\\n   -m 8 \\\n   -boot menu=on,strict=on \\\n   -hda freedos.img \\\n   -hdb FD13FULL.vmdk\n~~~\n\nAt this point you should see the machine start to boot, press Esc\nwhen prompted and select the second hard drive to boot from (that's\nour vmdk drive).  The drive is then treated like the CD-ROM, follow\nthe programs instructions for installation. You will need to reboot\nseveral times during the process. Until your full installation is\ncomplete you'll need to select the second harddrive as the boot drive\nand continue the installation.\n\nThe first time I successfully installed FreeDOS 1.3rc4 I just installed\nthe plain dos. When I re-did the process I install everything. It\nfills up my 750M virtual harddrive but rc4 includes development tools\nlike a C compiler.  That I think made it worth it.\n\nHere's a Bash script you can use to build your FreeDOS machine.\n\n~~~\n#!/bin/bash\n\nif [ ! -f freedos.img ]; then\n  echo \"Creating fresh Harddisk as drive C:\"\n  qemu-img create freedos.img 750M\nfi\necho \"Booting machine using FD13FULL.vmdk for installation\"\nqemu-system-i386 \\\n    -m 8 \\\n    -boot menu=on,strict=on \\\n    -hda freedos.img \\\n    -hdb FD13FULL.vmdk\n~~~\n\nAnd here is one for running it.\n\n~~~\n#!/bin/bash\n\necho \"Booting machine using freedos.img as drive C:\"\nqemu-system-i386 \\\n    -m 8 \\\n    -boot menu=on,strict=on \\\n    -hda freedos.img\n~~~\n\nNext step, explore FreeDOS and see what I can build.\n\nPutting everything together\n---------------------------\n\nBelow is a [script](run-freedos-1.3rc4.bash) I developed automating either building or running your FreeDOS setup.\n\n~~~\n#!/bin/bash\n\nif [ ! -f FD13FULL.vmdk ]; then\n    if [ ! -f FD13-FullUSB.zip ]; then\n      echo \"Missing FD13FULL.vmdk, downloading FD13-FullUSB.zip\"\n      curl -L -O https://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/distributions/1.3/previews/1.3-rc4/FD13-FullUSB.zip\n    fi\n    echo \"Unzipping FD13-FullUSB.zip\"\n    unzip FD13-FullUSB.zip\nfi\n\nif [ ! -f freedos.img ]; then\n  echo \"Creating fresh Harddisk as drive C:\"\n  qemu-img create freedos.img 750M\n  echo \"Booting machine using FD13FULL.vmdk as drive C:\"\n  echo \"Installing FreeDOS on drive D:\"\n  qemu-system-i386 \\\n      -name FreeDOS \\\n      -machine pc \\\n      -m 32 \\\n      -boot order=c \\\n      -hda FD13FULL.vmdk \\\n      -hdb freedos.img \\\n      -parallel none \\\n      -vga cirrus \\\n      -display gtk\nelse\n  echo \"Booting machine using freedos.img on drive C:\"\n  qemu-system-i386 \\\n      -name FreeDOS \\\n      -machine pc \\\n      -m 32 \\\n      -boot menu=on,strict=on \\\n      -hda freedos.img \\\n      -parallel none \\\n      -vga cirrus \\\n      -display gtk\nfi\n~~~\n\n\nReference material\n------------------\n\nMy inspiration for this was the description of manual install in\nthe FreeDOS book section of the website, [Manual Install](https://www.freedos.org/books/get-started/june14-manual-install.html).\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-11-27",
        "keywords": [
          "FreeDOS",
          "Qemu"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Setting up FreeDOS 1.3rc4 with Qemu"
      },
      "url": "posts/2021/11/27/FreeDOS-1.3rc4-with-Qemu.json"
    },
    {
      "content": "\nPortable conversions (Integers)\n===============================\n\nBy R. S. Doiel, 2021-11-26\n\nAn area in working with Oberon-07 on a POSIX machine that has proven problematic is type conversion. In particular converting to and from INTEGER or REAL and ASCII.  None of the three compilers I am exploring provide a common way of handling this. I've explored relying on C libraries but that approach has it's own set of problems.  I've become convinced a better approach is a pure Oberon-07 library that handles type conversion with a minimum of assumptions about the implementation details of the Oberon compiler or hardware. I'm calling my conversion module \"Types\". The name is short and descriptive and seems an appropriate name for a module consisting of type conversion tests and transformations.  My initial implementation will focusing on converting integers to and from ASCII.\n\nINTEGER to ASCII and back again\n-------------------------------\n\nI don't want to rely on the representation of the INTEGER value in the compiler or at the machine level. That has lead me to think in terms of an INTEGER as a signed whole number. \n\nThe simplest case of converting to/from ASCII is the digits from zero to nine (inclusive). Going from an INTEGER to an ASCII CHAR is just looking up the offset of the character representing the \"digit\". Like wise going from ASCII CHAR to a INTEGER is a matter of mapping in the reverse direction.  Let's call these procedures `DigitToChar` and  `CharToDigit*`.\n\nSince INTEGER can be larger than zero through nine and CHAR can hold non-digits I'm going to add two additional procedures for validating inputs -- `IsIntDigit` and `IsCharDigit`. Both return TRUE if valid, FALSE if not.\n\nFor numbers larger than one digit I can use decimal right shift to extract the ones column value or a left shift to reverse the process.  Let's called these `IntShiftRight` and `IntShiftLeft`.  For shift right it'd be good to capture the ones column being lost. For shift left it would be good to be able to shift in a desired digit. That way you could shift/unshift to retrieve to extract and put back values.\n\nA draft definition for \"Types\" should look something like this.\n\n~~~\nDEFINITION Types;\n\n(* Check if an integer is a single digit, i.e. from 0 through 9 returns\n   TRUE, otherwise FALSE *)\nPROCEDURE IsIntDigit(x : INTEGER) : BOOLEAN;\n\n(* Check if a CHAR is \"0\" through \"9\" and return TRUE, otherwise FALSE *)\nPROCEDURE IsCharDigit(ch : CHAR) : BOOLEAN;\n\n(* Convert digit 0 through 9 into an ASCII CHAR \"0\" through \"9\",\n   ok is TRUE if conversion successful, FALSE otherwise *)\nPROCEDURE DigitToChar(x : INTEGER; VAR ch : CHAR; VAR ok : BOOLEAN);\n\n(* Convert a CHAR \"0\" through \"9\" into a digit 0 through 9, ok\n   is TRUE is conversion successful, FALSE otherwise *)\nPROCEDURE CharToDigit(ch : CHAR; VAR x : INTEGER; VAR ok : BOOLEAN);\n\n(* Shift an integer to the right (i.e. x * 0.1) set \"r\" to the\n   value shifted out (ones column lost) and return the shifted value.\n   E.g.  x becomes 12, r becomes 3.\n\n       x := IntShiftRight(123, r);\n   \n *)\nPROCEDURE IntShiftRight(x : INTEGER; VAR r : INTEGER) : INTEGER;\n\n(* Shift an integer to the left (i.e. x * 10) adding the value y\n   after the shift.\n\n   E.g. x before 123\n\n       x := IntShiftRight(12, 3);\n\n *)\nPROCEDURE IntShiftLeft(x, y : INTEGER) : INTEGER;\n\n(* INTEGER to ASCII *)\nPROCEDURE Itoa(src : INTEGER; VAR value : ARRAY OF CHAR; VAR ok : BOOLEAN);\n\n(* ASCII to INTEGER *)\nPROCEDURE Atoi(src : ARRAY OF CHAR; VAR value : INTEGER; VAR ok : BOOLEAN);\n\nEND Types.\n~~~\n\n\nNOTE: Oberon-07 provides us the ORD and CHR built as part of the\nlanguage.  These are for working with the encoding and decoding\nvalues as integers. This is not the same thing as the meaning\nof \"0\" versus the value of 0.  Getting to and from the encoding\nto the meaning of the presentation can be done with some simple\narithmetic.\n\nPutting it all together\n-----------------------\n\n~~~\n(* DigitToChar converts an INTEGER less than to a character. E.g.\n   0 should return \"0\", 3 returns \"3\", 0 returns \"9\" *)\nPROCEDURE DigitToChar*(i : INTEGER) : CHAR;\nBEGIN\n  RETURN (CHR(ORD(\"0\") + i))\nEND DigitToChar;\n\n(* CharToDigit converts a single \"Digit\" character to an INTEGER value.\n   E.g. \"0\" returns 0, \"3\" returns 3, \"9\" returns 9. *)\nPROCEDURE CharToDigit(ch : CHAR) : INTEGER;\nBEGIN\n  RETURN (ORD(ch) - ORD(\"0\"))\nEND CharToDigit;\n~~~\n\nThis implementation is naive. It assumes the ranges of the input values\nwas already checked. In practice this is going to encourage bugs.\n\nIn a language like Go or Python you can return multiple values (in\nPython you can return a tuple). In Oberon-07 I could use a\nRECORD type to do that but that feels a little too baroque. Oberon-07\nlike Oberon-2, Oberon, Modula and Pascal does support \"VAR\" parameters. \nWith a slight modification to our procedure signatures I can support\neasy assertions about the conversion. Let's create two functional\nprocedures `IsIntDigit()` and `IsCharDigit()` then update our\n`DigitToChar()` and `CharToDigit()` with an a  \"VAR ok : BOOLEAN\"\nparameter.\n\n~~~\n(* IsIntDigit returns TRUE is the integer value is zero through nine *)\nPROCEDURE IsIntDigit(i : INTEGER) : BOOLEAN;\nBEGIN \n  RETURN ((i >= 0) & (i <= 9))\nEND IsIntDigit;\n\n(* IsCharDigit returns TRUE if character is zero through nine. *)\nPROCEDURE IsCharDigit(ch : CHAR) : BOOLEAN;\nBEGIN\n  RETURN ((ch >= \"0\") & (ch <= \"9\"))\nEND IsCharDigit;\n\n(* DigitToChar converts an INTEGER less than to a character. E.g.\n   0 should return \"0\", 3 returns \"3\", 0 returns \"9\" *)\nPROCEDURE DigitToChar*(i : INTEGER; VAR ok : BOOLEAN) : CHAR;\nBEGIN\n  ok := IsIntDigit(i);\n  RETURN (CHR(ORD(\"0\") + i))\nEND DigitToChar;\n\n(* CharToDigit converts a single \"Digit\" character to an INTEGER value.\n   E.g. \"0\" returns 0, \"3\" returns 3, \"9\" returns 9. *)\nPROCEDURE CharToDigit(ch : CHAR; VAR ok : BOOLEAN) : INTEGER;\nBEGIN\n  ok := IsCharDigit(ch);\n  RETURN (ORD(ch) - ORD(\"0\"))\nEND CharToDigit;\n~~~\n\nWhat about values are greater nine? Here we can take advantage\nof our integer shift procedures.  `IntShiftRight` will move the\nINTEGER value right reducing it's magnitude (i.e. x * 0.1). It\nalso captures the ones column lost in the shift.  Repeatedly calling\n`IntShiftRight` will let us peal off the ones columns until the\nvalue \"x\" is zero. `IntShiftLeft` shifts the integer to the\nleft meaning it raises it a magnitude (i.e. x * 10). `IntShiftLeft`\nalso rakes a value to shift in on the right side of the number.\nIn this way we can shift in a zero and get `x * 10` or shift in\nanother digit and get `(x * 10) + y`. This means you can use\n`IntShiftRight` and recover an `IntShiftLeft`.\n\n~~~\n\n(* IntShiftRight converts the input integer to a real, multiplies by 0.1\n   and converts by to an integer. The value in the ones column is record\n   in the VAR parameter r.  E.g. IntShiftRight(123) return 12, r is set to 3. *)\nPROCEDURE IntShiftRight*(x : INTEGER; VAR r : INTEGER) : INTEGER;\n  VAR i : INTEGER; isNeg : BOOLEAN;\nBEGIN\n  isNeg := (x < 0);\n  i := FLOOR(FLT(ABS(x)) * 0.1);\n  r := ABS(x) - (i * 10);\n  IF isNeg THEN\n    i := i * (-1);\n  END;\n  RETURN i\nEND IntShiftRight;\n\n(* IntShiftLeft multiples input value by 10 and adds y. E.g. IntShiftLeft(123, 4) return 1234 *)\nPROCEDURE IntShiftLeft*(x, y : INTEGER) : INTEGER;\n  VAR i : INTEGER; isNeg : BOOLEAN;\nBEGIN\n  isNeg := (x < 0);\n  i := (ABS(x) * 10) + y;\n  IF isNeg THEN\n    i := i * (-1);\n  END;\n  RETURN i\nEND IntShiftLeft;\n\n~~~\n\nI have what I need for implementing `Itoa` (integer to ASCII).\n\n\n~~~\n\n(* Itoa converts an INTEGER to an ASCII string setting ok BOOLEAN to\n   TRUE if value ARRAY OF CHAR holds the full integer, FALSE if\n   value was too small to hold the integer value.  *)\nPROCEDURE Itoa*(x : INTEGER; VAR value : ARRAY OF CHAR; ok : BOOLEAN);\n  VAR i, j, k, l, minL : INTEGER; tmp : ARRAY BUFSIZE OF CHAR; isNeg : BOOLEAN;\nBEGIN\n  i := 0; j := 0; k := 0; l := LEN(value); isNeg := (x < 0);\n  IF isNeg THEN\n    (* minimum string length for value is 3, negative sign, digit and 0X *)\n    minL := 3;\n  ELSE \n    (* minimum string length for value is 2, one digit and 0X *)\n    minL := 2; \n  END;\n  ok := (l >= minL) & (LEN(value) >= LEN(tmp));\n  IF ok THEN\n    IF IsIntDigit(ABS(x)) THEN\n      IF isNeg THEN\n         value[i] := \"-\"; INC(i);\n      END;\n      value[i] := DigitToChar(ABS(x), ok); INC(i); value[i] := 0X;\n    ELSE\n      x := ABS(x); (* We need to work with the absolute value of x *)\n      i := 0; tmp[i] := 0X;\n      WHILE (x >= 10) & ok DO\n        (* extract the ones columns *)\n        x := IntShiftRight(x, k); (* a holds the shifted value, \n                                     \"k\" holds the ones column \n                                     value shifted out. *)\n        (* write append k to our temp array holding values in\n           reverse number magnitude *)\n        tmp[i] := DigitToChar(k, ok); INC(i); tmp[i] := 0X;\n      END;\n      (* We now can convert the remaining \"ones\" column. *)\n      tmp[i] := DigitToChar(x, ok); INC(i); tmp[i] := 0X;\n      IF ok THEN\n        (* now reverse the order of tmp string append each\n           character to value *)\n        i := 0; j := Strings.Length(tmp) - 2;\n        IF isNeg THEN\n          value[i] := \"-\"; INC(i);\n        END;\n        j := Strings.Length(tmp) - 1;\n        WHILE (j > -1) DO\n          value[i]:= tmp[j]; \n          INC(i); DEC(j);\n          value[i] := 0X;\n        END;\n        value[i] := 0X;\n      END;\n    END; \n  ELSE\n    ok := FALSE;\n  END;\nEND Itoa;\n\n~~~\n\nIntegers in Oberon are signed. So I've chosen to capture the sign in the `isNeg` variable. This lets me work with the absolute value for the actual conversion.  One failing in this implementation is I don't detect an overflow.  Also notice that I am accumulating the individual column values in reverse order (lowest magnitude first).  That is what I need a temporary buffer. I can then copy the values in reverse order into the VAR ARRAY OF CHAR. Finally I also maintain the ok BOOLEAN to track if anything went wrong.\n\nWhen moving from an ASCII representation I can simplified the code by having a local (to the module) procedure for generating magnitudes.\n\nGoing the other way I can simplify my `Atoi` if I have an local to the module \"magnitude\" procedure.\n\n~~~\n\n(* magnitude takes x and multiplies it be 10^y, If y is positive zeros\n   are appended to the right side (i.e. multiplied by 10). If y is\n   negative then the result is shifted left (i.e.. multiplied by\n   0.1 via IntShiftRight().).  The digit(s) shift to the fractional\n   side of the decimal are ignored. *)\nPROCEDURE magnitude(x, y : INTEGER) : INTEGER;\n  VAR z, w : INTEGER;\nBEGIN\n  z := 1;\n  IF y >= 0 THEN\n    WHILE y > 0 DO\n      z := IntShiftLeft(z, 0);\n      DEC(y);\n    END;\n  ELSE\n    WHILE y < 0 DO\n      x := IntShiftRight(x, w);\n      INC(y);\n    END;\n  END;\n  RETURN (x * z)\nEND magnitude;\n\n~~~\n\nAnd with that I can put together my `Atoi` (ASCII to integer) procedure.  I'll need to add some sanity checks as well.\n\n~~~\n\n(* Atoi converts an ASCII string to a signed integer value\n   setting the ok BOOLEAN to TRUE on success and FALSE on error. *)\nPROCEDURE Atoi*(source : ARRAY OF CHAR; VAR value : INTEGER; VAR ok : BOOLEAN);\n  VAR i, l, a, m: INTEGER; isNeg : BOOLEAN;\nBEGIN\n  (* \"i\" is the current CHAR position we're analyzing, \"l\" is the\n     length of our string, \"a\" holds the accumulated value,\n     \"m\" holds the current magnitude we're working with *)\n  i := 0; l := Strings.Length(source);\n  a := 0; m := l - 1; isNeg := FALSE; ok := TRUE;\n  (* Validate magnitude and sign behavior *)\n  IF (l > 0) & (source[0] = \"-\") THEN\n    INC(i); DEC(m);\n    isNeg := TRUE;\n  ELSIF (l > 0) & (source[0] = \"+\") THEN\n    INC(i); DEC(m);\n  END;\n\n  (* The accumulator should always hold a positive integer, if the\n     sign flips we have overflow, ok should be set to FALSE *)\n  ok := TRUE;\n  WHILE (i < l) & ok DO\n    a := a + magnitude(CharToDigit(source[i], ok), m);\n    IF a < 0 THEN\n      ok := FALSE; (* we have an overflow condition *)\n    END;\n    DEC(m);\n    INC(i);\n  END;\n  IF ok THEN\n    IF (i = l) THEN\n      IF isNeg THEN\n        value := a * (-1);\n      ELSE\n        value := a;\n      END;\n    END;\n  END;\nEND Atoi;\n\n~~~\n\nHere's an example using the procedures.\n\nConverting an integer 1234 to an string \"1234\".\n\n~~~\n\n   x := 1234; s := \"\"; ok := FALSE;\n   Types.Itoa(x, s, ok);\n   IF ok THEN \n     Out.String(s); Out.String(\" = \");\n     Out.Int(x,1);Out.Ln;\n   ELSE\n     Out.String(\"Something went wrong\");Out.Ln;\n   END;\n\n~~~\n\nConverting a string \"56789\" to integer 56789.\n\n~~~\n\n   x := 0; src := \"56789\"; ok := FALSE;\n   Types.Atoi(src, x, ok);\n   IF ok THEN \n     Out.Int(x,1); Out.String(\" = \"); Out.String(s); \n     Out.Ln;\n   ELSE\n     Out.String(\"Something went wrong\");Out.Ln;\n   END;\n\n~~~\n\n\nReferences and resources\n------------------------\n\nImplementations for modules for this article are linked here [Types](./Types.Mod), [TypesTest](./TypesTest.Mod) and [Tests](./Tests.Mod). \n\nExpanded versions of the `Types` module will be available as part of Artemis Project -- [github.com/rsdoiel/Artemis](https://github.com/rsdoiel/Artemis).\n\nPrevious\n--------\n\n- [Revisiting Files](../../11/22/Revisiting-Files.html)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-11-26",
        "keywords": [
          "Oberon",
          "Modules",
          "Types",
          "conversion"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 21,
        "title": "Portable Conversions (Integers)"
      },
      "url": "posts/2021/11/26/Portable-Conversions-Integers.json"
    },
    {
      "content": "\n\nA2 Oberon on VirtualBox 6.1\n===========================\n\nBy R. S. Doiel, 2021-04-02\n\nThis is a short article documenting how I install A2 Oberon\nin VirtualBox using the [FreeDOS 1.2](https://freedos.org),\nthe A2 [ISO](https://sourceforge.net/projects/a2oberon/files/) cd image and [VirtualBox 6.1](https://virtualbox.org).\n\nBasic Approach\n--------------\n\n1. Download the ISO images for FreeDOS and A2\n2. Create a new Virtual Machine\n3. Install FreeDOS 1.2 (Base install) in the virtual machine\n4. Install A2 from the ISO image over the FreeDOS installation\n\nFrom working with Native Oberon 2.3.7 I've found it very helpful\nto have a FreeDOS 1.2. installed in the Virtual machine first. \nI suspect the reason I have had better luck taking this approach\nis based on assumptions about the virtual hard disk being setup\nwith an existing known formatted, boot-able partition. In essence\nmaking our Virtualbox look like a fresh out of the box vintage PC.\n\nDownload the ISO Images for FreeDOS and A2\n------------------------------------------\n\nYou'll find FreeDOS 1.2 installation ISO image at \n[FreeDos.org](http://freedos.org/download/). Download it\nwhere you can easily find it from the VirtualBox manager.\n\nYou'll find the A2 Oberon ISO image at [SourceForge](https://sourceforge.net/projects/a2oberon/files/) in the A2 Files section. There is a green download\nbutton you can click and it'll take you to a downloads page and download\nthe ISO.  Once again move it to where you can find it from \nthe VirtualBox manager easily.\n\n\nCreate a new Virtual Machine\n----------------------------\n\nFire up VirtualBox.  Click the \"New\" icon. Given your machine\na descriptive name and set the Type to \"Other\" and version to \"DOS\".\nClick Next.\n\nOn the Memory Size panel select the memory size you want. I picked\n2048 MB. A2 like other Oberon are frugal in resource consumption.\nClick Next.\n\nOn the Hard Disk panel I accepted the default \"Create a virtual hard disk now\"\nand clicked \"Create\" button at the bottom of the panel.\n\nI accepted the default \"VDI (VirtualBox Disk Image)\" and clicked\nNext.\n\nI accepted \"Dynamically allocated\" and clicked Next.\n\nI accepted the default name and 500 MB disk size and clicked\nCreate.\n\nThis returned me to the main VirtualBox manager panel. I click on \nthe \"Settings\" icon. This opens the Settings panel. I Clicked on the\n\"Display\" label in the left side of the panel. On the \"Screen\" tab\nI increased the Video Memory from 6 MB to 128 MB.  I also checked\nthe \"Enable 3D Acceleration\" box.\n\nNext I clicked  \"Network\" label in the left side of the panel.\nI changed the Attached to from \"NAT\" to \"Bridged Adapter\"\nbefore clicking \"OK\". This should return you to the manager panel.\n\nScroll down the description of your virtual machine so that the\n\"Storage\" section is visible. You should see \"IDE Secondary Device 0: \n[Optical Drive] Empty\". Click the the words \"Optical Drive\".\nYou be given a context menu, click on \"Choose a Disk file\". Navigate\nto where you saved the FressDOS ISO (e.g. FD12CD.iso).\nClick Open. This should return you to the manager panel and you\nshould see the \"FD12CD.iso\" file listed.\n\nInstall FreeDOS 1.2\n-------------------\n\nClick the \"Start\" button.  This should boot the machine. By\ndefault the search order for booting is floppy drive,\nCD-ROM drive then hard disk.  Since we have the FD12CD.iso\nmounted in the cd ROM drive it'll boot using it.\n\nWhen you see the \"Welcome\" screen press the tab key.\nYou should see a line describing the image it'll boot.  Click\ninto the Virtual machine's window and press the space bar\nthen type \"raw\" (without the quotes). Press the enter key.\n\nThis should return you to the install process, select your\nlanguage (e.g. English for me). The select \"Yes - Continue with the\ninstallations\". On the next screen select \"Yes - Partition drive C:\".\nThen select \"Yes - Please reboot now\". This will reboot the\nmachine and bring you back to the Welcome page. Once again\npress the tab key, press the space bar and type in \"raw\"\n(without the quotes).\n\nAs before select your language and select \"Yes - Continue with\nthe installation\". This time you should see the option \n\"Yes - Please erase and format drive C:\", select it. \nAfter formatting it ask you to select your keyboard type.\nIt will then give you the option of installing base or full\ninstallations (with our without source).  I suggest only\nselecting \"Base packages only\".  \n\nOn the next screen select \"Yes - Please install FreeDOS 1.2\".\nAfter it finishes you can select \"Yes - Please reboot now\".\nWhen the machine reboots you'll see the welcome screen again\nbut rather than press tab, select \"Boot system from hard disk\".\nPress enter to select the extended memory manager and you\nshould now be at the DOS \"C:>\" prompt.\n\nSwitch back to the VirtualBox manager panel and click on\n\"Optical Drive\" and click \"Remove disk from virtual drive\".\n\nInstalling A2 Oberon\n--------------------\n\nWe now should have a Virtual Machine ready to receive A2.\nClick the \"Optical Drive\" again and select the A2 ISO\nimage you downloaded from SourceForge previously.\nYour optical drive should show the full filename of\nthe ISO image, e.g. \"A2_Rev-6498_serial-trace.iso\"\nWe can now click the \"Start\" icon in the manager panel.\n\nA2 comes up running like a \"live CD\".  It's the full A2\nso you can play around with it if you want but we're going\nto install it on our virtual hard drive. At the bottom of the\nA2 desktop you should see a panel of buttons. Click the button\nlabeled \"System\". This will change the panel buttons below it.\nIn the lower panel you should see \"Installer\", click it. This\nwill bring up a \"Welcome to Oberon\" installer window. You will\nsee two presentations of drives. The upper one will be the hard\ndrive where we want to install A2 and the lower one is the \nvirtual CD ROM we're running. Click on the bar for the hard disk.\nBefore click the drive bar was red. After clicking it was yellow.\nThe text label above the var says, \"IDE0 (VBOX HARD DISK), Size \n500 MB, Open count 0\".\n\nIn the lower part of the panel click \"Quickinstall\", then\nanswer Yes to the model dialog that pops up. After a few moments \nA2 should finish installing itself on the virtual hard disk.  The lower\npanel's buttons will include one labeled \"Done\", press it. This\nwill close the installer window.\n\nAt the bottom of the desktop you should still see the System\npanel buttons. There is a red one labeled \"Shutdown\". Press it.\n\nThe virtual machine's screen should go black. On my machine\nI press the right control key (the host key) to release my\nmouse and keyboard from the virtual machine. Close the window\nand when it select \"Power of the machine\" in when VirtualBox\nprompts how to shut it down.\n\nLike with the FD12CD.iso we want to unmount our A2 installation\nCD ROM. Click on the \"Optical Drive\" in the manager panel\nand choose \"Remove disk from virtual Drive\". \n\nYou can now start the machine again and start exploring A2.\nI recommend looking at the [Oberon Wikibook](https://en.wikibooks.org/wiki/Oberon#A2_and_UnixAOS)\n for details about how to use A2 and ideas of what to explore.\n\nOne nice feature of A2 is it includes a full \"NativeOberon\"\nor ETH Oberon as an A2 Application.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-04-02",
        "keywords": [
          "FreeDOS 1.2",
          "VirtualBox 6.1",
          "A2 Oberon"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "A2 Oberon on VirtualBox 6.1"
      },
      "url": "posts/2021/04/02/A2-Oberon-on-VirtualBox-6.1.json"
    },
    {
      "content": "\nOfront on Raspberry Pi OS\n=========================\n\nBy R. S. Doiel, 2021-04-25\n\nThis post is about getting Ofront[^1] up and running on Raspberry Pi OS[^2].\nOfront provides a Oberon-2 to C transpiler as well as a Oberon V4[^3]\ndevelopment environment. There are additional clever tools like `ocat`\nthat are helpful working with the differences in text file formats between\nOberon System 3, V4 and POSIX. The V4 implementation sits nicely on top of\nPOSIX with minimal compromises that distract from the Oberon experience.\n\n[^1]: Ofront was developed by Joseph Templ, see http://www.software-templ.com/ \n\n[^2]: see https://www.raspberrypi.org/software/ (a 32 bit Debian based Linux for both i386 and ARM)\n\n[^3]: see https://ssw.jku.at/Research/Projects/Oberon.html\n\n\nAn Initial Impression\n---------------------\n\nI first heard of running Ofront/V4 via the ETH Oberon Mail list[^4].\nWhat caught my eye is the reference to running on Raspberry Pi. Prof. Templ \nprovides two flavors of Ofront. One targets the Raspberry Pi OS on ARM\nhardware the second Linux on i386. The Raspberry Pi OS for Intel is an\ni386 variant. I downloaded the tar file, unpacked it and immediately ran\nthe \"oberon.bash\" script provided eager to see a V4 environment. It\nrenders but the fonts rendered terribly slowly. I should have read the\ndocumentation first!  Prof. Templ provides man pages for the tools that\ncome with Ofront including the oberon application. Reading the\nman page for oberon quickly addresses the point of slow font rendering.\nIt also discusses how to convert Oberon fonts to X Windows bitmap fonts.\nIf you use the X Window fonts the V4 environment is very snappy. It does\nrequire that X Windows knows where to find the fonts used in V4. That is\ndone by appending the V4 converted fonts to the X Window font map. I had\ninstalled the Ofront system in my home directory so the command was\n\n```bash\nxset +fp $HOME/ofront_1.4/fonts\n```\n\nRunning \"oberon.bash\" after that immediately improved things. Since I didn't\nneed the Oberon fonts outside of V4 I added the `xset` command to the\n\"oberon.bash\" script just before it invokes the `oberon` command.\n\n[^4]: See Hans Klaver's message: http://lists.inf.ethz.ch/pipermail/oberon/2021/015514.html \n\n\nGoals in my setup\n-----------------\n\nI had three goals in wanting to play with Ofront and running the V4\nOberon.\n\n1. I wanted to work in an Oberon System environment\n2. I need a system meets my vision requirements (e.g. larger font size)\n3. I wanted to understand the Linz/V4 variation in Oberon's evolution\n\nOfront address all three once you get the X Window side setup correctly.\n\nSetting up Ofront and V4\n------------------------\n\nFirst we need to boot up a Raspberry Pi OS device (or an i386 Linux with X11).\nWe need to retrieve the software from Joseph Templ's [software-templ.com](https://software-templ.com).\nTwo 1.4 versions are available precompiled. The first is for ARM running\nRaspberry Pi OS and the second is for generic Linux i386 with X11. I initially\ntested this on an old laptop where running the i386 version of Raspberry Pi OS. \n\nWhat we need\n------------\n\nThe following software is usually already installed on your \nRaspberry Pi OS.\n\n+ curl to download the files[^5]\n+ gunzip to uncompressed the archive file\n+ tar to unpack the archive file\n\n[^5]: If not try `sudo apt install curl` from the command line\n\nWhat we do\n----------\n\n1. Download the appropriate tar file\n    a. ARM: http://www.software-templ.com/shareware/ofront-1.4_raspbian-Pi3.tar.gz\n    b. Intel i386: http://www.software-templ.com/shareware/ofront-1.4_linux-386-3.2.tar.gz\n2. Make sure we can read the compressed archive file\n3. Gunzip and untar the file\n\nHere's the commands I used for the Raspberry Pi hardware.\n\n```bash\n    curl -O http://www.software-templ.com/shareware/ofront-1.4_raspbian-Pi3.tar.gz\n    tar ztvf ofront-1.4_raspbian-Pi3.tar.gz\n    tar zxvf ofront-1.4_raspbian-Pi3.tar.gz\n```\n\nHere's the commands I used for Raspberry Pi OS on Intel\n\n```bash\n    curl -O http://www.software-templ.com/shareware/ofront-1.4_linux-386-3.2.tar.gz\n    tar ztvf ofront-1.4_linux-386-3.2.tar.gz\n    tar zxvf ofront-1.4_linux-386-3.2.tar.gz\n```\n\nAt this point there should be an `ofront_1.4` directory\nwhere you gunziped and untared the archive file. At this point\nyou can test to make sure everything runs by doing the following\n(remember the font rendering with be very slow).\n\n```\n    cd ofront_1.4\n    ./oberon.bash\n```\n\nYou can exit the V4 environment by closing the window or typing\n`System.Quit ~` in an Oberon viewer and middle clicking with your\nmouse[^6].\n\n[^6]: Oberon Systems expect a three button mouse, with a two button mouse you hold the alt key and press the left button. Note that command in Oberon are case sensitive.\n\nThe reason the system is so slow is that X is having to write bitmaps\na pixel at a time in the window holding our Oberon System. What we\nwant X to do is render an X Window font.  Joseph as provided us with\nthe Oberon fonts already converted for X! We just need to let the\nX Window system know where to look.\n\nWhat we need\n------------\n\n+ an editor for editing `oberon.bash`\n\nWhat we'll do\n-------------\n\n1. Exit the running Oberon System using `System.Quit ~` or just close the window\n2. Edit `oberon.bash` to speed up font rendering\n3. Try `oberon.bash` again and see the speed bump\n\nWith your favorite editor add the `xset` line before the `oberon`\ncommand is invoked. My \"oberon.bash\" looks like this.\n\n```\n#!/bin/bash\n\nif [ -z \"$OFRONT_HOME\" ]; then\n  export OFRONT_HOME=.\n  echo \"OFRONT_HOME set to .\"\nfi\nexport OBERON=.:$OFRONT_HOME/V4_ofront:$OFRONT_HOME/V4:$OFRONT_HOME/fonts\nexport LD_LIBRARY_PATH=.:$OFRONT_HOME/lib\nexport PATH=.:$OFRONT_HOME/bin:$PATH\nxset +fp $HOME/ofront_1.4/fonts\n$OFRONT_HOME/bin/oberon -f ./V4/Big.Map -u 8000 -c $* &\n```\n\nThe `xset` command adds the provided X fonts to X Window. This\nresults in a huge speedup of rendering. I also add the options\nfor using the largest font sizes via a font map file, \"V4/Big.Map\"\nand set the display units to 8000. Your vision or monitor may\nnot need this so you want to only add the line to include the\nX fonts needed by Oberon.\n\nNow re-launch Oberon using the updated \"oberon.bash\" and\nsee the improvement.\n\n```\n    vi oberon.bash\n    ./oberon.bash\n```\n\nYou now have a functioning V4 Oberon System to play with and\nexplore.\n\nThere are some additional POSIX environment setup you can\nadd to improve the integration with your Linux setup. These\nare covered in the man pages for the tools that come with Ofront.\nAdditional information is also provided in the Oberon Texts\nand Tools files in the V4 environment. All are worth reading.\n\n\nWhat does this setup provide?\n-----------------------------\n\nAt the point we have V4 available we have a rich development\nand text environment. One which I feel is conducive to both\nwriting in general and programming specifically. You are running\nunder an adapted Oberon System so there are somethings to consider.\n\nThe Oberon V4 file system does support punctuation characters aside\nfrom periods and slashes.  So when I tried to edit a file with hyphens\nin the name Oberon assumed the filename stopped at the first hyphens.\nThe Oberon file systems are typically case sensitive so this can\nbe worked around with letter case. Of course I could modify the V4\nsystem to allow for more letters too. That's the nice thing about\nhaving the source code.\n\nThe second issue if file format.  In Oberon we can embed fonts\nand coloring and that is treated as normal text. End of line\ncharacters are represented as a carriage return. In POSIX environments\nwe have \"plain text\" without specific font directives and we use\na line feed to terminate lines. Fortunately Prof. Templ provided\na program called `ocat`[^7] that makes short work of converting an\nOberon text into a POSIX friendly format. On the Oberon side of things\nit's also easy because Oberon will treat an ASCII file as a text we\nonly need to convert the line endings and in the Ofront implementation\nof V4 it handles the differences in line endings behind the scenes.\n\nIf you create or store a file in the Oberon environment it'll become\nOberon text. If you need to have a plain text version use `ocat`.\nIf you only read POSIX files in the Oberon environment then they remain\nplain text files but V4 takes care of translating the POSIX line ending\nto ones that are displayed nicely in Oberon.\n\n\n[^7]: In the `ofront_1.4` directory run `man man1/ocat.1` to find out more\n\nWhat to explore next?\n---------------------\n\nNow that we have a fast running V4 system we have some choices\nfor development. Joseph Templ has adapted the display for X\nand also the file system so the files are visible from the Unix\nshell.  This is a powerful arrangement. This supports both Oberon\ndevelopment and the use of Oberon language for the development of\nPOSIX friendly programs.  The Ofront collection provides the\n`ofront` an Oberon-2 to C translator, `ocl` is a tool that will\ncombine `ofront` with your C compiler and linker to produce\nprograms and libraries for Linux. There is also `ocat` for\nconverting Oberon texts to POSIX plain text and `showdef` for\nshowing module definitions.  Finally Ofront provides the\n`oberon` command so we have an Oberon System available as a\ndevelopment environment.\n\nOne thing I recommend exploring is Jospeh Templ's GitHub repository.\nThe makefile provided with the GitHub version assuming an existing\ninstallation of ofront. Since we have one we can compile our own copy\nfrom scratch. If you're running i386 you'll want to look at\n`V4_ofront/linix386` for Pi hardware take a look at `V4_ofront/raspbian`.\n\nHere's how I generated a new version on my Pi hardware.\n\n```\n    git clone https://github.com/jtempl/ofront\n    cd ofront/V4_ofront/raspbian\n    make\n    ./oberon.bash\n```\n\nThere is a note in the README of that directory about finding\n`libX11.so` but I did not need the symbolic link suggested. Since the\nfont path was previously adjusted for the original version I downloaded\nfrom Templ's website I didn't need to add the fonts again. If I fork\nTempl's version or GitHub I will probably update the \"oberon.bash\"\nfile included to check to see if the X fonts are available and if not\nadd them via `xset`. That's on a someday maybe list, for now I am\ncontent exploring the system as is.\n\n\nSomeday, Maybe\n--------------\n\nThings that come to mind after initial exploration include--\n\n- Figure out how to make Atkinson-Hyperlegible[^8] available to V4\n- Replace the X11 integration with SDL 2 integration and run under macOS or Windows\n- Exploring porting V4 to run natively Raspberry Pi via Clang cross compilers\n\nNot sure I'll get the time or have the energy to do these things but\nthey are certainly seem feasible with Ofront as it stands now.\n\n[^8]: See https://brailleinstitute.org/freefont\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-04-25",
        "keywords": [
          "Oberon",
          "Raspberry Pi OS",
          "Ofront",
          "Mostly Oberon",
          "V4",
          "Linz"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Ofront on Raspberry Pi OS"
      },
      "url": "posts/2021/04/25/Ofront-on-Rasberry-Pi-OS.json"
    },
    {
      "content": "\nUpdating Schema in SQLite3\n==========================\n\nBy R. S. Doiel, 2020-04-16\n\n[SQLite3](https://sqlite.org/docs.html) is a handy little\ndatabase as single file tool.  You can interact with the file\nthrough largely standard SQL commands and embed it easily into\napplications via the C libraries that the project supports.\nIt is also available from various popular scripting languages\nlike Python, PHP, and Lua. One of the things I occasionally\nneed to do and always seems to forget it how to is modify a\ntable schema where I need to remove a column[^1]. So here are\nsome of the basics do I can quickly find them later and avoid\nreading various articles tutorials because the search engines\ndoesn't return the page in the SQLite documentation.\n\n[^1]: The SQL `ALTER TABLE table_name DROP COLUMN column_name` does not work in SQLite3\n\nIn the next sections I'll be modeling a simple person object\nwith a id, uname, display_name, role and updated fields.\n\nCreating a person table\n-----------------------\n\n\n```sql\n\nCREATE TABLE IF NOT EXISTS \"person\" \n        (\"id\" INTEGER NOT NULL PRIMARY KEY, \n        \"uname\" VARCHAR(255) NOT NULL, \n        \"role\" VARCHAR(255) NOT NULL, \n        \"display_name\" VARCHAR(255) NOT NULL, \n        \"updated\" INTEGER NOT NULL);\n\n```\n\nAdding a column\n---------------\n\nWe will create a *junk* column which we will remove later.\n\n```sql\n\n.schema person\nALTER TABLE person ADD COLUMN junk VARCHAR(255) NOT NULL;\n.schema person\n\n```\n\nDropping a column\n-----------------\n\nTo drop a column in SQLite you need to actually create\na new table, migrate the data into it then drop the old table\nand finally rename it. It is best to wrap this in a transaction.\n\n```sql\n\nBEGIN TRANSACTION;\n    CREATE TABLE IF NOT EXISTS \"person_new\" \n           (\"id\" INTEGER NOT NULL PRIMARY KEY, \n           \"uname\" VARCHAR(255) NOT NULL, \n           \"role\" VARCHAR(255) NOT NULL, \n           \"display_name\" VARCHAR(255) NOT NULL, \n           \"updated\" INTEGER NOT NULL);\n    INSERT INTO person_new\n           SELECT id, uname, role, display_name, updated\n           FROM person;\n    DROP TABLE person;\n    ALTER TABLE person_new RENAME TO person;\nCOMMIT;\n\n```\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-04-16",
        "keywords": [
          "SQLite",
          "SQL",
          "database"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 1,
        "series": "SQL Reflections",
        "title": "Updating Schema in SQLite3"
      },
      "url": "posts/2021/04/16/Updating-Schema-in-SQLite3.json"
    },
    {
      "content": "\nETH Oberon System 3 on VirtualBox 6.1\n=====================================\n\nBy R. S. Doiel, 2021-03-17\n\nIn this post I am walking through installing Native Oberon 2.3.7\n(aka ETH Oberon System 3) on a virtual machine running under\nVirtualBox 6.1. It is a follow up to my 2019 post \n[FreeDOS to Oberon System 3](/blog/2019/07/28/freedos-to-oberon-system-3.html \"Link to old blog post for bringing up Oberon System 3 in VirtualBox 6.0 using FreeDOS 1.2\"). To facilitate the install I will first prepare\nmy virtual machine as a FreeDOS 1.2 box. This simplifies getting the\nvirtual machines' hard disk partitioned and formatted correctly.\nWhen Native Oberon was released back in 1990's most Intel flavored\nmachines shipped with some sort Microsoft OS on them.  I believe\nthat is why the tools and instructions for Native Oberon assume\nyou're installing over or along side a DOS partition.\n\nBuilding our machine\n--------------------\n\nRequirements\n------------\n\n1. Install VirtualBox 6.1 installed on your host computer.\n2. Download and install a minimal FreeDOS 1.2 as a virtual machine\n3. Downloaded a copy of Native Oberon 2.3.7 alpha from SourceForge\n3. Familiarized yourself Oberon's Text User Interface\n4. Boot your FreeDOS virtual machine using the Oberon0.Dsk downloaded\nas part of NativeOberon_2.3.7.tar.gz\n5. Mount \"Oberon0.Dsk\" and start installing Native Oberon\n\nBefore you boot \"Oberon0.Dsk\" on your virtual machine make sure\nyou've looked at some online Oberon documentation. This is important.\nOberon is very different from macOS, Windows, Linux, DOS, CP/M or\nUnix. It is easy to read the instructions and miss important details \nlike how you use the three button mouse, particularly the selections\nand execute actions of text instructions.\n\nVirtual Machine Setup\n---------------------\n\nVirtualBox 6.1 can be obtained from [virtualbox.org](https://www.virtualbox.org/).  This involves downloading the installer for your particular host\noperating system (e.g. Linux, macOS or Windows) and follow the instructions\non the VirtualBox website to complete the installation.\n\nOnce VirtualBox is installed, launch VirtualBox.\n\nClick the \"New\" button and name your machine (e.g. \"Native Oberon 2.3.7 Alpha\") and choose type of \"Other\" and version \"DOS\". Click continue. I accepted\nthe default memory size of 32 MB. This is plenty for Oberon.  I clicked on create disk and accepted the default VDI (VirtualBox Disk Image). Press continue. I think accepted \"Dynamically allocated\", press continue. I chose a \"disk size\" of 100.00 MB. Oberon System is tiny. Press create button.\n\nMake sure your new machine is highlight on the left side of the VirtualBox\nmanagement panel. Click on Settings button, it looks like a gear towards\nthe top. Click \"Display\" on the model dialog and bump the Video Memory\nup to 128 MB. I also clicked Enable 3D Acceleration (though I don't think\nOberon uses this).  Before clicking OK click on the Network icon in the \nmodal dialog box. Change \"NAT\" to \"Bridged Adapter\". Now click \"OK\" to\nclose the modal dialog box. \n\nYour VirtualBox is now ready, before pressing \"Start\" we need\nto install FreeDOS 1.2.\n\nMake a FreeDOS 1.2 machine\n---------------------------\n\nDownload the [FD12CD.iso](https://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/distributions/1.2/FD12CD.iso) file from the \n[FreeDOS project](https://freedos.org/download).\n\n\"Insert\" the \"FD12CD.ISO\" file into our VirtualBox 6.1\nCD-ROM drive. Go to the VirtualBox management panel. \nIn the area that summarizes storage click the word \"Empty\"\nin the line with \"[Optical Drive]\". Find the \"FD12CD.ISO\"\nyou downloaded and select it.\n\nNow press the green \"Start\" arrow in the VirtualBox management\npanel. This should start your virtual machine and it will boot\nusing the CD-ROM drive.\n\nThis will display a welcome screen with installation options.\nPress your \"tab\" key once. This should cause a boot string to be\ndisplayed. Type a space and then type the word \"raw\" (without quotes).\nPress enter. Next select the language you want to install with\n(e.g. English). Choose \"Yes - Continue with installation\" on the\nnext prompt. You should then be given a dialog box that\nindicates \"Drive C: does not appear to be partitioned.\", select\n\"Yes - Partition drive C:\". Then that completes press\n\"Yes - Please reboot now\". \n\nThis will cause the machine to reboot and you will be faced with\nthe \"Welcome to FreeDOS 1.2\" screen once again. Press the \"tab\"\nAdd a space and type \"raw\" to the boot string as before.\nSelect the language again then select \"Yes - Continue with \ninstallation\". The screen should now say something like\n\"Drive C: does not appear to be formatted\", select \n\"Yes - Please erase and format drive C:\".\n\nWhen done it'll gather some info on the system and ask you\nwhich keyboard you're using. Pick yours (e.g. \"US English (Default)\").\nIt will then give you a choice of what to install. Since we're\ngoing to overwrite this when we install Oberon just select\nthe base package, then select \"Yes - Please install FreeDOS 1.2\"\n\nBefore selecting \"Yes - Please reboot now\" when the install is\nfinished you want to \"eject\" your FD12CD.ISO from the virtual\nCD-ROM drive.  Switch back to your VirtualBox management panel.\nClick the text that says \"FD12CD.iso\" and select \"remove disk\nfrom virtual drive\" in the popup menu. Switch back to your\nVirtual machine and select \"Yes - Please reboot now\"\n\nIf all goes well the machine will boot into FreeDOS 1.2. When\nyou see the \"C:>\" prompt type \"shutdown\" (without the quotes)\nand press enter. We're now ready to start installing Native\nOberon 2.3.7.\n\n\nNative Oberon 2.3.7\n-------------------\n\nNative Oberon used to be hosted at ETH where Oberon and the Oberon\nSystem was first developed as a research and instructional project.\nUnfortunately this seems to no longer be supported by ETH. Prof. Wirth\nhas long been retired now and they no longer choose to use such a \nuseful language or Operating System. \n\nSourceForge has a mirror of the original sources and some of the\nremaining community has put at a \"new\" release of 2.3.7 Alpha \nbringing Native Oberon a little closer to the present. It's this\nversion we'll use. You can read more at the [SourceForge](https://sourceforge.net/projects/nativeoberon/) as well as at the [Oberon Wikibook](https://en.wikibooks.org/wiki/Oberon). ETH also still maintains an email\nlist for Oberon and it is active. It can be found at\nhttps://lists.inf.ethz.ch/mailman/listinfo/oberon. I recommend\nbrowsing the archives of the Email list if you run into problems.\nI've found very helpful information there and the people on the\nlist seem happy to answer a novices question.\n\nWe are going to be downloading files from the Native Oberon Project's\nFiles page at SourceForge.\n\n> https://sourceforge.net/projects/nativeoberon/files/nativeoberon/\n\nIn the Files page download the instructions \n[NativeOberonInstall.pdf](https://sourceforge.net/projects/nativeoberon/files/NativeOberonInstall.pdf/download) \nor or the text version. This document by Pieter Muller (May 1999) explains\nthe installation process. It is good for its overview though I found\nthe actual process simpler than what was described for May 1999. \n\nOn the Files page you'll also see a green button to \"Download Latest Version\", NativeOberon_2.3.7.tar.gz. Click the button and download it.\n\nThe NativeOberon_2.3.7.tar.gz contains the files we'll need to run\nNativeOberon on our VirtualBox. Ungzip and untar the file into\na location that is convenient for you. I put mine\nin `src/NativeOberon-2.3.7` and I had downloaded the file into my\nhome directory's \"Downloads\" folder. \n\n```shell\n    mkdir -p src/NativeOberon-2.3.7\n    cd src/NativeObeorn-2.3.7\n    tar zxvf ~/Downloads/NativeOberon_2.3.7.tar.gz\n```\n\nYou now have the software ready to proceed in installing the system\nin VirtualBox.\n\nNativeOberon in a VirtualBox\n----------------------------\n\nGo back to your VirtualBox management panel. We need to place\nhe boot disk image in the virtual floppy drive. In the files\nwe unpacked (i.e. ungzip and untar) there is a file named\n\"Oberon0.Dsk\".  We want to mount that in the virtual floppy drive.\nClick on the word \"Empty\" next to \"Floppy Device 0:\" in the management\npanel. You are then given a modal dialog box and we want to select \n\"Choose a disk file\". You can then find the files you save and \nselect \"Oberon0.Dsk\". \n\nBooting with Oberon0.Dsk\n------------------------\n\nWe can now click \"Start\" button at the top of the VirtualBox management\npanel. This will boot the virtual machine using \"Oberon0.Dsk\". Oberon\nitself loads completely into memory. \n\nYou now have a running Oberon System but we need to install it\non the virtual hard drive. Fortunately our running system comes with\nbuilt in instructions.  It is here that people how haven't \nused Oberon before are going to run into trouble.\n\nOberon System uses all three buttons of a three button mouse. On\nmost mice I've encountered to day there are two buttons and a\nscroll wheel. The scroll wheel is click able and functions like\nthe middle button on an Oberon mouse.\n\nThe left mount button sets the pointer, the middle button (our\nscroll wheel if your mouse is like mine) is used to execute\ncommands and the right mouse button is used to select text.\nIn our installation instructions displayed on our virtual \nmachine we generally be middle clicking the blue colored text. \n\nIn Native Oberon all text is potentially actionable.  Unlike in\nUnix where you type a command press enter then have to retype\n(or use the command history) to execute the next command we're\ngoing to click on the text and sometimes select text to execute\ncommands.  Before we proceed I highly recommend readying\nand trying a tutorial out before attempting to install Oberon\non your virtual hard drive. There is an [Oberon System 3 - Main Tutorial](https://web.archive.org/web/20171226183816/http://www.ethoberon.ethz.ch/ethoberon/tutorial/) available at the Internet Archive's Wayback machine.\n\nInstalling to our Virtual Hard disk\n----------------------------------\n\nAlong the right side (in the system track) is the text \"Edit.Open Introduction.Text\". Click with your middle button (scroll wheel on my\nmouse) and this will open the text in the \"Edit\" track on the left\nside.  Read this text if you haven't before. Scrolling through\nthe text is a little different than the scroll bars on macOS, Windows,\nX Windows. They are on the left side and the middle mouse button\nsets the scroll position. The left button pages down, the right\npages up.  You can close the \"Introduction.Text\" windows by \nmiddle clicking \"System.Close\" in the upper menu bar.\n\nReview step 1.\n--------------\n\nWe need to configure the hard drive by middle clicking on\n\"Config.Desk Standard ATA/EIDE\"[^1]. In the console viewer above\nyou should see something like\n\n[^1]: This blue text makes it clear the command is actionable, like a link in the web browser. But the actual text is the command not the color.\n\n```\nDisk: Standard ATA/EIDE\nStatic BootLinker for OM Object Files / prk\n linking Native.Bin 255388\n```\n\nReview step 2.\n--------------\n\nMiddle click on \"Edit.Open InstallFiles.Tool\".  A \"Tool\" file\nis like a text file but usually contains instructions and\na sorta menu or recipe of commands.  In fact our instructions\nin the lower viewer of the system track is a \"Tool\" file called\n\"Install.Tool\".  Using \"Edit.Open\" to open the tool or text file\nopens a viewer on the left track, the edit track. If you had\nclicked on \"System.Open Install.Tool\" it would open a viewer\non the right, or systems track. In either track by default\nthe viewers will tile (not overlap).  If you want to close\na view you can click on \"System.Close\" in the viewer's menu\nbar. Now open our InstallFiles.Tool in the edit track.\n\nInstallFiles.Tool\n-----------------\n\nWe now are going to prepare our virtual hard drive. Like\nour \"Install.Tool\" text we have a series of instructions\nwhich commands we can click on (the ones in blue).\n\nMiddle click on \"Partitions.Show ~\". This will open a pain\nshowing the partition information. You should see something\nlike\n\n```\nDisk: Diskette0, GetSize: no media, removable\n\nDisk: IDE0, 99MB, VBOX HARDDISK\nIDE0#00        99MB  --- (Whole disk)\nIDE0#01        99MB  --- (Free)\n\nDisk: IDE2, GetSize: no media, removable, VBOX CD-ROM\n```\n\nThis tells us we have three drives in our VirtualBox\nvisible to Oberon.  The first is the floppy drive.\nIt shows \"no media\". That might seem odd but when you\nread the \"Oberon0.Dsk\" it read that into memory and the\nwhole OS is not running in memory, not from disk! While\nthe disk is still \"in the drive\" as far as VirtualBox\nis concerned it isn't \"mounted\" from the point of view of\nthe operating system.\n\nThe second disk section describes our virtual hard drive.\nThe third describes the virtual CD-ROM drive.\n\nWe're interested in using the disk \"IDE0\" with the\ndevice number of \"01\", we express that as \"IDE0#01\". \n\nIn the \"Partitions.Text\" viewer where we see the\npartitions information we can type the command\ndescribed in \"InstallFiles.Tool\"\n\n```\nPartitions.ChangeType IDE0#01 6 76 ~\n```\n\nWe then middle mouse click on line we just type. This\nshould produce output in the \"System.Log\" view in the\nupper right of the screen that looks like\n\n```\nIDE0#01 changed to type 76\n```\n\nI had to do a modified version of step 3 of \"InstallFiles.Tool\"\nchoosing option \"b\".\n\nIn the output of \"Partitions.show ~\" (i.e. the Partitions.Text\nviewer) want to middle click on the \"I\" of \"IDE0#01\".\nThen right mouse button select \"IDE0#01\". \n\nFrom 3a in the \"InstallFiles.Tool\" viewer middle mouse button\nclick on \"Partitions.Format ↑\". This should result in \nthe \"System.Log\" viewer showing \n\n```\nIDE0#01 format successful\n```\n\nAfter formatting the drive I was able to complete step 3b by\nmiddle clicking the commands as provided in the \"InstallFiles.Tool\"\n\n> NOTE: you may need to scroll that window to see all of step 3\n\nMiddle click on \"Partitions.UpdateBootFile ↑\" \nThe \"Systems.Log\" viewer should show\n\n```\nIDE#00 update successful\n```\n\nMiddle click on \"FilesSystem.Mount DST AosFS ↑\" in 3b. The\n\"System.Log\" viewer should show\n\n```\nDST: mounted\n```\n\nWe are ready for Step 4. This command does the brunt of the\nwork of coping things over. The command \"Configuration.DoCommands\"\ntake a list of Oberon commands and executes them one after the\nother. Middle Mouse click on \"Configuration.DoCommands\".\nThe \"System.Log\" viewer will show many messages that are\na result of each command taken. Make sure there are no errors.\nThe last series of commands renamed files so you should see\nsomething like\n\n```\nSystem.RenameFiles\nDST:Rel.Obeorn.Text => DST:Oberon.Text renaming\nDST:Rel.Network.Tool => DST:Network.Tool renaming\nDST:Rel.DOS.Tool => DST:DOS.Tool renaming\n```\n\nFor step 5 of \"InstallFiles.Tool\" we can close our \"InstallFiles.Tool\"\nviewer by middle clicking on \"System.Close\" in the menu bar. You can\nalso close the \"Partitions.Text\" viewer using its menu bar and\nmiddle clicking \"System.Close\".\n\nRight now we've formatted our hard drive and copied a bunch of \nfiles too it. We still need to configuration our system before\nit is self hosting.\n\nIn the \"Install.Tool\" viewer we want to open our \"Configure.Tool\".\nMiddle click on the \"Edit.Open Configure.Tool\".\n\nConfiguring our Oberon System\n-------------------------------\n\nThe configuration tool breaks configuration into a series of\nparts. First part is configure the display in Part two\nwe make the hard disk bootable.\n\nTo configure out display we want to middle click on the blue text in\n\"Config.DetectVesa (BIOS cal might hang some systems!)\".\nYou will be presented with a list of screen resolutions. I middle\nclicked the blue text in \"Config.Vesa 00000147H 1600 * 1200 * 32\".\nIn the \"System.Log\" viewer this showed\n\n```\nVesa mode 00000147H\n```\n\n> NOTE: You will likely need to scroll down the page using the scroll bar\n\nIn part two we need to decide how we want to boot Oberon. In our case\nI recommend Option 2, boot Oberon directly (non-FAT hosted). Middle\nclick the blue text \"Config.BootParition menu ~\".\nThe \"System.Log\" viewer should output\n\n```\nIDE0#01 config written\n```\n\nMiddle click the blue text \"Partitions.Show ~\". Like in \n\"InstallFiles.Tool\" this will open a new \"Partitions.Text\" \nviewer with content like\n\n```\nDisk: Diskette0, GetSize: no media, removable\n\nDisk: IDE0, 99MB, VBOX HARDDISK\nIDE0#00       99MB  --- (Whole disk)\nIDE0#01       99MB   76 * Native Oberon, Aos\n\nDisk: IDE2, GetSize: no media, removable, VBOX CD-ROM\n```\n\nUsing your right mouse button select \"IDE0#01\" then in the\n\"Configure.Tool\" viewer middle click the blue text\n\"Partitions.Activate ↑\". The \"System.Log\" viewer should\nshow\n\n```\nIDE0#01 already active\n```\n\nWe don't have a partition to deactivate so we can skip the last\nstep of option 2. This is a good place to \"eject\" our \nfloppy disk \"Oberon0.Dsk\" before we \"System.Reboot\".\n\nTo eject the disk click on \"Oberon0.Dsk\" in the VirtualBox\nmanager panel. The should then change the text to \"Empty\".\n\nFinally we're ready to move to the last step in \"Configure.Tool\".\nScroll down and find \"System.Reboot\". \nMiddle click on the blue text \"System.Reboot\". At this point\nthe virtualbox should reboot from the virtual hard drive.\nThis reboot will take a little longer than the floppy boot\nand the screen size of the virtualbox will be large based on the\nsettings you picked early. You have a minimal working Oberon\nSystem 3. Now to install some more programs and flesh the system out.\n\nInstall some programs\n---------------------\n\nFirst we need to get the zip files provided in \nNativeOberon_2.3.7.tar.gz on to the hard drive.  \nHistorically these were done via 1.44 MB floppy disks.\nWe're going to make it easier. Native Oberon 2.3.7 can\nread an ISO formatted CD-ROM. \n\nMaking our virtual CD-ROM\n-------------------------\n\nUnder Ubuntu 20.04.2 LTS machine creating a ISO image\nis one command. Below is I am going to create an ISO \nimage of the directory \"NativeOberon-2.3.7\"\nand save the image as \"NativeOberon-2.3.7.iso\".\n\n```shell\n    mkisofs -J --iso-level 3 \\\n        -o NativeOberon-2.3.7.iso NativeOberon-2.3.7\n```\n\nThe `-J` says to use the Joliet extensions, the `--iso-level`\nsets the level of ISO support, in this case to 3. See\nthe manpage for `mkisofs` for details.\n\nOn macOS this involves two commands. First use\nthe \"Disk Utility\" to create an image of the folder\nwhere you unpacked NativeOberon_2.3.7.tar.gz.\nThis will result in a \".dmg\" or disk image file common\non macOS.  Next we need to convert this to an ISO\nformatted image file.  For that we use a command line\nmacOS tool called `hdiutil` to convert the disk\nimage to an ISO format. In the process you will create\nthe ISO file but it will have the extension of \".cdr\".\nYou can rename (i.e. mv) that file so it has a \".iso\"\nextension. This is suitable to mount in VirtualBox's \nvirtual CD-ROM drive.\n\n```shell\n    hdiutil convert NativeOberon-2.3.7.dmg -format UDTO -o NativeOberon-2.3.7.iso\n    mv NativeOberon-2.3.7.iso.cdr NativeOberon-2.3.7.iso\n```\n\nGo to the VirtualBox 6.1 management panel and mount the\nISO image file you created. Now we're ready to return\nto our Native Oberon virtual machine.\n\nInstalling from an ISO CD-ROM\n-----------------------------\n\nI suggest create the following as it's own tool text.\nBut if you want you can also type in the commands and\nexecute one by one.\n\n```\nThese are the instructions from installing the Native\nOberon 2.3.7 zip archive files. Steps:\n\n1. See what the CD-ROM mount point by reviewing the partitions\n\n    Paritions.Show ~\n\nOn my virtual machine the second disk is IDE2 and that\nis where we'll find the CD-ROM.\n\n2. Mount the ISO image as CD\n\n    FileSystem.Mount CD ISOFS IDE2 ~\n\n3. Check to see what files are on the CD-ROM\n\n    System.Directory CD:* ~\n\n4. Copy the files from the CD-ROM to the harddisk\n\n    System.CopyFiles\n        CD:Apps1.zip => Apps1.zip\n        CD:Apps2.zip => Apps2.zip\n        CD:Docu.zip => Docu.zip\n        CD:Gadgets.zip => Gadgets.zip\n        CD:Pr3Fonts.zip => Pr3Fonts.zip\n        CD:Source1.zip => Source1.zip\n        CD:Source2.zip => Source2.zip\n        CD:Source3.zip => Source3.zip\n        ~\n\n5. Unzip all our archives using the ZipTool.\n\n    ZipTool.ExtractAll \\o \\p SYS:\n        Gadgets.zip Docu.zip Apps1.zip Apps2.zip\n        Pr3Fonts.zip Pr6Fonts.zip\n        Source1.zip Source2.zip Source3.zip\n        ~\n\n```\n\nYou should now have a full installed Native Oberon 2.3.7\nsystem running under VirtualBox 6.1. Enjoy your explorations.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-03-17",
        "keywords": [
          "FreeDOS 1.2",
          "VirtualBox 6.1",
          "Oberon System 3",
          "Native Oberon"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "ETH Oberon System 3 on VirtualBox 6.1"
      },
      "url": "posts/2021/03/17/NativeOberon-VirtualBox.json"
    },
    {
      "content": "\n\nCombing Oberon-07 with C using Obc-3\n===================================\n\nBy R. S. Doiel, 2021-06-14\n\nThis post explores integrating C code with an Oberon-07 module use\nMike Spivey's Obc-3 Oberon Compiler.  Last year I wrote a similar post\nfor Karl Landström's [OBNC](/blog/2020/05/01/Combining-Oberon-and-C.html).\nThis goal of this post is to document how I created a version of Karl's\nExtension Library that would work with Mike's Obc-3 compiler.\nIf you want to take a shortcut you can see the results on GitHub\nin my [obc-3-libext](https://github.com/rsdoiel/obc-3-libext) repository.\n\nFrom my time with OBNC I've come to rely on three modules from Karl's\nextension library. When trying to port some of my code to use with\nMike's compiler. That's where I ran into a problem with that dependency.\nKarl's modules aren't available. I needed an [extArgs](http://miasap.se/obnc/obncdoc/ext/extArgs.def.html),\nan [extEnv](http://miasap.se/obnc/obncdoc/ext/extEnv.def.html) and\n[extConvert](http://miasap.se/obnc/obncdoc/ext/extConvert.def.html).\n\nMike's own modules that ship with Obc-3 cover allot of common ground\nwith Karl's. They are organized differently. The trivial solution is\nto implement wrapping modules using Mike's modules for implementation.\nThat takes case of extArgs and extEnv.\n\nThe module extConvert is in a another category. Mike's `Conv` module is\nsignificantly minimalist. To solve that case I've create C code to perform\nthe needed tasks based on Karl's examples and used Mike's share library\ncompilation instructions to make it available inside his run time.\n\nBackground material\n-------------------\n\n- [Obc-3 website](https://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler)\n    - [Installing Obc-3](https://spivey.oriel.ox.ac.uk/corner/Installing_OBC_release_3.1)\n    - [Adding primitives to Obc-3](https://spivey.oriel.ox.ac.uk/corner/How_to_add_primitives_to_OBC), this is how you extend Obc-3 with C\n    - [Obc-3.1 Manual](https://spivey.oriel.ox.ac.uk/wiki/images-corner/c/ce/Obcman-3.1.pdf)\n- [Obc-3 at GitHub](http://github.com/Spivoxity/obc-3)\n\n\nDifferences: OBNC and Obc-3\n---------------------------\n\nThe OBNC compiler written by Karl takes the approach of translating\nOberon-07 code to C and then calling the C tool chain to convert that\ninto a   executable.  Karl's compiler is largely written in C\nwith some parts written in Oberon.\n\nMike's takes a different approach. His compiler uses a run time JIT\nand is written mostly in OCaml with some C parts and shell scripting.\nWhen you compile an Oberon program (either Oberon-2 or Oberon-07) using\nMike's compiler you get a bunch of \"*.k\" files that the object code\nfor Mike's thunder virtual machine and JIT.  This can in turn be used\nto create a executable.\n\nFor implementing Oberon procedures in C Karl's expects an empty\nprocedure body. e.g.\n\n```oberon\nPROCEDURE DoMyThing();\nBEGIN\nEND DoMyThing;\n```\n\nWhile Mike has added a \"IS\" phrase to the procedure signature to\nindicate what the C implementation is known as. There is no procedure\nbody in Mike's implementation and the parameters need to map\ndirectly into a C data type.\n\n```oberon\nPROCEDURE DoMyThing() IS \"do_my_thing\";\n```\n\nOf course both compilers have completely different command line options\nand when you're integrating C shared libraries in Mike's you need to\ncall your local CC (e.g. GCC, clang) to create a share library file.\nMike has extended Oberon-07 SYSTEM to include `SYSTEM.LOADLIB()` which\ntakes a string containing the path to the compiler shared library.\n\nIn Karl's own Oberon-07 modules he uses the `.obn` file extension but\nalso accepts `.Mod`.  In Mike's he uses `.m` and also accepts `.Mod`.\nIn this article I will be using `.m` as that simplified the recipe\nof building and integrating the shared C libraries.\n\n\nSimilarities of OBNC and Obc-3\n------------------------------\n\nBoth compilers provide for compiling Oberon-07 code, Mike's requires\nthe `-07` option to be used to switch from Oberon-2. Both offer the\nability to extend reach into the host POSIX system by wrapping\nC shared libraries. Both run on a wide variety of POSIX systems and\nyou can read the source code at your leisure. This last bit is\nimportant.\n\nArgs, extArgs and extEnv.\n-------------------------\n\nMike provides two features in his Args module. The first is access\nto the command line arguments of the compiled program. The\nsecond feature is to provide access to the host environment variables.\nIn Karl's implementation he separates Mikes `Args.GetEvn()` into\na module called `extEnv`. Here's Mike's module definition looks like ---\n\n```oberon\nDEFINITION Args;\n\nVAR argc* : INTEGER; (* this is equavilent to extArgs.count *)\n\nPROCEDURE GetArg*(n: INTEGER; VAR s: ARRAY OF CHAR);\n\nPROCEDURE GetEnv*(name: ARRAY OF CHAR; VAR s: ARRAY OF CHAR);\n\nEND Args.\n```\n\nMy implementation of Karl's `extArgs` needs to look like ---\n\n```oberon\nDEFINITION extArgs;\n\nVAR count*: INTEGER; (* this is the same as Args.argc *)\n\nPROCEDURE Get*(n: INTEGER; VAR arg: ARRAY OF CHAR; VAR res: INTEGER);\n\nEND extArgs.\n```\n\nThis leaves us with a very simple module mimicking Karl's.\n\n```oberon\nMODULE extArgs;\n\nIMPORT Args;\n\nVAR\n  count*: INTEGER;\n\nPROCEDURE Get*(n: INTEGER; VAR arg: ARRAY OF CHAR; VAR res: INTEGER);\nBEGIN\n  Args.GetArg(n + 1, arg);  res := 0;\nEND Get;\n\nBEGIN\n  count := Args.argc - 1;\nEND extArgs.\n```\n\nNOTE: In Mike's approach the zero-th arg is the program name.\nIn Karl's the zero-th arg is the first argument after the program\nname. To get Karl's behavior with Mike's `GetArg()` I need to\nadjust the offsets.\n\nSo far so good. How about implementing Karl's `extEnv`?\n\nWe've already seen Mike's Args so he doesn't have a matching\ndefinition.  Karl's `extEnv` looks like\n\n```oberon\nDEFINITION extEnv;\n\nPROCEDURE Get*(name: ARRAY OF CHAR; VAR value: ARRAY OF CHAR; VAR res: INTEGER);\n\nEND extEnv.\n```\n\nAnd again a simple mapping of features and you have\n\n```oberon\nMODULE extEnv;\n\nIMPORT Args, Strings;\n\nPROCEDURE Get*(name : ARRAY OF CHAR; VAR value : ARRAY OF CHAR; VAR res : INTEGER);\n  VAR i, l1, l2 : INTEGER; val : ARRAY 512 OF CHAR;\nBEGIN\n  l1 := LEN(value) - 1; (* Allow for trailing 0X *)\n  Args.GetEnv(name, val);\n  l2 := Strings.Length(val);\n  IF l2 <= l1 THEN\n    res := 0;\n  ELSE\n    res := l2 - l1;\n  END;\n  i := 0;\n  WHILE (i < l2) & (val[i] # 0X) DO\n      value[i] := val[i];\n      INC(i);\n  END;\n  value[i] := 0X;\nEND Get;\n\nEND extEnv.\n```\n\nextConvert requires more work\n-----------------------------\n\nMike provides a module called `Conv.m` for converting numbers\nto strings.  It is a little minimal for my current purpose.\nThat is easy enough to solve as Mike, like Karl provides a means\nof extending Oberon code with C.  That means I need to write\n`extConvert` as both `extConvert.m` (the Oberon-07 part) and\n`extConvert.c` (the C part).\n\nHere's Karl's definition\n\n```oberon\nDEFINITION extConvert;\n\nPROCEDURE IntToString*(i: INTEGER; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n\nPROCEDURE RealToString*(x: REAL; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n\nPROCEDURE StringToInt*(s: ARRAY OF CHAR; VAR i: INTEGER; VAR done: BOOLEAN);\n\nPROCEDURE StringToReal*(s: ARRAY OF CHAR; VAR x: REAL; VAR done: BOOLEAN);\n\nEND extConvert.\n```\n\nI have implement my `extConvert` as a hybrid of Oberon-07 and calls\nto a C shared library I will create called `extConvert.c`.\n\nThe Oberon file (i.e. extConvert.m)\n\n```oberon\nMODULE extConvert;\n\nIMPORT SYSTEM;\n\nPROCEDURE IntToString*(i: INTEGER; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n  VAR l : INTEGER;\nBEGIN\n  l := LEN(s); done := TRUE;\n  IntToString0(i, s, l);\nEND IntToString;\n\nPROCEDURE IntToString0(i : INTEGER; VAR s : ARRAY OF CHAR; l : INTEGER) IS \"conv_int_to_string\";\n\nPROCEDURE RealToString*(x: REAL; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n  VAR l : INTEGER;\nBEGIN\n  l := LEN(s);\n  RealToString0(x, s, l);\nEND RealToString;\n\nPROCEDURE RealToString0(x: REAL; VAR s: ARRAY OF CHAR; l : INTEGER) IS \"conv_real_to_string\";\n\nPROCEDURE StringToInt*(s: ARRAY OF CHAR; VAR i: INTEGER; VAR done: BOOLEAN);\nBEGIN\n  done := TRUE;\n  StringToInt0(s, i);\nEND StringToInt;\n\nPROCEDURE StringToInt0(s : ARRAY OF CHAR; VAR i : INTEGER) IS \"conv_string_to_int\";\n\nPROCEDURE StringToReal*(s: ARRAY OF CHAR; VAR x: REAL; VAR done: BOOLEAN);\nBEGIN\n  done := TRUE;\n  StringToReal0(s, x);\nEND StringToReal;\n\nPROCEDURE StringToReal0(s: ARRAY OF CHAR; VAR x : REAL) IS \"conv_string_to_real\";\n\nBEGIN\n  SYSTEM.LOADLIB(\"./extConvert.so\");\nEND extConvert.\n```\n\nIf you review Mike's module code you'll see I have followed a similar pattern. Before calling out to C I take care of what house keeping I can in Oberon, then I call a \"0\" version of the function implemented in C. The C implementation are not exported only the wrapping Oberon procedures are.\n\nNotice how the initialization block calls `SYSTEM.LOADLIB(\"./extConvert.so\");` this loads the C shared library so that the Oberon module can call out it it.\n\nThe C code in `extConvert.c` looks very traditional without the macros\nyou'd see in OBNC's implementation. Here's what the C code look like.\n\n```C\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid conv_int_to_string(int i, char *s, int l) {\n  snprintf(s, l, \"%d\", i);\n}\n\nvoid conv_real_to_string(float r, char *s, int l) {\n  snprintf(s, l, \"%f\", r);\n}\n\nvoid conv_real_to_exp_string(float r, char *s, int l) {\n  snprintf(s, l, \"%e\", r);\n}\n\nvoid conv_string_to_int(char *s, int *i) {\n    *i = atoi(s);\n}\n\nvoid conv_string_to_real(char *s, float *r) {\n    *r = atof(s);\n}\n```\n\nThe dance to compile the module and C shared library is very different\nbetween OBNC and Obc-3.  With Obc-3 we compile and skip linking\nthe wrapping Oberon module `extConvert.m`. We compile using CC\nour C shared library. We can then put it all together to test\neverything out in `ConvertTest.m`.\n\n```shell\nobc -07 -c extConvert.m\ngcc -fPIC -shared extConvert.c -o extConvert.so\n```\n\nOur test code program looks like.\n\n```oberon\nMODULE ConvertTest;\n\nIMPORT T := Tests, Convert := extConvert;\n\nVAR ts : T.TestSet;\n\nPROCEDURE TestIntConvs() : BOOLEAN;\n  VAR test, ok : BOOLEAN;\n      expectI, gotI : INTEGER;\n      expectS, gotS : ARRAY 128 OF CHAR;\nBEGIN test := TRUE;\n  gotS[0] := 0X; gotI := 0;\n  expectI := 101;\n  expectS := \"101\";\n\n  Convert.StringToInt(expectS, gotI, ok);\n  T.ExpectedBool(TRUE, ok, \"StringToInt('101', gotI, ok) true\", test);\n  T.ExpectedInt(expectI, gotI, \"StringToInt('101', gotI, ok)\", test);\n\n  Convert.IntToString(expectI, gotS, ok);\n  T.ExpectedBool(TRUE, ok, \"IntToString(101, gotS, ok) true\", test);\n  T.ExpectedString(expectS, gotS, \"IntToString(101, gotS, ok)\", test);\n\n  RETURN test\nEND TestIntConvs;\n\nPROCEDURE TestRealConvs() : BOOLEAN;\n  VAR test, ok : BOOLEAN;\n      expectR, gotR : REAL;\n      expectS, gotS : ARRAY 128 OF CHAR;\nBEGIN test := TRUE;\n  gotR := 0.0; gotS[0] := 0X;\n  expectR := 3.1459;\n  expectS := \"3.145900\";\n\n  Convert.StringToReal(expectS, gotR, ok);\n  T.ExpectedBool(TRUE, ok, \"StringToReal('3.1459', gotR, ok) true\", test);\n  T.ExpectedReal(expectR, gotR, \"StringToReal('3.1459', gotR, ok)\", test);\n\n  Convert.RealToString(expectR, gotS, ok);\n  T.ExpectedBool(TRUE, ok, \"RealToString(3.1459, gotS; ok) true\", test);\n  T.ExpectedString(expectS, gotS, \"RealToString(3.1459, gotS, ok)\", test);\n\n  RETURN test\nEND TestRealConvs;\n\nBEGIN\n  T.Init(ts, \"extConvert\");\n  T.Add(ts, TestIntConvs);\n  T.Add(ts, TestRealConvs);\n  ASSERT(T.Run(ts));\nEND ConvertTest.\n```\n\nWe compile and run our test program use the following commands\n(NOTE: Using Obc-3 you list all the dependent modules to possibly\nbe compiled one the command line along with your program module).\n\n```shell\nobc -07 -o converttest extConvert.m Tests.m ConvertTest.m\n./converttest\n```\n\nSource code for these modules is available on GitHub at\n[github.com/rsdoiel/obc-3-libest](https://github.com/rsdoiel/obc-3-libext)\n\n\nNext & Previous\n---------------\n\n- Next [Revisiting Files](../../11/22/Revisiting-Files.html)\n- Previous [Beyond Oakwood, Modules and Aliases](../../05/16/Beyond-Oakwood-Modules-and-Aliases.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-06-14",
        "keywords": [
          "Oberon",
          "Obc-3",
          "C",
          "extArgs",
          "extEnv",
          "extConvert"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 19,
        "title": "Combining Oberon-07 with C using Obc-3"
      },
      "url": "posts/2021/06/14/Combining-Oberon-07-with-C-using-Obc-3.json"
    },
    {
      "content": "\nNotes on setting up a Mid-2010 Mac Mini\n=======================================\n\nBy R. S. Doiel, 2021-12-18\n\nI acquired a Mid 2010 Mac Mini. It was in good condition but lacked an OS on the hard drive.  I used a previously purchased copy of Mac OS X Snow Leopard to get an OS up and running on the bare hardware. Then it was a longer effort to get the machine into a state with the software I wanted to use on it. My goal was Mac OS X High Sierra, Xcode 10.1 and Mac Ports. The process was straight forward but very time consuming but I think worth it.  I wound up with a nice machine for experimenting with and writing blog posts.\n\nThe setup process was as follows:\n\n1. Install macOS Snow Leopard on the bare disk of the Mac Mini\n2. Install macOS El Capitan on the Mac Mini after manually downloading it from Apple's support site\n3. Run updates indicated by El Capitan\n4. Install macOS High Sierra on the Mac Mini after manually downloading it from the Apple's support site\n5. Run updates indicated by High Sierra \n6. Manually download and install Xcode 10.1 command line tools \n7. Check and run some updates again\n8. Finally install Mac Ports\n\nThe OS installs took about 45 minutes to 90 minutes each. Installing Xcode took about 45 minutes to an hour. Installing Mac Ports was fast as was installing software via Mac Ports.\n\nReference material\n------------------\n\n- Apple support pages that I found helpful\n    - [How to get old versions of macOS](https://support.apple.com/en-us/HT211683)\n    - [How to create a bootable installer for macOS](https://support.apple.com/en-us/HT201372)\n    - [macOS High Sierra - Technical Specifications](https://support.apple.com/kb/SP765?locale=en_US)\n- Wikipedia page on [Xcode](https://en.wikipedia.org/wiki/Xcode) is how I sorta out what version of Xcode I needed to install\n- Links to old macOS and Xcode\n    - Download [Mac OS X El El Capitan](http://updates-http.cdn-apple.com/2019/cert/061-41424-20191024-218af9ec-cf50-4516-9011-228c78eda3d2/InstallMacOSX.dmg)\n    - Download [Mac OX X High Sierra](https://apps.apple.com/us/app/macos-high-sierra/id1246284741?mt=12)\n    - Download [Xcode 10.1](https://developer.apple.com/download/all/?q=xcode), Scroll down the list until you want it.\n        - [Command Line Tools (macOS 10.13) for Xcode 10.1](https://download.developer.apple.com/Developer_Tools/Command_Line_Tools_macOS_10.13_for_Xcode_10.1/Command_Line_Tools_macOS_10.13_for_Xcode_10.1.dmg)\n        - NOTE: There are two version available, you want the version for macOS 10.13 (High Sierra) NOT Mac OS 10.14.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-12-18",
        "keywords": [
          "macOS",
          "High Sierra",
          "Mac Mini"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Notes on setting up a Mid-2010 Mac Mini"
      },
      "url": "posts/2021/12/18/Notes-on-setting-up-a-2010-Mac-Mini.json"
    },
    {
      "content": "\n\n# Go, Bleve and Library oriented software\n\nBy R. S. Doiel, 2018-02-19\n(updated: 2018-02-22)\n\nIn 2016, Stephen Davison, asked me, \"Why use Go and Blevesearch for\nour library projects?\" After our conversation I wrote up some notes so\nI would remember. It is now 2018 and I am revising these notes. I\nthink our choice paid off.  What follows is the current state of my\nreflection on the background, rational, concerns, and risk mitigation\nstrategies so far for using [Go](https://golang.org) and\n[Blevesearch](https://blevesearch.com) for Caltech Library projects.\n\n## Background\n\nI first came across Go a few years back when it was announced as an\nOpen Source project by Google at an Google I/O event (2012). The\noriginal Go authors were Robert Griesemer, Rob Pike, and Ken\nThompson. What I remember from that presentation was Go was a rather\nconsistent language with the features you need but little else.  Go\ndeveloped at Google as a response to high development costs for C/C++\nand Java in addition to challenges with performance and slow\ncompilation times.  As a language I would put Go between C/C++ and\nJava. It comes the ease of writing and reading you find in languages\nlike Python. Syntax is firmly in the C/C++ family but heavily\nsimplified. Like Java it provides many modern features including rich basic\ndata structures and garbage collection. It has a very complete standard\nlibrary and provides very good tooling.  This makes it easy to\ngenerate code level documentation, format code, test, efficiently profile, \nand debug.\n\nOften programming languages develop around a specific set of needs.\nThis is true for Go. Given the Google origin it should not be\nsurprising to find that Go's primary strengths are working with \nstructured data, I/O and concurrency. The rich standard\nlibrary is organized around a package concept. These include packages\nsupporting network protocols, file and socket I/O as well as various\nencoding and compression scheme. It has particularly strong support\nfor XML, JSON, CSV formatted data out of the box. It has a template\nlibrary for working with plain text formats as well as generating safe\nHTML. You can browse Go's standard library https://golang.org/pkg/.\n\nAn additional feature is Go's consistency. Go code that compiles under\nversion 1.0 still compiles under 1.10. Even before 1.0 code changes\nthat were breaking came with tooling to automatically updates existing\ncode.  Running code is a strong element of Go's evolution.\n\nGo is unsurprising and has even been called boring.  This turns out to\nbe a strength when building sustainable projects in a small team.\n\n\n## Why do I write Go?\n\nFor me Go is a good way to write web services, assemble websites,\ncreate search appliances and write command line (cli) utilities. When\na shell script becomes unwieldy Go is often what I turn to.  Go is\nwell suited to building tools as well as systems.  Go based command\nline tools are very easy to orchestrate with shell and Python.\n\nGo runs on all the platforms I actively use - Windows, Mac OS X, Linux\non both Intel and ARM (e.g. Raspberry Pi, Pine64). It has experimental\nsupport for Android and iOS.  I've used a tool called\n[GopherJS](http://gopherjs.org) to write web browser applications that\ntransform my command line tools into web tools with a friendlier user\ninterface (see our [BibTeX Tools](https://caltechlibrary.github.io/bibtex/webapp/)).\n\nGo supports cross compiling out of the box. This means a production\nsystem running on AWS, Google's compute engine or Microsoft's Azure\ncan be compiled from Windows, Mac OS or even a Raspberry Pi!\nDeployment is a matter of copying the (self contained) compiled binary\nonto the production system. This contrasts with other\nplatforms like Perl, PHP, Python, NodeJS and Ruby where you need to\ninstall not only your application code but all dependencies. While\ninterpretive languages retain an advantage of having a REPL, Go\nbased programs have advantages of fast compile times and easy deployment.\n\nIn many of the projects I've written in Go I've only required a few\n(if any) 3rd party libraries (packages in Go's nomenclature). This is\nquite a bit different from my experience with Perl, PHP, Python,\nNodeJS and Ruby. This is in large part a legacy of having grown up at\nGoogle before become an open source project. While the Go standard\npackages are very good there is a rich ecosystem for 3rd party\npackages for specialized needs. I've found I tend to rely only on a\nfew of them. The one I've used the most is\n[Bleve](http://blevesearch.com).\n\nBleve is a Go package for building search engines. When I originally\ncame across Bleve (around 2014), it was described as \"Lucene lite\". \n\"Lucene lite\" was an apt description, but I find it easier\nto use than Lucene. When I first used Bleve I embedded its\nfunctionality into the tools I used to process data and present web\nservices. It did not have much in the way of stand alone command line\ntooling.  Today I increasingly think of Bleve as \"Elastic Search\nlite\". It ships with a set of command line tools that include support\nfor building Bleve's indexes.  My current practice is to only embed the search\nportion of the packages. I can use the Bleve command line for the\nrest.  In 2018, Bleve is being actively developed, has a small vibrant\ncommunity and is used by [Couchbase](https://couchbase.com), a well\nestablished NoSQL player.\n\n\n## Who is using Go?\n\nMany companies use Go. The short list includes\nGoogle, Amazon, Netflix, Dropbox, Box, eBay, Pearsons and even\nWalmart and Microsoft. This came to my attention at developer conferences\nback in 2014.  People from many of these companies started\npresenting at conferences on pilot projects that had been successful\nand moved to production. Part of what drove adoption was the ease\nof development in Go along with good system performance. I also think\nthere was a growing disenchantment with alternatives like C++, C sharp\nand Java as well as the weight of the LAMP, Tomcat, and OpenStack.\n\nHighly visible Go based projects include\n\n+ [Docker](http://docker.org) and [Rocket](http://www.docker.com) - Containerization for running process in the cloud\n+ [Kubernettes](http://kubernetes.io/) and [Terraform](https://www.terraform.io/) - Container orchestration systems\n+ [Hugo](http://hugo.io) - the fast/popular static website generator, an alternative to Jekyll, for those who want speed\n+ [Caddy](https://caddyserver.com/) - a Go based web server trying to unseat Apache/NGinX focusing on easy of use plus speed\n+ [IPFS](http://ipfs.io) - a cutting edge distributed storage system based on block chains\n\n\n### Who is using Blevesearch?\n\nHere's some larger projects using Bleve.\n\n+ [Couchbase](http://www.couchbase.com), a NoSQL database platform are replacing Lucene with Bleve.  Currently the creator of Bleve works for them.\n+ [Hugo](http://hugo.io) can integrate with Bleve for search and index generation\n+ [Caddy](https://caddyserver.com/) integrates with Bleve to provide an embedded search capability\n\n\n## Managing risks\n\nIn 2014 Go was moving from bleeding to leading edge. Serious capital\nwas behind its adoption and it stopped being an exotic conference\nitem. In 2014 Bleve was definitely bleeding edge. By late 2015 and early\n2016 the program level API stabilized. People were piloting projects\nwith it. This included our small group at Caltech Library. In 2015\nnon-English language support appeared followed by a growing list\nof non-European languages in 2016. By mid 2016 we started to see \nmissing features like alternative sorting added. While Bleve isn't\nyet 1.0 (Feb. 2018) it is reliable. The primary challenge for the Bleve\nproject is documentation targeting the novice and non-Programmer users.\nBleve has proven effective as an indexing and search platform for \narchival, library, and data repository content.\n\nAdopting new software comes with risk. We have mitigated this in two ways.\n\n1. Identify alternative technology (a plan B)\n2. Architect our systems for easy decomposition and re-composition\n\nIn the case of Go, packages can be compiled to a C-Shared\nlibrary. This allows us to share working Go packages with languages\nlike Python, R, and PHP. We have included shared Go/Python modules\non our current road map for projects.\n\nFor Blevesearch the two alternatives are Solr and Elastic\nSearch. Both are well known, documented, and solid.  The costs would be\nrecommitting to a Java stack and its resource requirements. We have\nalready identified what we want to index and that could be converted\nto either platform if needed.  If we stick with Go but dropped \nBlevesearch we would swap out the Bleve specific code for Go packages \nsupporting Solr and Elastic Search.\n\n\nThe greatest risk in adopting Go for library and archive projects was \nknowledge transfer. We addressed this \nby knowledge sharing and insuring the Go codebase can \nbe used via command line programs.  Additionally \nwe are adding support for Go based Python modules.\nTraining also is available in the form of books, websites and\nonline courses ([lynda.com](https://www.lynda.com/Go-tutorials/Up-Running-Go/412378-2.html) offers a \"Up Running Go\" course).\n\n\n## What are the benefits?\n\nFor library and archives software we have found Go's benefits include\nimproved back end systems performance at a lower cost, ease of development, \nease of deployment, a rich standard library focused on the types of things \nneeded in library and archival software.  Go plays nice with\nother systems (e.g. I create an API based service in Go that can easily\nbe consumed by a web browser running JavaScript or Perl/PHP/Python\ncode running under LAMP). In the library and archives setting Go \ncan become a high performance duck tape. We get the performance and \nreliability of C/Java type systems with code simplicity \nsimilar to Python.\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2018, R. S. Doiel",
        "date": "2018-02-19",
        "keywords": [
          "Golang",
          "Bleve",
          "search"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Go, Bleve and Library oriented software"
      },
      "url": "posts/2018/02/19/go-bleve-and-libraries.json"
    },
    {
      "content": "\n\n# Go based Python modules\n\nBy R. S. Doiel, 2018-02-24\n\nThe problem: I have written a number of Go packages at work.\nMy colleagues know Python and I'd like them to be able to use the\npackages without resorting to system calls from Python to the\ncommand line implementations. The solution is create a C-Shared\nlibrary from my Go packages, using Go's _C_ package and combine it\nwith Python's _ctypes_ package.  What follows is a series of \nsimple recipes I used to understand the details of how that worked.\n\n\n## Example 1, libtwice.go and twice.py\n\nMany of the the examples I've come across on the web start by \nshowing how to run a simple math operation on the Go side with\nnumeric values traveling round trip via the C shared library layer. \nIt is a good place to start as you only need to consider type \nconversion between both Python's runtime and Go's runtime.  It \nprovides a simple illustration of how the Go *C* package, Python's\n*ctypes* module and the toolchain work together.\n\nIn this example we have a function in Go called \"twice\" it takes\na single integer, doubles it and returns the new value.  On\nthe Go side we create a _libtwice.go_ file with an empty `main()` \nfunction.  Notice that we also import the *C* package and use \na comment decoration to indicate the function we are exporting\n(see https://github.com/golang/go/wiki/cgo and \nhttps://golang.org/cmd/cgo/\nfor full story about Go's _C_ package and _cgo_).\nPart of the what _cgo_ and the *C* package does is use the \ncomment decoration to build the signatures for the function calls\nin the shared C library.  The Go toolchain does all the heavy \nlifting in making a *C* shared library based on comment \ndirectives like \"//export\". We don't need much for our twice\nfunction.\n\n```Go\n    package main\n    \n    import (\n    \t\"C\"\n    )\n    \n    //export twice\n    func twice(i int) int {\n    \treturn i * 2\n    }\n    \n    func main() {}\n```\n\nOn the python side we need to wrap our calls to our shared library\nbringing them into the Python runtime in a useful and idiomatically\nPython way. Python provides a few ways of doing this. In my examples\nI am using the *ctypes* package.  _twice.py_ looks like this--\n\n```python\n    import ctypes\n    import os\n    \n    # Set our shared library's name\n    lib_name='libtwice'\n    \n    # Figure out shared library extension\n    uname = os.uname().sysname\n    ext = '.so'\n    if uname == 'Darwin':\n        ext = '.dylib'\n    if uname == 'Windows':\n        ext = '.dll'\n    \n    # Find our shared library and load it\n    dir_path = os.path.dirname(os.path.realpath(__file__))\n    lib = ctypes.cdll.LoadLibrary(os.path.join(dir_path, lib_name+ext))\n    \n    # Setup our Go functions to be nicely wrapped\n    go_twice = lib.twice\n    go_twice.argtypes = [ctypes.c_int]\n    go_twice.restype = ctypes.c_int\n    \n    # Now write our Python idiomatic function\n    def twice(i):\n        return go_twice(ctypes.c_int(i))\n    \n    # We run this test code if with: python3 twice.py\n    if __name__ == '__main__':\n        print(\"Twice of 2 is\", twice(2))\n```\n\nNotice the amount of lifting Python's *ctypes* does for us. It provides\nfor converting C based types to their Python counter parts. Indeed the\nadditional Python source here is focused around using that functionality\nto create a simple Python function called twice. This pattern of \nbringing in a low level version of our desired function and then \npresenting in a Pythonic one is common in more complex C based Python\nmodules.  In general we need *ctypes* to access and wrapping our \nshared library. The *os* module is used so we can find our C \nshared library based on the naming conventions of our host OS. \nFor simplicity I've kept the shared library (e.g. _libtwice.so_ \nunder Linux) in the same directory as the python module \ncode _twice.py_.\n\nThe build command for Linux looks like---\n\n```shell\n    go build -buildmode=c-shared -o libtwice.so libtwice.go\n```\n\nUnder Windows it would look like---\n\n```shell\n    go build -buildmode=c-shared -o libtwice.dll libtwice.go\n```\n\nand Mac OS X---\n\n```shell\n    go build -buildmode=c-shared -o libtwice.dynlib libtwice.go\n```\n\nYou can test the Python module with---\n\n```shell\n    python3 twice.py\n```\n\nNotice the filename choices. I could have called the Go shared\nlibrary anything as long as it wasn't called `twice.so`, `twice.dll`\nor `twice.dylib`. This constraint is to avoid a module name collision\nin Python.  If we had a Python script named `twice_test.py` and \nimport `twice.py` then Python needs to make a distinction between\n`twice.py` and our shared library. If you use a Python package\napproach to wrapping the shared library you would have other options\nfor voiding name collision.\n\nHere is an example of `twice_test.py` to make sure out import is\nworking.\n\n```python\n    import twice\n    print(\"Twice 3\", twice.twice(3))\n```\n\nExample 1 is our base recipe. The next examples focus on handling\nother data types but follow the same pattern.\n\n\n## Example 2, libsayhi.go and sayhi.py\n\nI found working with strings a little more nuanced. Go's concept of\nstrings are oriented to utf-8. Python has its own concept of strings \nand encoding.  Both need to pass through the C layer which assumes \nstrings are a char pointer pointing at contiguous memory ending \nin a null. The *sayhi* recipe is focused on moving a string from \nPython, to C, to Go (a one way trip this time). The example uses \nGo's *fmt* package to display the string. \n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"fmt\"\n    )\n    \n    //export say_hi\n    func say_hi(msg *C.char) {\n    \tfmt.Println(C.GoString(msg))\n    }\n    \n    func main() { }\n```\n\nThe Go source is similar to our first recipe but our Python modules\nneeds to use *ctypes* to get you Python string into shape to be\nunpacked by Go.\n\n```python\n   import ctypes\n   import os\n   \n   # Set the name of our shared library\n   lib_name = 'libsayhi'\n\n   # Figure out shared library extension\n   uname = os.uname().sysname\n   ext = '.so'\n   if uname == 'Darwin':\n       ext = '.dylib'\n   if uname == 'Windows':\n       ext = '.dll'\n   \n   # Find our shared library and load it\n   dir_path = os.path.dirname(os.path.realpath(__file__))\n   lib = ctypes.cdll.LoadLibrary(os.path.join(dir_path, lib_name+ext))\n   \n   # Setup our Go functions to be nicely wrapped\n   go_say_hi = lib.say_hi\n   go_say_hi.argtypes = [ctypes.c_char_p]\n   # NOTE: we don't have a return type defined here, the message is \n   # displayed from Go\n   \n   # Now write our Python idiomatic function\n   def say_hi(txt):\n       return go_say_hi(ctypes.c_char_p(txt.encode('utf8')))\n   \n   if __name__ == '__main__':\n       say_hi('Hello!')\n```\n\nPutting things together (if you are using Windows or Mac OS X\nyou'll adjust name output name, `libsayhi.so`, to match the\nfilename extension suitable for your operating system).\n\n```bash\n    go build -buildmode=c-shared -o libsayhi.so libsayhi.go\n```\n\nand testing.\n\n```bash\n    python3 sayhi.py\n```\n\n\n## Example 3, libhelloworld.go and helloworld.py\n\nIn this example we send a Python string to Go (which expects utf-8)\nbuild our \"hello world\" message and then send it back to Python\n(which needs to do additional conversion and decoding).\n\nLike in previous examples the Go side remains very simple. The heavy\nlifting is done by the *C* package and the comment `//export`. We\nare using `C.GoString()` and `C.CString()` to flip between our native\nGo and C datatypes.\n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"fmt\"\n    )\n    \n    //export helloworld\n    func helloworld(name *C.char) *C.char {\n    \ttxt := fmt.Sprintf(\"Hello %s\", C.GoString(name))\n    \treturn C.CString(txt)\n    }\n    \n    func main() { }\n```\n\nIn the python code below the conversion process is much more detailed.\nPython isn't explicitly utf-8 like Go. Plus we're sending our Python \nstring via C's char arrays (or pointer to chars). Finally when we \ncomeback from Go via C we have to put things back in order for Python. \nOf particular note is checking how the byte arrays work then \nencoding/decoding everything as needed. We also explicitly set the result \ntype from our Go version of the helloworld function.\n\n```python\n    import ctypes\n    import os\n    \n    # Set the name of our shared library\n    lib_name = 'libhelloworld'\n\n    # Figure out shared library extension\n    uname = os.uname().sysname\n    ext = '.so'\n    if uname == 'Darwin':\n        ext = '.dylib'\n    if uname == 'Windows':\n        ext = '.dll'\n    \n    # Find our shared library and load it\n    dir_path = os.path.dirname(os.path.realpath(__file__))\n    lib = ctypes.cdll.LoadLibrary(os.path.join(dir_path, lib_name+ext))\n    \n    # Setup our Go functions to be nicely wrapped\n    go_helloworld = lib.helloworld\n    go_helloworld.argtypes = [ctypes.c_char_p]\n    go_helloworld.restype = ctypes.c_char_p\n    \n    # Now write our Python idiomatic function\n    def helloworld(txt):\n        value = go_helloworld(ctypes.c_char_p(txt.encode('utf8')))\n        if not isinstance(value, bytes):\n            value = value.encode('utf-8')\n        return value.decode()\n    \n    \n    if __name__ == '__main__':\n        import sys\n        if len(sys.argv) > 1:\n            print(helloworld(sys.argv[1]))\n        else:\n            print(helloworld('World'))\n```\n\nThe build recipe remains the same as the two previous examples.\n\n```bash\n    go build -buildmode=c-shared -o libhelloworld.so libhelloworld.go\n```\n\nHere are two variations to test.\n\n```bash\n     python3 helloworld.py\n     python3 helloworld.py Jane\n```\n\n\n## Example 4, libjsonpretty.go and jsonpretty.py\n\nIn this example we send JSON encode text to the Go package,\nunpack it in Go's runtime and repack it using the `MarshalIndent()`\nfunction in Go's JSON package before sending it back as Python\nin string form.  You'll see the same encode/decode patterns as \nin our *helloworld* example.\n\nGo code\n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"encoding/json\"\n    \t\"fmt\"\n    \t\"log\"\n    )\n    \n    //export jsonpretty\n    func jsonpretty(rawSrc *C.char) *C.char {\n    \tdata := new(map[string]interface{})\n    \terr := json.Unmarshal([]byte(C.GoString(rawSrc)), &data)\n    \tif err != nil {\n    \t\tlog.Printf(\"%s\", err)\n    \t\treturn C.CString(\"\")\n    \t}\n    \tsrc, err := json.MarshalIndent(data, \"\", \"    \")\n    \tif err != nil {\n    \t\tlog.Printf(\"%s\", err)\n    \t\treturn C.CString(\"\")\n    \t}\n    \ttxt := fmt.Sprintf(\"%s\", src)\n    \treturn C.CString(txt)\n    }\n    \n    func main() {}\n```\n\nPython code\n\n```python\n    import ctypes\n    import os\n    import json\n    \n    # Set the name of our shared library\n    lib_name = 'libjsonpretty'\n\n    # Figure out shared library extension\n    uname = os.uname().sysname\n    ext = '.so'\n    if uname == 'Darwin':\n        ext = '.dylib'\n    if uname == 'Windows':\n        ext = '.dll'\n\n    dir_path = os.path.dirname(os.path.realpath(__file__))\n    lib = ctypes.cdll.LoadLibrary(os.path.join(dir_path, lib_name+ext))\n    \n    go_jsonpretty = lib.jsonpretty\n    go_jsonpretty.argtypes = [ctypes.c_char_p]\n    go_jsonpretty.restype = ctypes.c_char_p\n    \n    def jsonpretty(txt):\n        value = go_jsonpretty(ctypes.c_char_p(txt.encode('utf8')))\n        if not isinstance(value, bytes):\n            value = value.encode('utf-8')\n        return value.decode()\n    \n    if __name__ == '__main__':\n        src = '''\n    {\"name\":\"fred\",\"age\":25,\"height\":75,\"units\":\"inch\",\"weight\":\"239\"}\n    '''\n        value = jsonpretty(src)\n        print(\"Pretty print\")\n        print(value)\n        print(\"Decode into dict\")\n        o = json.loads(value)\n        print(o)\n```\n\nBuild command\n\n```shell\n    go build -buildmode=c-shared -o libjsonpretty.so libjsonpretty.go\n```\n\nAs before you can run your tests with `python3 jsonpretty.py`.\n\nIn closing I would like to note that to use these examples you Python3\nwill need to be able to find the module and shared library. For \nsimplicity I've put all the code in the same directory. If your Python\ncode is spread across multiple directories you'll need to make some \nadjustments.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2018, R. S. Doiel",
        "date": "2018-02-24",
        "keywords": [
          "Golang",
          "Python",
          "shared libraries"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Go based Python modules"
      },
      "url": "posts/2018/02/24/go-based-python-modules.json"
    },
    {
      "content": "\n\n# Review: Software Tools in Pascal\n\nBy R. S. Doiel, 2018-07-22\n(updated: 2018-07-22, 1:39 pm, PDT)\n\n\nThis book is by Brian W. Kernighan and P. J. Plauger. It is an\nexample of the type of books I find I re-read and want in my\npersonal library. The book covers software construction through \na series of programs written in pascal. It is about how these \nprograms work, how to approach problems and write sound software.\nI was surprised I did not know about this book when I was browsing \nthe [Open Library](https://openlibrary.org) this weekend.  While \nPascal was a popular in the 1980's it has faded for most people in the \nearly 21st century.  This review maybe a small bit of nostalgia. \nOn the other hand I suspect \n[\"Software Tools in Pascal\"](https://openlibrary.org/books/OL4258115M/Software_tools_in_Pascal)\nis one of the short list of computer books that will remain useful\nover the long run.\n\n\n## What's covered\n\nThe book is organized around specific programs and their implementations.\nThe implementations provided are simple and straight forward. Each\nsection is followed by a set of \"exercises\" that extend the ideas\nshown in the section. In this way you could derive the modern equivalent\nof these tools.\n\nThe topics you build tools for in the text are\nfilters, files, sorting, text patterns, editing, formatting, \nand macro processing.\n\nIf you want to follow the book along in Pascal then I think Free Pascal\navailable in many Debian distributions including Raspbian on the Raspberry\nPi is a good choice.  Likewise Wirth's Pascal is easy enough to port\nto other languages and indeed this would be a useful exercise when I\nre-read the book the next time.\n\nThe book presents a very nice set of text oriented programs to explore\nprogramming or re-connect with your programming roots.\n\n## Read the book\n\n<iframe width=\"165\" frameBorder=\"0\" height=\"400\" src=\"https://openlibrary.org/books/OL4258115M/Software_tools_in_Pascal/widget\"></iframe>\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2018, R. S. Doiel",
        "date": "2018-07-22",
        "keywords": [
          "Pascal",
          "programming",
          "book review"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Review: Software Tools in Pascal"
      },
      "url": "posts/2018/07/22/software-tools-in-pascal.json"
    },
    {
      "content": "\n\n# Accessing Go from Julia\n\nBy R. S. Doiel, 2018-03-11\n\nThe problem: I've started exploring Julia and I would like to leverage existing\ncode I've written in Go. Essentially this is a revisit to the problem in my\nlast post [Go based Python Modules](https://rsdoiel.github.io/blog/2018/02/24/go-based-python-modules.html) \nbut with the language pairing of Go and Julia.\n\n\n## Example 1, libtwice.go, libtwice.jl and libtwice_test.jl\n\nIn out first example we send an integer value from\nJulia to Go and back via a C shared library (written in Go). While Julia doesn't\nrequire type declarations I will be using those for clarity. Like in my previous post\nI think this implementation this is a good starting point to see how Julia interacts with\nC shared libraries. Like before I will present our Go code, an explanation \nfollowed by the Julia code and commentary.\n\nOn the Go side we create a _libtwice.go_ file with an empty `main()` \nfunction.  Notice that we also import the *C* package and use \na comment decoration to indicate the function we are exporting\n(see https://github.com/golang/go/wiki/cgo and \nhttps://golang.org/cmd/cgo/\nfor full story about Go's _C_ package and _cgo_).\nPart of the what _cgo_ and the *C* package does is use the \ncomment decoration to build the signatures for the function calls\nin the shared C library.  The Go toolchain does all the heavy \nlifting in making a *C* shared library based on comment \ndirectives like \"//export\". We don't need much for our twice\nfunction.\n\n```Go\n    package main\n    \n    import (\n    \t\"C\"\n    )\n    \n    //export twice\n    func twice(i int) int {\n    \treturn i * 2\n    }\n    \n    func main() {}\n```\n\nLike in our previous Python implementation we need to build the C shared\nlibrary before using it from Julia. Here are some example Go build commands\nfor Linux, Windows and Mac OS X. You only need to run the one that applies\nto your operating system.\n\n```shell\n    go build -buildmode=c-shared -o libtwice.so libtwice.go\n    go build -buildmode=c-shared -o libtwice.dll libtwice.go\n    go build -buildmode=c-shared -o libtwice.dynlib libtwice.go\n```\n\nUnlike the Python implementation our Julia code will be split into two files. _libtwice.jl_ will\nhold our module definition and _libtwice_test.jl_ will hold our test code. In the\ncase of _libtwice.jl_ we will access the C exported function via a function named *ccall*. \nJulia doesn't require a separate module to be imported in order to access a C shared library.\nThat makes our module much simpler. We still need to be mindful of type conversion.  Both \nGo and Julia provide for rich data types and structs.  But between Go and Julia we have C \nand C's basic type system.  On the Julia side *ccall* and Julia's type system help us\nmanaging C's limitations.\n\nHere's the Julia module we'll call _libtwice.jl_.\n\n```Julia\n    module libtwice\n            \n    # We write our Julia idiomatic function\n    function twice(i::Integer)\n        ccall((:twice, \"./libtwice\"), Int32, (Int32,), i)\n    end\n\n    end\n```\n\nWe're will put the test code in a file named _libtwice\\_test.jl_. Since this isn't\nan establish \"Package\" in Julia we will use Julia's *include* statement to get bring the\ncode in then use an *import* statement to bring the module into our current name space.\n\n```Julia\n    include(\"libtwice.jl\")\n    import libtwice\n    # We run this test code for libtwice.jl\n    println(\"Twice of 2 is \", libtwice.twice(2))\n```\n\nOur test code can be run with\n\n```shell\n    julia libtwice_test.jl\n```\n\nNotice the amount of lifting that Julia's *ccall* does. The Julia code is much more compact\nas a result of not having to map values in a variable declaration. We still have the challenges \nthat Julia and Go both support richer types than C. In a practical case we should consider \nthe over head of running to two runtimes (Go's and Julia's) as well as whether or not \nimplementing as a shared library even makes sense. But if you want to leverage existing \nGo based code this approach can be useful.\n\nExample 1 is our base recipe. The next examples focus on handling\nother data types but follow the same pattern.\n\n\n## Example 2, libsayhi.go, libsayhi.jl and libsayhi_test.jl\n\nLike Python, passing strings passing to or from Julia and Go is nuanced. Go is expecting \nUTF-8 strings. Julia also supports UTF-8 but C still looks at strings as a pointer to an\naddress space that ends in a null value. Fortunately in Julia the *ccall* function combined with\nJulia's rich type system gives us straight forward ways to map those value. \nGo code remains unchanged from our Python example in the previous post. \nIn this example we use Go's *fmt* package to display the string. In the next example\nwe will round trip our string message.\n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"fmt\"\n    )\n    \n    //export say_hi\n    func say_hi(msg *C.char) {\n    \tfmt.Println(C.GoString(msg))\n    }\n    \n    func main() { }\n```\n\nThe Go source is the similar to our first recipe. No change from our\nprevious posts' Python example. It will need to be compiled to create our\nC shared library just as before. Run the go build line that applies to\nyour operating system (i.e., Linux, Windows and Mac OS X).\n\n```shell\n    go build -buildmode=c-shared -o libsayhi.so libsayhi.go\n    go build -buildmode=c-shared -o libsayhi.dll libsayhi.go\n    go build -buildmode=c-shared -o libsayhi.dylib libsayhi.go\n```\n\nOur Julia module looks like this.\n\n```julia\n    module libsayhi\n\n    # Now write our Julia idiomatic function using *ccall* to access the shared library\n    function say_hi(txt::AbstractString)\n        ccall((:say_hi, \"./libsayhi\"), Int32, (Cstring,), txt)\n    end\n\n    end\n```\n\nThis code is much more compact than our Python implementation.\n\nOur test code looks like\n\n```julia\n    include(\"./libsayhi.jl\")\n    import libsayhi\n    libsayhi.say_hi(\"Hello again!\")\n```\n\nWe run our tests with\n\n```shell\n    julia libsayhi_test.jl\n```\n\n\n## Example 3, libhelloworld.go and librhelloworld.cl and libhelloworld_test.jl\n\nIn this example we send a string round trip between Julia and Go. \nMost of the boiler plate we say in Python is gone due to Julia's type system. In\naddition to using Julia's *ccall* we'll add a *convert* and *bytestring* function calls\nto bring our __Cstring__ back to a __UTF8String__ in Julia.\n\nThe Go implementation remains unchanged from our previous Go/Python implementation. \nThe heavy lifting is done by the *C* package and the comment \n`//export`. We are using `C.GoString()` and `C.CString()` to flip between \nour native\nGo and C datatypes.\n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"fmt\"\n    )\n    \n    //export helloworld\n    func helloworld(name *C.char) *C.char {\n    \ttxt := fmt.Sprintf(\"Hello %s\", C.GoString(name))\n    \treturn C.CString(txt)\n    }\n    \n    func main() { }\n```\n\nAs always we must build our C shared library from the Go code. Below is\nthe go build commands for Linux, Windows and Mac OS X. Pick the line that\napplies to your operating system to build the C shared library.\n\n```shell\n    go build -buildmode=c-shared -o libhelloworld.so libhelloworld.go\n    go build -buildmode=c-shared -o libhelloworld.dll libhelloworld.go\n    go build -buildmode=c-shared -o libhelloworld.dylib libhelloworld.go\n```\n\nIn our Julia, _libhelloworld.jl_, the heavy lifting of type conversion\nhappens in Julia's type system and in the *ccall* function call. Additionally we need\nto handle the conversion from __Cstring__ Julian type to __UTF8String__ explicitly\nin our return value via a functions named *convert* and *bytestring*.\n\n```julia\n    module libhelloworld\n\n    # Now write our Julia idiomatic function\n    function helloworld(txt::AbstractString)\n        value = ccall((:helloworld, \"./libhelloworld\"), Cstring, (Cstring,), txt)\n        convert(UTF8String, bytestring(value))\n    end\n\n    end\n```\n\nOur test code looks similar to our Python test implementation.\n\n```julia\n    include(\"libhelloworld.jl\")\n    import libhelloworld\n \n    if length(ARGS) > 0\n        println(libhelloworld.helloworld(join(ARGS, \" \")))\n    else\n        println(libhelloworld.helloworld(\"World\"))\n    end\n```\n\nAs before we see the Julia code is much more compact than Python's.\n\n\n## Example 4, libjsonpretty.go, libjsonpretty.jl and libjsonpretty_test.jl\n\nIn this example we send JSON encode text to the Go package,\nunpack it in Go's runtime and repack it using the `MarshalIndent()`\nfunction in Go's JSON package before sending it back to Julia\nin C string form.  You'll see the same encode/decode patterns as \nin our *libhelloworld* example.\n\nGo code\n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"encoding/json\"\n    \t\"fmt\"\n    \t\"log\"\n    )\n    \n    //export jsonpretty\n    func jsonpretty(rawSrc *C.char) *C.char {\n    \tdata := new(map[string]interface{})\n    \terr := json.Unmarshal([]byte(C.GoString(rawSrc)), &data)\n    \tif err != nil {\n    \t\tlog.Printf(\"%s\", err)\n    \t\treturn C.CString(\"\")\n    \t}\n    \tsrc, err := json.MarshalIndent(data, \"\", \"    \")\n    \tif err != nil {\n    \t\tlog.Printf(\"%s\", err)\n    \t\treturn C.CString(\"\")\n    \t}\n    \ttxt := fmt.Sprintf(\"%s\", src)\n    \treturn C.CString(txt)\n    }\n    \n    func main() {}\n```\n\nBuild commands for Linux, Windows and Mac OS X are as before, pick the one that matches\nyour operating system.\n\n```shell\n    go build -buildmode=c-shared -o libjsonpretty.so libjsonpretty.go\n    go build -buildmode=c-shared -o libjsonpretty.dll libjsonpretty.go\n    go build -buildmode=c-shared -o libjsonpretty.dylib libjsonpretty.go\n```\n\nOur Julia module code\n\n```Julia\n    module libjsonpretty\n\n    # Now write our Julia idiomatic function\n    function jsonpretty(txt::AbstractString)\n        value = ccall((:jsonpretty, \"./libjsonpretty\"), Cstring, (Cstring,), txt)\n        convert(UTF8String, bytestring(value))\n    end\n    \n    end\n```\n\nOur Julia test code\n\n```Julia\n    include(\"./libjsonpretty.jl\")\n    import libjsonpretty\n\n    src = \"\"\"{\"name\":\"fred\",\"age\":25,\"height\":75,\"units\":\"inch\",\"weight\":\"239\"}\"\"\"\n    println(\"Our origin JSON src\", src)\n    value = libjsonpretty.jsonpretty(src)\n    println(\"And out pretty version\\n\", value)\n```\n\nAs before you can run your tests with `julia libjsonpretty_test.jl`.\n\nIn closing I would like to note that to use these examples I am assuming your\nJulia code is in the same directory as your shared C library. Julia, like Python3,\nhas a feature rich module and Package system. If you are creating a serious Julia\nproject then you need to be familiar with how Julia's package and module system works\nand place your code and shared libraries appropriately.\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2018, R. S. Doiel",
        "date": "2018-03-11",
        "keywords": [
          "Golang",
          "Julia",
          "shared libraries"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Accessing Go from Julia"
      },
      "url": "posts/2018/03/11/accessing-go-from-julia.json"
    }
  ]
}