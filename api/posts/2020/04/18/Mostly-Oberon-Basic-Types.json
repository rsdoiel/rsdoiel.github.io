{
  "content": "\n\nOberon Basic Types\n==================\n\n\nBy R. S. Doiel, 2020-04-18\n\nThis is the third post in the [Mostly Oberon](../11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit wholes I inevitably fell into.\n\n## Simple Types\n\nOberon is a small systems language. It provides a useful but \nlimited umber of basic types. These can be be\nthought of as simple types mapping to specific memory locations\nand more complex types composed of multiple memory locations.\n\nNOTE: __basic types__, INTEGER, REAL, CHAR, ARRAY, RECORD and POINTER TO\n\n### INTEGER\n\nIntegers are easiest to be thought of as whole numbers. They may be\npositive numbers or negative numbers. Declaring an integer\nvariable `i` it would look something like\n\n\n~~~{.oberon}\n\n    VAR i : INTEGER;\n\n~~~\n\n\nSetting `i`'s value to seven would look like\n\n\n~~~{.oberon}\n\n    i := 7;\n\n~~~\n\n\n\n### REAL\n\nReal holds real numbers. Real numbers contain a fractional \ncomponent. We normally notate them with\na decimal value e.g. \"0.01\". Like integers they can also be \npositive or negative.\n\nDeclaring a real number variable `a` would look like\n\n\n~~~{.oberon}\n\n    VAR a : REAL;\n\n~~~\n\n\nSetting the value of `a` to seven and one tenth (7.1) would\nlook like\n\n\n~~~{.oberon}\n\n    a := 7.1;\n\n~~~\n\n\n### CHAR\n\nA CHAR is a single ASCII character. Oberon, unlike more recent\nlanguages like Go or Julia, predates the wide adoption of UTF-8.\nThe character is represented in memory as one 8 bit byte.\nIf you need to work with an extended character set then you need\nto either re-encode the values into ASCII. At this time[^now] there\nis no standard way of handling None ASCII character systems natively.\nIf you need to work directly with an encoding such as UTF-8 you'll\nneed to develop your own modules and procedures for handily their\nencoding, decoding and other operations.\n\nDeclaring a CHAR variable `c` would look like\n\n\n~~~{.oberon}\n\n    VAR c: CHAR;\n\n~~~\n\n\nSetting the value of `c` to capital Z would look like\n\n\n~~~{.oberon}\n\n    c := \"Z\";\n\n~~~\n\n\nNote: Oberon expects double quotes to notate a character.\n\n\n### More complex types\n\nThe simplest types would prove problematic when addressing\nmore complex data representations if Oberon lacked two three built-in\ntypes - ARRAY, RECORD and POINTER TO. \n\n### ARRAY\n\nAn array is a sequence of memory locations which contain a common\ntype.  In Oberon-07 all arrays have to have a known link. This is\nbecause the Oberon compiler is responsible for pre-allocating\nmemory when the program starts to hold the array.  While this\nseems restrictive our next data type, RECORD, lets us move\ninto more dynamic memory structures.  Pre-allocating the array\nsize also has the advantage that we can re-use those locations\neasily in a type safe manner.\n\nDeclaring a variable \"name\" as an array of twelve characters would \nlook like and declaring a variable \"scores\" as an array of ten\nintegers would look like\n\n\n~~~{.oberon}\n\n    VAR \n      name : ARRAY 24 OF CHAR;\n      scores : ARRAY 10 OF INTEGER;\n\n~~~\n\n\nThe length of the array immediately follows the keyword \"ARRAY\" and\nthe \"OF CHAR\" or \"OF INTEGER\" phrases describes the types that can be \ncontained in the array. In the \"OF CHAR\" the type is \"CHAR\" the \n\"OF INTEGER\" is the type \"INTEGER\". \n\nSetting an array value can be done using an index. In this example\nthe zero-th element (first element of the array) is set to the value\n102. \n\n\n~~~{.oberon}\n\n    scores[0] := 102;\n\n~~~\n\n\nIn the case of CHAR arrays the whole array can be set in a simple \nsingle assignment.\n\n\n~~~{.oberon}\n\n    name := \"Ada Lovelace\";\n\n~~~\n\n\nTwo key points of arrays in Oberon are a known length and a single \ntype of data associated with them. Arrays can have more than\none dimension but the cells of the array most contain the same type.\n\nNOTE: __type safety__, Type safe means the compiler or run time verify that the data stored at that location conforms to the program defined, this is helpful in maintaining program correctness.\n\n### RECORD\n\nThe RECORD is Oberon's secret sauce. The record is used to\ncreate new types if data representations. It extend Oberon's basic \ntypes creating structured data representation. In this example we'll \ncreate a record that holds an game's name, a list of three player names \nand a list of three scores. We'll call this record type \n\"TopThreeScoreboard\". \n\n\n~~~{.oberon}\n\n    TYPE\n      TopThreeScoreboard = RECORD\n        gameName : ARRAY 24 OF CHAR;\n        playerNames : ARRAY 3, 24 OF CHAR;\n        scores : ARRAY 3 OF INTEGER\n      END;\n\n~~~\n\n\nNow that we have describe a record of type \"TopThreeScoreboard\" we can\ndeclare it with our \"VAR\" statement.\n\n\n~~~{.oberon}\n\n    VAR\n      scoreboard : TopThreeScoreboard;\n\n~~~\n\n\nSetting the element values in a record uses a dot notation\nand if those elements are themselves. In this case we'll set\nthe game name to \"Basketball\", the three players are\n\"Ada Lovelace\", \"Blaise Pascal\", and \"John McCarthy\", with\nthe scores 102, 101, 100.\n\n\n~~~{.oberon}\n\n   scoreboard.gameName := \"Basketball\";\n   scoreboard.playerNames[0] := \"Ada Lovelace\";\n   scoreboard.scores[0] := 102;\n   scoreboard.playerNames[1] := \"Blaise Pascal\";\n   scoreboard.scores[0] := 101;\n   scoreboard.playerNames[2] := \"John McCarthy\";\n   scoreboard.scores[0] := 100;\n\n~~~\n\n\nRecords are also used to create dynamic memory structures such as lists, trees and maps (see note on \"AD\").  The dynamic nature of records is achieved with\nour next type \"POINTER TO\".\n\nNOTE: __AD__, Prof. Wirth wrote an excellent text on [Algorithms and Data structures](https://inf.ethz.ch/personal/wirth/AD.pdf) available in PDF format.\n### POINTER TO\n\nOberon is a type safe language. To keep things safe in a type\nsafe language you need to place constraints around random\nmemory access. Memory can be thought of a list of locations and\nwe can go to those locations if we know their address. A pointer\nin most languages holds an address. Oberon has pointers but they\nmust point at specific data types. So like array you have to indicate\nthe type of the thing you are pointing at in a declaration. \nE.g. `VAR a : POINTER TO CHAR;` would declare a variable 'a' \nthat points to a memory location that holds a CHAR. The more common \ncase is we use \"POINTER TO\" in records to create dynamic data \nstructures such as linked lists.\n\nHere's a simple data structure representing a dynamic list\nof characters. Let's call it a DString and we will implement\nit using a single link list. The list can be implemented by\ndefining a RECORD type that holds a single character and a pointer\nto the next record. We can then also define a pointer to this type\nof record.  If there is no next character record\nwe assume we're at the end of the string.\n\n\n~~~{.oberon}\n\n    TYPE\n      DStringDesc = RECORD\n        value : CHAR;\n        next : POINTER TO DStringDesc\n      END;\n\n      DString : POINTER TO DStringDesc;\n\n~~~\n\n\nRECORD types are permitted to use recursive definition so our \n\"next\" value is itself a type \"DStringDesc\".  Declaring a \nDString variable is as easy as declaring our scoreboard type variable.\n\n\n~~~{.oberon}\n\n  VAR\n    VAR s : DString;\n\n~~~\n\n\nSetting our DString is a little trickier. This is where\nOberon's procedures come into play. We can pass our variable \"s\"\nof type DString to a procedure to build out our DString from an simple\narray of characters. Note \"s\" is declared as a \"VAR\" parameter\nin our procedure heading. Our `SetDString` will also need to handle\ncreating new elements in our dynamic string. That is what Oberon's\nbuilt-in `NEW()` procedure does. It allocates new memory for our\nlist of records.\n\n\n~~~{.oberon}\n\n    PROCEDURE SetDString(VAR s : DString; buf : ARRAY OF CHAR);\n        VAR i : INTEGER; cur, tmp : DString;\n    BEGIN\n      (* Handle the case where s is NIL *)\n      IF s = NIL THEN\n        NEW(s);\n        s.value := 0X;\n        s.next := NIL;\n      END;\n      cur := s;\n      i := 0;\n      (* check to see if we are at end of string or array *)\n      WHILE (buf[i] # 0X) & (i < LEN(buf)) DO\n        cur.value := buf[i];\n        IF cur.next = NIL THEN\n          NEW(tmp);\n          tmp.value := 0X;\n          tmp.next := NIL;\n          cur.next := tmp;\n        END;\n        (* Advance our current pointer to the next element *)\n        cur := cur.next;\n        i := i + 1;\n      END;\n    END SetDString;\n\n~~~\n\n\nWe can move our string back into a fixed length array of char\nwith a similar procedure.\n\n\n~~~{.oberon}\n\n    PROCEDURE DStringToCharArray(s : DString; VAR buf : ARRAY OF CHAR);\n      VAR cur : DString; i, l : INTEGER;\n    BEGIN\n      l := LEN(buf);\n      i := 0;\n      cur := s;\n      WHILE (i < l) & (cur # NIL) DO\n        buf[i] := cur.value; \n        cur := cur.next;\n        i := i + 1;\n      END;\n      (* Zero out the rest of the string. *)\n      WHILE (i < l) DO\n        buf[i] := 0X;\n        i := i + 1;\n      END;\n    END DStringToCharArray;\n\n~~~\n\n\nAt this stage we have the basics of data organization. Modules\nallow us to group operations and data into cohesive focused units.\nProcedures allow us to define consistent ways of interacting with\nout data, and types singularly and collectively allow us to structure\ndata in a way that is useful to solving problems.\n\n## Putting it all together\n\nHere is a [module demoing our basic type](BasicTypeDemo.Mod). In it\nwe can define procedures to demo our assignments, display their results\nall called from inside the module's initialization block.\n\n\n~~~{.oberon}\n\n    MODULE BasicTypeDemo;\n      IMPORT Out;\n    \n      (* These are our custom data types definitions. *)\n      TYPE\n          TopThreeScoreboard = RECORD\n            gameName : ARRAY 24 OF CHAR;\n            playerNames : ARRAY 3, 24 OF CHAR;\n            scores : ARRAY 3 OF INTEGER\n          END;\n    \n          DStringDesc = RECORD\n            value : CHAR;\n            next : POINTER TO DStringDesc\n          END;\n    \n          DString = POINTER TO DStringDesc;\n    \n      (* Here are our private variables. *)\n      VAR \n        i : INTEGER;\n        a : REAL;\n        c: CHAR;\n        name : ARRAY 24 OF CHAR;\n        scores : ARRAY 10 OF INTEGER;\n        scoreboard : TopThreeScoreboard;\n        s : DString;\n    \n    \n      PROCEDURE SimpleTypes;\n      BEGIN\n        i := 7;\n        a := 7.1;\n        c := \"Z\";\n      END SimpleTypes;\n    \n      PROCEDURE DisplaySimpleTypes;\n      BEGIN\n        Out.String(\" i: \");Out.Int(i, 1);Out.Ln;\n        Out.String(\" a: \");Out.Real(a, 1);Out.Ln;\n        Out.String(\" c: \");Out.Char(c);Out.Ln;\n      END DisplaySimpleTypes;\n    \n    \n      PROCEDURE MoreComplexTypes;\n      BEGIN\n        scores[0] := 102;\n        name := \"Ada Lovelace\";\n        scoreboard.gameName := \"Basketball\";\n        scoreboard.playerNames[0] := \"Ada Lovelace\";\n        scoreboard.scores[0] := 102;\n        scoreboard.playerNames[1] := \"Blaise Pascal\";\n        scoreboard.scores[0] := 101;\n        scoreboard.playerNames[2] := \"John McCarthy\";\n        scoreboard.scores[0] := 100;\n      END MoreComplexTypes;\n    \n      PROCEDURE DisplayMoreComplexTypes;\n        VAR i : INTEGER;\n      BEGIN\n        i := 0;\n        Out.String(\" Game: \");Out.String(scoreboard.gameName);Out.Ln;\n        WHILE i < LEN(scoreboard.playerNames) DO\n          Out.String(\"    player, score: \");\n          Out.String(scoreboard.playerNames[i]);Out.String(\", \");\n          Out.Int(scoreboard.scores[i], 1);\n          Out.Ln;\n          i := i + 1;\n        END;\n      END DisplayMoreComplexTypes;\n    \n      PROCEDURE SetDString(VAR s : DString; buf : ARRAY OF CHAR);\n          VAR i : INTEGER; cur, tmp : DString;\n      BEGIN\n        (* Handle the case where s is NIL *)\n        IF s = NIL THEN\n          NEW(s);\n          s.value := 0X;\n          s.next := NIL;\n        END;\n        cur := s;\n        i := 0;\n        (* check to see if we are at end of string or array *)\n        WHILE (buf[i] # 0X) & (i < LEN(buf)) DO\n          cur.value := buf[i];\n          IF cur.next = NIL THEN\n            NEW(tmp);\n            tmp.value := 0X;\n            tmp.next := NIL;\n            cur.next := tmp;\n          END;\n          cur := cur.next;\n          i := i + 1;\n        END;\n      END SetDString;\n    \n      PROCEDURE DStringToCharArray(s : DString; VAR buf : ARRAY OF CHAR);\n        VAR cur : DString; i, l : INTEGER;\n      BEGIN\n        l := LEN(buf);\n        i := 0;\n        cur := s;\n        WHILE (i < l) & (cur # NIL) DO\n          buf[i] := cur.value; \n          cur := cur.next;\n          i := i + 1;\n        END;\n        (* Zero out the rest of the string. *)\n        WHILE (i < l) DO\n          buf[i] := 0X;\n          i := i + 1;\n        END;\n      END DStringToCharArray;\n    \n    BEGIN\n      SimpleTypes;\n      DisplaySimpleTypes;\n      MoreComplexTypes;\n      DisplayMoreComplexTypes;\n      (* Demo our dynamic string *)\n      Out.String(\"Copy the phrase 'Hello World!' into our dynamic string\");Out.Ln;\n      SetDString(s, \"Hello World!\");\n      Out.String(\"Copy the value of String s into 'name' our array of char\");Out.Ln;\n      DStringToCharArray(s, name);\n      Out.String(\"Display 'name' our array of char: \");Out.String(name);Out.Ln;\n    END BasicTypeDemo.\n\n~~~\n\n\n## Reading through the code\n\nThere are some nuances in Oberon syntax that can creep up on you.\nFirst while most statements end in a semi-colon there are noticeable\nexceptions. Look at the record statements in particular.  The last\nelement of your record before the `END` does not have a semicolon.\nIn that way it is a little like a `RETURN` value in a function\nlike procedure.\n\nIn creating our `DString` data structure the Oberon idiom is to first\ncreate a description record, `DStringDesc` then create a pointer to\nthe descriptive type, i.e. `DString`. This is a very common\nidiom in building out complex data structures. A good place to learn\nabout implementing algorithms and data structures in Oberon-07 is \nProf. Wirth's 2004 edition of [Algorithms and Data Structures](https://inf.ethz.ch/personal/wirth/AD.pdf) which\nis available from his personal website in PDF.\n\n\n### Next and Previous\n\n+ Next [Loops and Conditions](../19/Mostly-Oberon-Loops-and-Conditions.html)\n+ Previous [Modules and Procedures](../12/Mostly-Oberon-Modules.html)\n\n",
  "data": {
    "author": "rsdoiel@gmail.com (R. S. Doiel)",
    "copyright": "copyright (c) 2020, R. S. Doiel",
    "date": "2020-04-18",
    "keywords": [
      "Oberon",
      "programming"
    ],
    "license": "https://creativecommons.org/licenses/by-sa/4.0/",
    "number": 3,
    "series": "Mostly Oberon",
    "title": "Oberon Basic Types"
  }
}