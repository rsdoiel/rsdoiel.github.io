{
  "content": "\n\n# Portable Oberon-07\n\n## using OBNC modules\n\nThis is the eleventh post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series.\nMostly Oberon documents my exploration of the Oberon Language, Oberon System and the\nvarious rabbit holes I will inevitably fall into.\n\n## Working with standard input\n\nBy R. S. Doiel, 2020-08-15 (updated: 2020-09-05)\n\nKarl Landström's [OBNC](https://miasap.se/obnc/), Oberon-07 compiler,\ncomes with an Oberon-2 inspired set of modules\ndescribed in the Oakwood Guidelines as well as\nseveral very useful additions making Oberon-07 suitable for\nwriting programs in a POSIX environment.  We're going to\nexplore three of the Oakwood modules and two of Karl's own additions\nin this post as we create a program called [SlowCat](SlowCat.Mod).\nI am using the term \"portable\" to mean the code can be compiled\nusing OBNC on macOS, Linux, and Raspberry Pi OS and Windows 10\n(i.e. wherever OBNC is available). The Oakwood Guideline modules\nfocus on portability between an Oberon System and other systems.\nI'll leave that discussion along with\n[POW!](http://www.fim.uni-linz.ac.at/pow/pow.htm)\nto the end of this post.\n\n\n### SlowCat\n\nRecently while I was reviewing logs at work using [cat](https://en.wikipedia.org/wiki/Cat_(Unix)), [grep](https://en.wikipedia.org/wiki/Grep)\nand [more](https://en.wikipedia.org/wiki/More_(command)) it\nstruck me that it would have been nice if **cat**\nor **more** came with a time delay so you could use them like a\nteleprompter. This would let you casually watch the file scroll\nby while still being able to read the lines. The program we'll build\nin this post is \"SlowCat\" which accepts a command line parameter\nindicating the delay in seconds between display each line read from\nstandard input.\n\n## Working with Standard Input and Output\n\nThe Oakwood guides for Oberon-2 describe two modules\nparticularly useful for working with standard input and output.\nThey are appropriately called `In` and `Out`. On many Oberon Systems\nthese have been implemented such that your code could run under Unix\nor Oberon System with a simple re-compile.  We've used `Out` in our\nfirst program of this series, \"Hello World\". It provides a means to\nwrite Oberon system base types to standard out.  We've used `In`\na few times too. But `In` is worth diving into a bit more.\n\n### In\n\nThe [In](http://miasap.se/obnc/obncdoc/basic/In.def.html) module provides\na mirror of inputs to those of [Out](http://miasap.se/obnc/obncdoc/basic/Out.def.html). In Karl's implementation we are interested in one procedure\nand module status variable.\n\n+ `In.Line(VAR line: ARRAY OF CHAR)` : Read a sequence of characters from standard input from the current position in the file to the end of line.\n+ `In.Done` : Is a status Boolean variable, if the last call to an procedure in `In` was successful then it is set TRUE, otherwise FALSE (e.g. we're at the end of a file)\n\nWe use Karl's `In.Line()` extension to the standard `In` implementation\nbefore and will do so again as it simplifies our code and keeps things\neasily readable.\n\nThere is one nuance with `In.Done` that is easy to get tripped up on.\n`In.Done` indicates if the last operation was successful.\nSo if you're using `In.Line()` then `In.Done`\nshould be true if reading the line was successful. If you hit the end of\nthe file then `In.Done` should be false.  When you write your loop\nthis can be counter intuitive.  Here is a example of testing `In.Done`\nwith a repeat until loop.\n\n\n~~~\n\n    REPEAT\n      In.Line(text);\n      IF In.Done THEN\n        Out.String(text);Out.Ln();\n      END;\n    UNTIL In.Done = FALSE;\n\n~~~\n\n\nSo when you read this it is easy to think of `In.Done` as you're\ndone reading from standard input but actually we need to check for `FALSE`.\nThe value of `In.Done` was indicating the success of reading our line.\nAn unsuccessful line read, meaning we're at the end of the file, sets\n`In.Done` to false!\n\n### Out\n\nAs mention `Out` provides our output functions. We'll be using\ntwo procedure from `Out`, namely `Out.String()` and `Out.Ln()`.\nWe've seen both before.\n\n### Input\n\n\"SlowCat\" needs to calculate how often to write a line of\ntext to standard output with the `Out` module.  To do that\nI need access to the system's current time.  There isn't an\nOakwood module for time. There is a module called \n`Input` which provides a \"Time\" procedure. As a result\nI need to import `Input` as well as `In` even though\nI am using `In` to manage reading the file I am processing\nwith \"SlowCat\".\n\nA note about Karl's implementation.  `Input` is an Oakwood\nmodule that provides access to three system resources -- \nmouse, keyboard and system time.  Karl \nprovides two versions `Input` and `Input0`, the first is\nintended to be used with the `XYPlane` module for graphical\napplications the second for POSIX shell based application.\nIn the case of \"SlowCat\" I've stuck with `Input` as I am \nonly accessing time I've stuck with `Input` to make my source\ncode more portable if you're using another Oberon compiler.\n\n## Working with Karl's extensions\n\nThis is the part of my code which is not portable\nbetween compiler implementations and with Oberon Systems.\nKarl provides a number of extension module wrapping various\nPOSIX calls.  We are going to use two,\n[extArgs](http://miasap.se/obnc/obncdoc/ext/extArgs.def.html)\nwhich provides access to command line arguments and\n[extConvert](http://miasap.se/obnc/obncdoc/ext/extConvert.def.html)\nwhich provides a means of converting strings to integers.\nIf you are using another Oberon compiler you'll need to \nfind their equivalents and change my code example. I\nuse `extArgs` to access the command line parameters\nincluded in my POSIX shell invocation and I've used\n`extConvert` to convert the string presentation of the\ndelay to an integer value for my delay.\n\n\n## Our Approach\n\nTo create \"SlowCat\" we need four procedures and one\nglobal variable.\n\n`Usage()`\n: display a help text if parameters don't make sense\n\n`ProcessArgs()`\n: to get our delay time from the command line\n\n`Delay(count : INTEGER)`\n: a busy wait procedure\n\n`SlowCat(count : INTEGER)`\n: take standard input and display like a teleprompter\n\n`count`\n: is an integer holding our delay value (seconds of waiting) which is set by ProcessArgs()\n\n### Usage\n\nUsage just wraps helpful text and display it to standard out.\n\n## ProcessArgs()\n\nThis a functional procedure. It uses two of Karl's extension\nmodules. It uses `extArgs` to retrieve the command line parameters\nand `extConvert` the string value retrieved into an integer.\n`ProcessArgs()` returns TRUE if we can successful convert the\ncommand line parameter and set the value of count otherwise return\nFALSE.\n\n## Delay(VAR count : INTEGER)\n\nThis procedure uses `Input0` to fetch the current epoch time\nand counts the number of seconds until we've reached our delay\nvalue. It's a busy loop which isn't ideal but does keep the\nprogram simple.\n\n## SlowCat(VAR count: INTEGER);\n\nThis is the heart of our command line program. It reads\na line of text from standard input, if successful writes it\nto standard out and then waits using delay before repeating\nthis process. The delay is only invoked when a reading a\nline was successful.\n\n## Putting it all together\n\nHere's a \"SlowCat\" program.\n\n\n~~~\n\n    MODULE SlowCat;\n      IMPORT In, Out, Input, Args := extArgs, Convert := extConvert;\n\n    CONST\n      MAXLINE = 1024;\n\n    VAR\n      count: INTEGER;\n\n    PROCEDURE Usage();\n    BEGIN\n      Out.String(\"USAGE:\");Out.Ln();\n      Out.Ln();\n      Out.String(\"SlowCat outputs lines of text delayed by\");Out.Ln();\n      Out.String(\"a number of seconds. It takes one parameter,\");Out.Ln();\n      Out.String(\"an integer, which is the number of seconds to\");Out.Ln();\n      Out.String(\"delay a line of output.\");Out.Ln();\n      Out.String(\"SlowCat works on standard input and output.\");Out.Ln();\n      Out.Ln();\n      Out.String(\"EXAMPLE:\");\n      Out.Ln();\n      Out.String(\"    SlowCat 15 < README.md\");Out.Ln();\n      Out.Ln();\n    END Usage;\n\n    PROCEDURE ProcessArgs() : BOOLEAN;\n      VAR i : INTEGER; ok : BOOLEAN; arg : ARRAY MAXLINE OF CHAR;\n          res : BOOLEAN;\n    BEGIN\n      res := FALSE;\n      IF Args.count = 1 THEN\n        Args.Get(0, arg, i);\n        Convert.StringToInt(arg, i, ok);\n        IF ok THEN\n           (* convert seconds to microseconds of clock *)\n           count := (i * 1000);\n           res := TRUE;\n        END;\n      END;\n      RETURN res\n    END ProcessArgs;\n\n    PROCEDURE Delay*(count : INTEGER);\n      VAR start, current, delay : INTEGER;\n    BEGIN\n       start := Input.Time();\n       REPEAT\n         current := Input.Time();\n         delay := (current - start);\n       UNTIL delay >= count;\n    END Delay;\n\n    PROCEDURE SlowCat(count : INTEGER);\n      VAR text : ARRAY MAXLINE OF CHAR;\n    BEGIN\n      REPEAT\n        In.Line(text);\n        IF In.Done THEN\n          Out.String(text);Out.Ln();\n          (* Delay by count *)\n          Delay(count);\n        END;\n      UNTIL In.Done = FALSE;\n    END SlowCat;\n\n    BEGIN\n      count := 0;\n      IF ProcessArgs() THEN\n        SlowCat(count);\n      ELSE\n        Usage();\n      END;\n    END SlowCat.\n\n~~~\n\n\n## Compiling and trying it out\n\nTo compile our program and try it out reading\nour source code do the following.\n\n\n~~~\n\n    obnc SlowCat.Mod\n    # If successful\n    ./SlowCat 2 < SlowCat.Mod\n\n~~~\n\n\n\n## Oakwood Guidelines and POW!\n\nOberon and Oberon-2 were both used in creating and enhancing the\nOberon System(s) as well as for writing programs on other operating\nsystems (e.g. Apple's Mac and Microsoft Windows).\nImplementing Oberon compilers on non Oberon Systems required clarification\nbeyond the specification. The Oakwood Guidelines were an agreement\nbetween some of the important Oberon-2 compiler implementers which\nattempted to fill in that gap while encouraging portability in\nsource code between operating systems. Portability was desirable\nbecause it allowed programmers (e.g. students) to compile\nand run their Oberon programs with minimal modification in any\nenvironment where an Oakwood compliant compiler was available.\n\nCitation for Oakwood can be found in [Oberon-2 Programming with Windows](https://archive.org/details/oberonprogrammin00mhlb/page/n363/mode/2up?q=Oakwood+Guidlines).\n\n> Kirk B.(ed): The Oakwood Guidelines for Oberon-2 Compiler Developers. Available via FTP from ftp.fim.uni-linz.ac.at, /pub/soft/pow-oberon/oakwood\n\nThe FTP machine doesn't exist any more and does not appear to have been included in JKU's preservation plans. Fortunately the POW! website has been preserved.\n\n[POW!](http://www.fim.uni-linz.ac.at/pow/pow.htm) was a\ndifferent approach. It was a compiler and IDE targeting\nother than Oberon Systems (e.g. Windows and later Java). It was\nintended to be used in a hybrid development environment and to\nfacilitate leveraging non-Oberon resources (e.g. Java classes,\nnative Windows API).  POW project proposed \"Opal\" which was a\nsuper set of modules that went beyond Oakwood. Having skimmed\n\"Oberon-2 Programming with Windows\" some may seem reasonable to\nport to Oberon-07, others less so.\n\nWhy Oakwood and POW? These efforts are of interest to Oberon-07\ndevelopers as a well worn path to write code that is easy to\ncompile on POSIX systems and on systems that are based on the\nmore recent [Project Oberon 2013](http://www.projectoberon.com/).\nIt enhances the opportunity to bring forward well written modules\nfrom prior systems like [A2](https://en.wikibooks.org/wiki/Oberon/A2)\nbut implemented for the next generation of Oberon Systems\nlike [Integrated Oberon](https://github.com/io-core/io).\n\n### Oakwood PDF\n\nFinding a PDF of the original Oakwood guidelines is going to become\ntricky in the future. It was created by Robinson Associates and the\ncopy I've read from 1995 includes a page saying not for distribution.\nWhich sorta makes sense in the era of closed source software\ndevelopment. It is problematic for those of us who want to explore\nhow systems evolved.  The term \"Oakwood Guidelines\" is bandied about\nafter 1993 and several of the modules have had influence on the language\nuse via book publications.  I was able to find a PDF of the 1995\nversion of the guidelines at\n[http://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf](http://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf).\n\nHere's a typical explanation of Oakwood from \n[http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines](http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines)\nfor a description of Oakwood.\n\n> __The Oakwood Guidelines for the Oberon-2 Compiler Developers /These guidelines have been produced by a group of Oberon-2 compiler developers, including ETH developers, after a meeting at the Oakwood Hotel in Croydon, UK in June 1993__\n\n[http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines](http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines)  \n(an OS/2 developer website) was helpful for providing details about Oakwood.\n\nIt would have been nice if the Oakwood document had made its way\ninto either ETH's or JKU's research libraries.\n\nLeveraging prior art opens doors to the past and future. Karl has\ndone with this with the modules he provides with his OBNC compiler\nproject.\n\n### Next and Previous\n\n+ Next [Oberon to Markdown](../../10/03/Oberon-to-markdown.html)\n+ Previous [Procedures in records](../..//07/07/Procedures-in-records.html)\n\n",
  "content_ast": {
    "children": [
      {
        "children": [
          {
            "type": "text",
            "value": "Portable Oberon-07"
          }
        ],
        "depth": 1,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "using OBNC modules"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "This is the eleventh post in the "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "Mostly Oberon"
              }
            ],
            "type": "link",
            "url": "../../04/11/Mostly-Oberon.html"
          },
          {
            "type": "text",
            "value": " series.\nMostly Oberon documents my exploration of the Oberon Language, Oberon System and the\nvarious rabbit holes I will inevitably fall into."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Working with standard input"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "By R. S. Doiel, 2020-08-15 (updated: 2020-09-05)"
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Karl Landström's "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "OBNC"
              }
            ],
            "type": "link",
            "url": "https://miasap.se/obnc/"
          },
          {
            "type": "text",
            "value": ", Oberon-07 compiler,\ncomes with an Oberon-2 inspired set of modules\ndescribed in the Oakwood Guidelines as well as\nseveral very useful additions making Oberon-07 suitable for\nwriting programs in a POSIX environment.  We're going to\nexplore three of the Oakwood modules and two of Karl's own additions\nin this post as we create a program called "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "SlowCat"
              }
            ],
            "type": "link",
            "url": "SlowCat.Mod"
          },
          {
            "type": "text",
            "value": ".\nI am using the term \"portable\" to mean the code can be compiled\nusing OBNC on macOS, Linux, and Raspberry Pi OS and Windows 10\n(i.e. wherever OBNC is available). The Oakwood Guideline modules\nfocus on portability between an Oberon System and other systems.\nI'll leave that discussion along with\n"
          },
          {
            "children": [
              {
                "type": "text",
                "value": "POW!"
              }
            ],
            "type": "link",
            "url": "http://www.fim.uni-linz.ac.at/pow/pow.htm"
          },
          {
            "type": "text",
            "value": "\nto the end of this post."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "SlowCat"
          }
        ],
        "depth": 3,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Recently while I was reviewing logs at work using "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "cat"
              }
            ],
            "type": "link",
            "url": "https://en.wikipedia.org/wiki/Cat_(Unix)"
          },
          {
            "type": "text",
            "value": ", "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "grep"
              }
            ],
            "type": "link",
            "url": "https://en.wikipedia.org/wiki/Grep"
          },
          {
            "type": "text",
            "value": "\nand "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "more"
              }
            ],
            "type": "link",
            "url": "https://en.wikipedia.org/wiki/More_(command)"
          },
          {
            "type": "text",
            "value": " it\nstruck me that it would have been nice if "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "cat"
              }
            ],
            "type": "strong"
          },
          {
            "type": "text",
            "value": "\nor "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "more"
              }
            ],
            "type": "strong"
          },
          {
            "type": "text",
            "value": " came with a time delay so you could use them like a\nteleprompter. This would let you casually watch the file scroll\nby while still being able to read the lines. The program we'll build\nin this post is \"SlowCat\" which accepts a command line parameter\nindicating the delay in seconds between display each line read from\nstandard input."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Working with Standard Input and Output"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "The Oakwood guides for Oberon-2 describe two modules\nparticularly useful for working with standard input and output.\nThey are appropriately called "
          },
          {
            "type": "inlineCode",
            "value": "In"
          },
          {
            "type": "text",
            "value": " and "
          },
          {
            "type": "inlineCode",
            "value": "Out"
          },
          {
            "type": "text",
            "value": ". On many Oberon Systems\nthese have been implemented such that your code could run under Unix\nor Oberon System with a simple re-compile.  We've used "
          },
          {
            "type": "inlineCode",
            "value": "Out"
          },
          {
            "type": "text",
            "value": " in our\nfirst program of this series, \"Hello World\". It provides a means to\nwrite Oberon system base types to standard out.  We've used "
          },
          {
            "type": "inlineCode",
            "value": "In"
          },
          {
            "type": "text",
            "value": "\na few times too. But "
          },
          {
            "type": "inlineCode",
            "value": "In"
          },
          {
            "type": "text",
            "value": " is worth diving into a bit more."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "In"
          }
        ],
        "depth": 3,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "The "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "In"
              }
            ],
            "type": "link",
            "url": "http://miasap.se/obnc/obncdoc/basic/In.def.html"
          },
          {
            "type": "text",
            "value": " module provides\na mirror of inputs to those of "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "Out"
              }
            ],
            "type": "link",
            "url": "http://miasap.se/obnc/obncdoc/basic/Out.def.html"
          },
          {
            "type": "text",
            "value": ". In Karl's implementation we are interested in one procedure\nand module status variable."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "children": [
              {
                "children": [
                  {
                    "type": "inlineCode",
                    "value": "In.Line(VAR line: ARRAY OF CHAR)"
                  },
                  {
                    "type": "text",
                    "value": " : Read a sequence of characters from standard input from the current position in the file to the end of line."
                  }
                ],
                "type": "paragraph"
              }
            ],
            "spread": false,
            "type": "listItem"
          },
          {
            "children": [
              {
                "children": [
                  {
                    "type": "inlineCode",
                    "value": "In.Done"
                  },
                  {
                    "type": "text",
                    "value": " : Is a status Boolean variable, if the last call to an procedure in "
                  },
                  {
                    "type": "inlineCode",
                    "value": "In"
                  },
                  {
                    "type": "text",
                    "value": " was successful then it is set TRUE, otherwise FALSE (e.g. we're at the end of a file)"
                  }
                ],
                "type": "paragraph"
              }
            ],
            "spread": false,
            "type": "listItem"
          }
        ],
        "ordered": false,
        "spread": false,
        "type": "list"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "We use Karl's "
          },
          {
            "type": "inlineCode",
            "value": "In.Line()"
          },
          {
            "type": "text",
            "value": " extension to the standard "
          },
          {
            "type": "inlineCode",
            "value": "In"
          },
          {
            "type": "text",
            "value": " implementation\nbefore and will do so again as it simplifies our code and keeps things\neasily readable."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "There is one nuance with "
          },
          {
            "type": "inlineCode",
            "value": "In.Done"
          },
          {
            "type": "text",
            "value": " that is easy to get tripped up on.\n"
          },
          {
            "type": "inlineCode",
            "value": "In.Done"
          },
          {
            "type": "text",
            "value": " indicates if the last operation was successful.\nSo if you're using "
          },
          {
            "type": "inlineCode",
            "value": "In.Line()"
          },
          {
            "type": "text",
            "value": " then "
          },
          {
            "type": "inlineCode",
            "value": "In.Done"
          },
          {
            "type": "text",
            "value": "\nshould be true if reading the line was successful. If you hit the end of\nthe file then "
          },
          {
            "type": "inlineCode",
            "value": "In.Done"
          },
          {
            "type": "text",
            "value": " should be false.  When you write your loop\nthis can be counter intuitive.  Here is a example of testing "
          },
          {
            "type": "inlineCode",
            "value": "In.Done"
          },
          {
            "type": "text",
            "value": "\nwith a repeat until loop."
          }
        ],
        "type": "paragraph"
      },
      {
        "type": "code",
        "value": "\n    REPEAT\n      In.Line(text);\n      IF In.Done THEN\n        Out.String(text);Out.Ln();\n      END;\n    UNTIL In.Done = FALSE;\n"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "So when you read this it is easy to think of "
          },
          {
            "type": "inlineCode",
            "value": "In.Done"
          },
          {
            "type": "text",
            "value": " as you're\ndone reading from standard input but actually we need to check for "
          },
          {
            "type": "inlineCode",
            "value": "FALSE"
          },
          {
            "type": "text",
            "value": ".\nThe value of "
          },
          {
            "type": "inlineCode",
            "value": "In.Done"
          },
          {
            "type": "text",
            "value": " was indicating the success of reading our line.\nAn unsuccessful line read, meaning we're at the end of the file, sets\n"
          },
          {
            "type": "inlineCode",
            "value": "In.Done"
          },
          {
            "type": "text",
            "value": " to false!"
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Out"
          }
        ],
        "depth": 3,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "As mention "
          },
          {
            "type": "inlineCode",
            "value": "Out"
          },
          {
            "type": "text",
            "value": " provides our output functions. We'll be using\ntwo procedure from "
          },
          {
            "type": "inlineCode",
            "value": "Out"
          },
          {
            "type": "text",
            "value": ", namely "
          },
          {
            "type": "inlineCode",
            "value": "Out.String()"
          },
          {
            "type": "text",
            "value": " and "
          },
          {
            "type": "inlineCode",
            "value": "Out.Ln()"
          },
          {
            "type": "text",
            "value": ".\nWe've seen both before."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Input"
          }
        ],
        "depth": 3,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "\"SlowCat\" needs to calculate how often to write a line of\ntext to standard output with the "
          },
          {
            "type": "inlineCode",
            "value": "Out"
          },
          {
            "type": "text",
            "value": " module.  To do that\nI need access to the system's current time.  There isn't an\nOakwood module for time. There is a module called\n"
          },
          {
            "type": "inlineCode",
            "value": "Input"
          },
          {
            "type": "text",
            "value": " which provides a \"Time\" procedure. As a result\nI need to import "
          },
          {
            "type": "inlineCode",
            "value": "Input"
          },
          {
            "type": "text",
            "value": " as well as "
          },
          {
            "type": "inlineCode",
            "value": "In"
          },
          {
            "type": "text",
            "value": " even though\nI am using "
          },
          {
            "type": "inlineCode",
            "value": "In"
          },
          {
            "type": "text",
            "value": " to manage reading the file I am processing\nwith \"SlowCat\"."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "A note about Karl's implementation.  "
          },
          {
            "type": "inlineCode",
            "value": "Input"
          },
          {
            "type": "text",
            "value": " is an Oakwood\nmodule that provides access to three system resources --\nmouse, keyboard and system time.  Karl\nprovides two versions "
          },
          {
            "type": "inlineCode",
            "value": "Input"
          },
          {
            "type": "text",
            "value": " and "
          },
          {
            "type": "inlineCode",
            "value": "Input0"
          },
          {
            "type": "text",
            "value": ", the first is\nintended to be used with the "
          },
          {
            "type": "inlineCode",
            "value": "XYPlane"
          },
          {
            "type": "text",
            "value": " module for graphical\napplications the second for POSIX shell based application.\nIn the case of \"SlowCat\" I've stuck with "
          },
          {
            "type": "inlineCode",
            "value": "Input"
          },
          {
            "type": "text",
            "value": " as I am\nonly accessing time I've stuck with "
          },
          {
            "type": "inlineCode",
            "value": "Input"
          },
          {
            "type": "text",
            "value": " to make my source\ncode more portable if you're using another Oberon compiler."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Working with Karl's extensions"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "This is the part of my code which is not portable\nbetween compiler implementations and with Oberon Systems.\nKarl provides a number of extension module wrapping various\nPOSIX calls.  We are going to use two,\n"
          },
          {
            "children": [
              {
                "type": "text",
                "value": "extArgs"
              }
            ],
            "type": "link",
            "url": "http://miasap.se/obnc/obncdoc/ext/extArgs.def.html"
          },
          {
            "type": "text",
            "value": "\nwhich provides access to command line arguments and\n"
          },
          {
            "children": [
              {
                "type": "text",
                "value": "extConvert"
              }
            ],
            "type": "link",
            "url": "http://miasap.se/obnc/obncdoc/ext/extConvert.def.html"
          },
          {
            "type": "text",
            "value": "\nwhich provides a means of converting strings to integers.\nIf you are using another Oberon compiler you'll need to\nfind their equivalents and change my code example. I\nuse "
          },
          {
            "type": "inlineCode",
            "value": "extArgs"
          },
          {
            "type": "text",
            "value": " to access the command line parameters\nincluded in my POSIX shell invocation and I've used\n"
          },
          {
            "type": "inlineCode",
            "value": "extConvert"
          },
          {
            "type": "text",
            "value": " to convert the string presentation of the\ndelay to an integer value for my delay."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Our Approach"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "To create \"SlowCat\" we need four procedures and one\nglobal variable."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "inlineCode",
            "value": "Usage()"
          },
          {
            "type": "text",
            "value": "\n: display a help text if parameters don't make sense"
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "inlineCode",
            "value": "ProcessArgs()"
          },
          {
            "type": "text",
            "value": "\n: to get our delay time from the command line"
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "inlineCode",
            "value": "Delay(count : INTEGER)"
          },
          {
            "type": "text",
            "value": "\n: a busy wait procedure"
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "inlineCode",
            "value": "SlowCat(count : INTEGER)"
          },
          {
            "type": "text",
            "value": "\n: take standard input and display like a teleprompter"
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "inlineCode",
            "value": "count"
          },
          {
            "type": "text",
            "value": "\n: is an integer holding our delay value (seconds of waiting) which is set by ProcessArgs()"
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Usage"
          }
        ],
        "depth": 3,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Usage just wraps helpful text and display it to standard out."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "ProcessArgs()"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "This a functional procedure. It uses two of Karl's extension\nmodules. It uses "
          },
          {
            "type": "inlineCode",
            "value": "extArgs"
          },
          {
            "type": "text",
            "value": " to retrieve the command line parameters\nand "
          },
          {
            "type": "inlineCode",
            "value": "extConvert"
          },
          {
            "type": "text",
            "value": " the string value retrieved into an integer.\n"
          },
          {
            "type": "inlineCode",
            "value": "ProcessArgs()"
          },
          {
            "type": "text",
            "value": " returns TRUE if we can successful convert the\ncommand line parameter and set the value of count otherwise return\nFALSE."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Delay(VAR count : INTEGER)"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "This procedure uses "
          },
          {
            "type": "inlineCode",
            "value": "Input0"
          },
          {
            "type": "text",
            "value": " to fetch the current epoch time\nand counts the number of seconds until we've reached our delay\nvalue. It's a busy loop which isn't ideal but does keep the\nprogram simple."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "SlowCat(VAR count: INTEGER);"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "This is the heart of our command line program. It reads\na line of text from standard input, if successful writes it\nto standard out and then waits using delay before repeating\nthis process. The delay is only invoked when a reading a\nline was successful."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Putting it all together"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Here's a \"SlowCat\" program."
          }
        ],
        "type": "paragraph"
      },
      {
        "type": "code",
        "value": "\n    MODULE SlowCat;\n      IMPORT In, Out, Input, Args := extArgs, Convert := extConvert;\n\n    CONST\n      MAXLINE = 1024;\n\n    VAR\n      count: INTEGER;\n\n    PROCEDURE Usage();\n    BEGIN\n      Out.String(\"USAGE:\");Out.Ln();\n      Out.Ln();\n      Out.String(\"SlowCat outputs lines of text delayed by\");Out.Ln();\n      Out.String(\"a number of seconds. It takes one parameter,\");Out.Ln();\n      Out.String(\"an integer, which is the number of seconds to\");Out.Ln();\n      Out.String(\"delay a line of output.\");Out.Ln();\n      Out.String(\"SlowCat works on standard input and output.\");Out.Ln();\n      Out.Ln();\n      Out.String(\"EXAMPLE:\");\n      Out.Ln();\n      Out.String(\"    SlowCat 15 < README.md\");Out.Ln();\n      Out.Ln();\n    END Usage;\n\n    PROCEDURE ProcessArgs() : BOOLEAN;\n      VAR i : INTEGER; ok : BOOLEAN; arg : ARRAY MAXLINE OF CHAR;\n          res : BOOLEAN;\n    BEGIN\n      res := FALSE;\n      IF Args.count = 1 THEN\n        Args.Get(0, arg, i);\n        Convert.StringToInt(arg, i, ok);\n        IF ok THEN\n           (* convert seconds to microseconds of clock *)\n           count := (i * 1000);\n           res := TRUE;\n        END;\n      END;\n      RETURN res\n    END ProcessArgs;\n\n    PROCEDURE Delay*(count : INTEGER);\n      VAR start, current, delay : INTEGER;\n    BEGIN\n       start := Input.Time();\n       REPEAT\n         current := Input.Time();\n         delay := (current - start);\n       UNTIL delay >= count;\n    END Delay;\n\n    PROCEDURE SlowCat(count : INTEGER);\n      VAR text : ARRAY MAXLINE OF CHAR;\n    BEGIN\n      REPEAT\n        In.Line(text);\n        IF In.Done THEN\n          Out.String(text);Out.Ln();\n          (* Delay by count *)\n          Delay(count);\n        END;\n      UNTIL In.Done = FALSE;\n    END SlowCat;\n\n    BEGIN\n      count := 0;\n      IF ProcessArgs() THEN\n        SlowCat(count);\n      ELSE\n        Usage();\n      END;\n    END SlowCat.\n"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Compiling and trying it out"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "To compile our program and try it out reading\nour source code do the following."
          }
        ],
        "type": "paragraph"
      },
      {
        "type": "code",
        "value": "\n    obnc SlowCat.Mod\n    # If successful\n    ./SlowCat 2 < SlowCat.Mod\n"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Oakwood Guidelines and POW!"
          }
        ],
        "depth": 2,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Oberon and Oberon-2 were both used in creating and enhancing the\nOberon System(s) as well as for writing programs on other operating\nsystems (e.g. Apple's Mac and Microsoft Windows).\nImplementing Oberon compilers on non Oberon Systems required clarification\nbeyond the specification. The Oakwood Guidelines were an agreement\nbetween some of the important Oberon-2 compiler implementers which\nattempted to fill in that gap while encouraging portability in\nsource code between operating systems. Portability was desirable\nbecause it allowed programmers (e.g. students) to compile\nand run their Oberon programs with minimal modification in any\nenvironment where an Oakwood compliant compiler was available."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Citation for Oakwood can be found in "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "Oberon-2 Programming with Windows"
              }
            ],
            "type": "link",
            "url": "https://archive.org/details/oberonprogrammin00mhlb/page/n363/mode/2up?q=Oakwood+Guidlines"
          },
          {
            "type": "text",
            "value": "."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "children": [
              {
                "type": "text",
                "value": "Kirk B.(ed): The Oakwood Guidelines for Oberon-2 Compiler Developers. Available via FTP from ftp.fim.uni-linz.ac.at, /pub/soft/pow-oberon/oakwood"
              }
            ],
            "type": "paragraph"
          }
        ],
        "type": "blockquote"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "The FTP machine doesn't exist any more and does not appear to have been included in JKU's preservation plans. Fortunately the POW! website has been preserved."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "children": [
              {
                "type": "text",
                "value": "POW!"
              }
            ],
            "type": "link",
            "url": "http://www.fim.uni-linz.ac.at/pow/pow.htm"
          },
          {
            "type": "text",
            "value": " was a\ndifferent approach. It was a compiler and IDE targeting\nother than Oberon Systems (e.g. Windows and later Java). It was\nintended to be used in a hybrid development environment and to\nfacilitate leveraging non-Oberon resources (e.g. Java classes,\nnative Windows API).  POW project proposed \"Opal\" which was a\nsuper set of modules that went beyond Oakwood. Having skimmed\n\"Oberon-2 Programming with Windows\" some may seem reasonable to\nport to Oberon-07, others less so."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Why Oakwood and POW? These efforts are of interest to Oberon-07\ndevelopers as a well worn path to write code that is easy to\ncompile on POSIX systems and on systems that are based on the\nmore recent "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "Project Oberon 2013"
              }
            ],
            "type": "link",
            "url": "http://www.projectoberon.com/"
          },
          {
            "type": "text",
            "value": ".\nIt enhances the opportunity to bring forward well written modules\nfrom prior systems like "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "A2"
              }
            ],
            "type": "link",
            "url": "https://en.wikibooks.org/wiki/Oberon/A2"
          },
          {
            "type": "text",
            "value": "\nbut implemented for the next generation of Oberon Systems\nlike "
          },
          {
            "children": [
              {
                "type": "text",
                "value": "Integrated Oberon"
              }
            ],
            "type": "link",
            "url": "https://github.com/io-core/io"
          },
          {
            "type": "text",
            "value": "."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Oakwood PDF"
          }
        ],
        "depth": 3,
        "type": "heading"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Finding a PDF of the original Oakwood guidelines is going to become\ntricky in the future. It was created by Robinson Associates and the\ncopy I've read from 1995 includes a page saying not for distribution.\nWhich sorta makes sense in the era of closed source software\ndevelopment. It is problematic for those of us who want to explore\nhow systems evolved.  The term \"Oakwood Guidelines\" is bandied about\nafter 1993 and several of the modules have had influence on the language\nuse via book publications.  I was able to find a PDF of the 1995\nversion of the guidelines at\n"
          },
          {
            "children": [
              {
                "type": "text",
                "value": "http://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf"
              }
            ],
            "type": "link",
            "url": "http://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf"
          },
          {
            "type": "text",
            "value": "."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Here's a typical explanation of Oakwood from\n"
          },
          {
            "children": [
              {
                "type": "text",
                "value": "http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines"
              }
            ],
            "type": "link",
            "url": "http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines"
          },
          {
            "type": "text",
            "value": "\nfor a description of Oakwood."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "children": [
              {
                "children": [
                  {
                    "type": "text",
                    "value": "The Oakwood Guidelines for the Oberon-2 Compiler Developers /These guidelines have been produced by a group of Oberon-2 compiler developers, including ETH developers, after a meeting at the Oakwood Hotel in Croydon, UK in June 1993"
                  }
                ],
                "type": "strong"
              }
            ],
            "type": "paragraph"
          }
        ],
        "type": "blockquote"
      },
      {
        "children": [
          {
            "children": [
              {
                "type": "text",
                "value": "http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines"
              }
            ],
            "type": "link",
            "url": "http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines"
          },
          {
            "type": "break"
          },
          {
            "type": "text",
            "value": "(an OS/2 developer website) was helpful for providing details about Oakwood."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "It would have been nice if the Oakwood document had made its way\ninto either ETH's or JKU's research libraries."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Leveraging prior art opens doors to the past and future. Karl has\ndone with this with the modules he provides with his OBNC compiler\nproject."
          }
        ],
        "type": "paragraph"
      },
      {
        "children": [
          {
            "type": "text",
            "value": "Next and Previous"
          }
        ],
        "depth": 3,
        "type": "heading"
      },
      {
        "children": [
          {
            "children": [
              {
                "children": [
                  {
                    "type": "text",
                    "value": "Next "
                  },
                  {
                    "children": [
                      {
                        "type": "text",
                        "value": "Oberon to Markdown"
                      }
                    ],
                    "type": "link",
                    "url": "../../10/03/Oberon-to-markdown.html"
                  }
                ],
                "type": "paragraph"
              }
            ],
            "spread": false,
            "type": "listItem"
          },
          {
            "children": [
              {
                "children": [
                  {
                    "type": "text",
                    "value": "Previous "
                  },
                  {
                    "children": [
                      {
                        "type": "text",
                        "value": "Procedures in records"
                      }
                    ],
                    "type": "link",
                    "url": "../..//07/07/Procedures-in-records.html"
                  }
                ],
                "type": "paragraph"
              }
            ],
            "spread": false,
            "type": "listItem"
          }
        ],
        "ordered": false,
        "spread": false,
        "type": "list"
      }
    ],
    "type": "root"
  },
  "data": {
    "author": "rsdoiel@gmail.com (R. S. Doiel)",
    "copyright": "copyright (c) 2020, R. S. Doiel",
    "date": "2020-08-15",
    "keywords": [
      "Oberon",
      "portable",
      "stdin"
    ],
    "license": "https://creativecommons.org/licenses/by-sa/4.0/",
    "number": 11,
    "series": "Mostly Oberon",
    "title": "Portable Oberon-07"
  }
}