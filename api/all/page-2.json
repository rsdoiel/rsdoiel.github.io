{
  "page": 2,
  "total_pages": 2,
  "has_more": false,
  "next_page": null,
  "values": [
    {
      "content": "\nPortable conversions (Integers)\n===============================\n\nBy R. S. Doiel, 2021-11-26\n\nAn area in working with Oberon-07 on a POSIX machine that has proven problematic is type conversion. In particular converting to and from INTEGER or REAL and ASCII.  None of the three compilers I am exploring provide a common way of handling this. I've explored relying on C libraries but that approach has it's own set of problems.  I've become convinced a better approach is a pure Oberon-07 library that handles type conversion with a minimum of assumptions about the implementation details of the Oberon compiler or hardware. I'm calling my conversion module \"Types\". The name is short and descriptive and seems an appropriate name for a module consisting of type conversion tests and transformations.  My initial implementation will focusing on converting integers to and from ASCII.\n\nINTEGER to ASCII and back again\n-------------------------------\n\nI don't want to rely on the representation of the INTEGER value in the compiler or at the machine level. That has lead me to think in terms of an INTEGER as a signed whole number. \n\nThe simplest case of converting to/from ASCII is the digits from zero to nine (inclusive). Going from an INTEGER to an ASCII CHAR is just looking up the offset of the character representing the \"digit\". Like wise going from ASCII CHAR to a INTEGER is a matter of mapping in the reverse direction.  Let's call these procedures `DigitToChar` and  `CharToDigit*`.\n\nSince INTEGER can be larger than zero through nine and CHAR can hold non-digits I'm going to add two additional procedures for validating inputs -- `IsIntDigit` and `IsCharDigit`. Both return TRUE if valid, FALSE if not.\n\nFor numbers larger than one digit I can use decimal right shift to extract the ones column value or a left shift to reverse the process.  Let's called these `IntShiftRight` and `IntShiftLeft`.  For shift right it'd be good to capture the ones column being lost. For shift left it would be good to be able to shift in a desired digit. That way you could shift/unshift to retrieve to extract and put back values.\n\nA draft definition for \"Types\" should look something like this.\n\n~~~\nDEFINITION Types;\n\n(* Check if an integer is a single digit, i.e. from 0 through 9 returns\n   TRUE, otherwise FALSE *)\nPROCEDURE IsIntDigit(x : INTEGER) : BOOLEAN;\n\n(* Check if a CHAR is \"0\" through \"9\" and return TRUE, otherwise FALSE *)\nPROCEDURE IsCharDigit(ch : CHAR) : BOOLEAN;\n\n(* Convert digit 0 through 9 into an ASCII CHAR \"0\" through \"9\",\n   ok is TRUE if conversion successful, FALSE otherwise *)\nPROCEDURE DigitToChar(x : INTEGER; VAR ch : CHAR; VAR ok : BOOLEAN);\n\n(* Convert a CHAR \"0\" through \"9\" into a digit 0 through 9, ok\n   is TRUE is conversion successful, FALSE otherwise *)\nPROCEDURE CharToDigit(ch : CHAR; VAR x : INTEGER; VAR ok : BOOLEAN);\n\n(* Shift an integer to the right (i.e. x * 0.1) set \"r\" to the\n   value shifted out (ones column lost) and return the shifted value.\n   E.g.  x becomes 12, r becomes 3.\n\n       x := IntShiftRight(123, r);\n   \n *)\nPROCEDURE IntShiftRight(x : INTEGER; VAR r : INTEGER) : INTEGER;\n\n(* Shift an integer to the left (i.e. x * 10) adding the value y\n   after the shift.\n\n   E.g. x before 123\n\n       x := IntShiftRight(12, 3);\n\n *)\nPROCEDURE IntShiftLeft(x, y : INTEGER) : INTEGER;\n\n(* INTEGER to ASCII *)\nPROCEDURE Itoa(src : INTEGER; VAR value : ARRAY OF CHAR; VAR ok : BOOLEAN);\n\n(* ASCII to INTEGER *)\nPROCEDURE Atoi(src : ARRAY OF CHAR; VAR value : INTEGER; VAR ok : BOOLEAN);\n\nEND Types.\n~~~\n\n\nNOTE: Oberon-07 provides us the ORD and CHR built as part of the\nlanguage.  These are for working with the encoding and decoding\nvalues as integers. This is not the same thing as the meaning\nof \"0\" versus the value of 0.  Getting to and from the encoding\nto the meaning of the presentation can be done with some simple\narithmetic.\n\nPutting it all together\n-----------------------\n\n~~~\n(* DigitToChar converts an INTEGER less than to a character. E.g.\n   0 should return \"0\", 3 returns \"3\", 0 returns \"9\" *)\nPROCEDURE DigitToChar*(i : INTEGER) : CHAR;\nBEGIN\n  RETURN (CHR(ORD(\"0\") + i))\nEND DigitToChar;\n\n(* CharToDigit converts a single \"Digit\" character to an INTEGER value.\n   E.g. \"0\" returns 0, \"3\" returns 3, \"9\" returns 9. *)\nPROCEDURE CharToDigit(ch : CHAR) : INTEGER;\nBEGIN\n  RETURN (ORD(ch) - ORD(\"0\"))\nEND CharToDigit;\n~~~\n\nThis implementation is naive. It assumes the ranges of the input values\nwas already checked. In practice this is going to encourage bugs.\n\nIn a language like Go or Python you can return multiple values (in\nPython you can return a tuple). In Oberon-07 I could use a\nRECORD type to do that but that feels a little too baroque. Oberon-07\nlike Oberon-2, Oberon, Modula and Pascal does support \"VAR\" parameters. \nWith a slight modification to our procedure signatures I can support\neasy assertions about the conversion. Let's create two functional\nprocedures `IsIntDigit()` and `IsCharDigit()` then update our\n`DigitToChar()` and `CharToDigit()` with an a  \"VAR ok : BOOLEAN\"\nparameter.\n\n~~~\n(* IsIntDigit returns TRUE is the integer value is zero through nine *)\nPROCEDURE IsIntDigit(i : INTEGER) : BOOLEAN;\nBEGIN \n  RETURN ((i >= 0) & (i <= 9))\nEND IsIntDigit;\n\n(* IsCharDigit returns TRUE if character is zero through nine. *)\nPROCEDURE IsCharDigit(ch : CHAR) : BOOLEAN;\nBEGIN\n  RETURN ((ch >= \"0\") & (ch <= \"9\"))\nEND IsCharDigit;\n\n(* DigitToChar converts an INTEGER less than to a character. E.g.\n   0 should return \"0\", 3 returns \"3\", 0 returns \"9\" *)\nPROCEDURE DigitToChar*(i : INTEGER; VAR ok : BOOLEAN) : CHAR;\nBEGIN\n  ok := IsIntDigit(i);\n  RETURN (CHR(ORD(\"0\") + i))\nEND DigitToChar;\n\n(* CharToDigit converts a single \"Digit\" character to an INTEGER value.\n   E.g. \"0\" returns 0, \"3\" returns 3, \"9\" returns 9. *)\nPROCEDURE CharToDigit(ch : CHAR; VAR ok : BOOLEAN) : INTEGER;\nBEGIN\n  ok := IsCharDigit(ch);\n  RETURN (ORD(ch) - ORD(\"0\"))\nEND CharToDigit;\n~~~\n\nWhat about values are greater nine? Here we can take advantage\nof our integer shift procedures.  `IntShiftRight` will move the\nINTEGER value right reducing it's magnitude (i.e. x * 0.1). It\nalso captures the ones column lost in the shift.  Repeatedly calling\n`IntShiftRight` will let us peal off the ones columns until the\nvalue \"x\" is zero. `IntShiftLeft` shifts the integer to the\nleft meaning it raises it a magnitude (i.e. x * 10). `IntShiftLeft`\nalso rakes a value to shift in on the right side of the number.\nIn this way we can shift in a zero and get `x * 10` or shift in\nanother digit and get `(x * 10) + y`. This means you can use\n`IntShiftRight` and recover an `IntShiftLeft`.\n\n~~~\n\n(* IntShiftRight converts the input integer to a real, multiplies by 0.1\n   and converts by to an integer. The value in the ones column is record\n   in the VAR parameter r.  E.g. IntShiftRight(123) return 12, r is set to 3. *)\nPROCEDURE IntShiftRight*(x : INTEGER; VAR r : INTEGER) : INTEGER;\n  VAR i : INTEGER; isNeg : BOOLEAN;\nBEGIN\n  isNeg := (x < 0);\n  i := FLOOR(FLT(ABS(x)) * 0.1);\n  r := ABS(x) - (i * 10);\n  IF isNeg THEN\n    i := i * (-1);\n  END;\n  RETURN i\nEND IntShiftRight;\n\n(* IntShiftLeft multiples input value by 10 and adds y. E.g. IntShiftLeft(123, 4) return 1234 *)\nPROCEDURE IntShiftLeft*(x, y : INTEGER) : INTEGER;\n  VAR i : INTEGER; isNeg : BOOLEAN;\nBEGIN\n  isNeg := (x < 0);\n  i := (ABS(x) * 10) + y;\n  IF isNeg THEN\n    i := i * (-1);\n  END;\n  RETURN i\nEND IntShiftLeft;\n\n~~~\n\nI have what I need for implementing `Itoa` (integer to ASCII).\n\n\n~~~\n\n(* Itoa converts an INTEGER to an ASCII string setting ok BOOLEAN to\n   TRUE if value ARRAY OF CHAR holds the full integer, FALSE if\n   value was too small to hold the integer value.  *)\nPROCEDURE Itoa*(x : INTEGER; VAR value : ARRAY OF CHAR; ok : BOOLEAN);\n  VAR i, j, k, l, minL : INTEGER; tmp : ARRAY BUFSIZE OF CHAR; isNeg : BOOLEAN;\nBEGIN\n  i := 0; j := 0; k := 0; l := LEN(value); isNeg := (x < 0);\n  IF isNeg THEN\n    (* minimum string length for value is 3, negative sign, digit and 0X *)\n    minL := 3;\n  ELSE \n    (* minimum string length for value is 2, one digit and 0X *)\n    minL := 2; \n  END;\n  ok := (l >= minL) & (LEN(value) >= LEN(tmp));\n  IF ok THEN\n    IF IsIntDigit(ABS(x)) THEN\n      IF isNeg THEN\n         value[i] := \"-\"; INC(i);\n      END;\n      value[i] := DigitToChar(ABS(x), ok); INC(i); value[i] := 0X;\n    ELSE\n      x := ABS(x); (* We need to work with the absolute value of x *)\n      i := 0; tmp[i] := 0X;\n      WHILE (x >= 10) & ok DO\n        (* extract the ones columns *)\n        x := IntShiftRight(x, k); (* a holds the shifted value, \n                                     \"k\" holds the ones column \n                                     value shifted out. *)\n        (* write append k to our temp array holding values in\n           reverse number magnitude *)\n        tmp[i] := DigitToChar(k, ok); INC(i); tmp[i] := 0X;\n      END;\n      (* We now can convert the remaining \"ones\" column. *)\n      tmp[i] := DigitToChar(x, ok); INC(i); tmp[i] := 0X;\n      IF ok THEN\n        (* now reverse the order of tmp string append each\n           character to value *)\n        i := 0; j := Strings.Length(tmp) - 2;\n        IF isNeg THEN\n          value[i] := \"-\"; INC(i);\n        END;\n        j := Strings.Length(tmp) - 1;\n        WHILE (j > -1) DO\n          value[i]:= tmp[j]; \n          INC(i); DEC(j);\n          value[i] := 0X;\n        END;\n        value[i] := 0X;\n      END;\n    END; \n  ELSE\n    ok := FALSE;\n  END;\nEND Itoa;\n\n~~~\n\nIntegers in Oberon are signed. So I've chosen to capture the sign in the `isNeg` variable. This lets me work with the absolute value for the actual conversion.  One failing in this implementation is I don't detect an overflow.  Also notice that I am accumulating the individual column values in reverse order (lowest magnitude first).  That is what I need a temporary buffer. I can then copy the values in reverse order into the VAR ARRAY OF CHAR. Finally I also maintain the ok BOOLEAN to track if anything went wrong.\n\nWhen moving from an ASCII representation I can simplified the code by having a local (to the module) procedure for generating magnitudes.\n\nGoing the other way I can simplify my `Atoi` if I have an local to the module \"magnitude\" procedure.\n\n~~~\n\n(* magnitude takes x and multiplies it be 10^y, If y is positive zeros\n   are appended to the right side (i.e. multiplied by 10). If y is\n   negative then the result is shifted left (i.e.. multiplied by\n   0.1 via IntShiftRight().).  The digit(s) shift to the fractional\n   side of the decimal are ignored. *)\nPROCEDURE magnitude(x, y : INTEGER) : INTEGER;\n  VAR z, w : INTEGER;\nBEGIN\n  z := 1;\n  IF y >= 0 THEN\n    WHILE y > 0 DO\n      z := IntShiftLeft(z, 0);\n      DEC(y);\n    END;\n  ELSE\n    WHILE y < 0 DO\n      x := IntShiftRight(x, w);\n      INC(y);\n    END;\n  END;\n  RETURN (x * z)\nEND magnitude;\n\n~~~\n\nAnd with that I can put together my `Atoi` (ASCII to integer) procedure.  I'll need to add some sanity checks as well.\n\n~~~\n\n(* Atoi converts an ASCII string to a signed integer value\n   setting the ok BOOLEAN to TRUE on success and FALSE on error. *)\nPROCEDURE Atoi*(source : ARRAY OF CHAR; VAR value : INTEGER; VAR ok : BOOLEAN);\n  VAR i, l, a, m: INTEGER; isNeg : BOOLEAN;\nBEGIN\n  (* \"i\" is the current CHAR position we're analyzing, \"l\" is the\n     length of our string, \"a\" holds the accumulated value,\n     \"m\" holds the current magnitude we're working with *)\n  i := 0; l := Strings.Length(source);\n  a := 0; m := l - 1; isNeg := FALSE; ok := TRUE;\n  (* Validate magnitude and sign behavior *)\n  IF (l > 0) & (source[0] = \"-\") THEN\n    INC(i); DEC(m);\n    isNeg := TRUE;\n  ELSIF (l > 0) & (source[0] = \"+\") THEN\n    INC(i); DEC(m);\n  END;\n\n  (* The accumulator should always hold a positive integer, if the\n     sign flips we have overflow, ok should be set to FALSE *)\n  ok := TRUE;\n  WHILE (i < l) & ok DO\n    a := a + magnitude(CharToDigit(source[i], ok), m);\n    IF a < 0 THEN\n      ok := FALSE; (* we have an overflow condition *)\n    END;\n    DEC(m);\n    INC(i);\n  END;\n  IF ok THEN\n    IF (i = l) THEN\n      IF isNeg THEN\n        value := a * (-1);\n      ELSE\n        value := a;\n      END;\n    END;\n  END;\nEND Atoi;\n\n~~~\n\nHere's an example using the procedures.\n\nConverting an integer 1234 to an string \"1234\".\n\n~~~\n\n   x := 1234; s := \"\"; ok := FALSE;\n   Types.Itoa(x, s, ok);\n   IF ok THEN \n     Out.String(s); Out.String(\" = \");\n     Out.Int(x,1);Out.Ln;\n   ELSE\n     Out.String(\"Something went wrong\");Out.Ln;\n   END;\n\n~~~\n\nConverting a string \"56789\" to integer 56789.\n\n~~~\n\n   x := 0; src := \"56789\"; ok := FALSE;\n   Types.Atoi(src, x, ok);\n   IF ok THEN \n     Out.Int(x,1); Out.String(\" = \"); Out.String(s); \n     Out.Ln;\n   ELSE\n     Out.String(\"Something went wrong\");Out.Ln;\n   END;\n\n~~~\n\n\nReferences and resources\n------------------------\n\nImplementations for modules for this article are linked here [Types](./Types.Mod), [TypesTest](./TypesTest.Mod) and [Tests](./Tests.Mod). \n\nExpanded versions of the `Types` module will be available as part of Artemis Project -- [github.com/rsdoiel/Artemis](https://github.com/rsdoiel/Artemis).\n\nPrevious\n--------\n\n- [Revisiting Files](../../11/22/Revisiting-Files.html)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-11-26",
        "keywords": [
          "Oberon",
          "Modules",
          "Types",
          "conversion"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 21,
        "title": "Portable Conversions (Integers)"
      },
      "url": "posts/2021/11/26/Portable-Conversions-Integers.json"
    },
    {
      "content": "\nSetting up FreeDOS 1.3rc4 with Qemu\n-----------------------------------\n\nBy R. S. Doiel, 2021-11-27\n\nIn this article I'm going explore setting up FreeDOS with Qemu\non my venerable Dell 4319 running Raspberry Pi Desktop OS (Debian\nGNU/Linux).  First step is to download FreeDOS \"Live CD\" in the\n1.3 RC4 release. See http://freedos.org/download/ for that.\n\nInstalling Qemu\n---------------\n\nI needed to install Qemu in my laptop. It runs the Raspberry Pi\nDesktop OS (i.e. Debian with Raspberry Pi UI). I choose to install\nthe \"qemu-system\" package since I will likely use qemu for other\nthings besides FreeDOS. The qemu-system package contains all the\nvarious systems I might want to emulate in other projects as well\nas several qemu utilities that are handy.  Here's the full sequence\nof `apt` commands I ran (NOTE: these included making sure my laptop\nwas up to date before I installed qemu-system).\n\n~~~\nsudo apt update\nsudo apt upgrade\nsudo apt install qemu-system\n~~~\n\nNow that I had the software available it was time to figure out\nhow to actually knit things together and run FreeDOS.\n\n\nObtaining FreeDOS 1.3rc4\n------------------------\n\nBefore I get started I create a folder in my home directory\nfor running everything. You can name it what you want\nbut I called mine `FreeDOS_13` and changed into that folder\nfor the work in this article.\n\n~~~\nmkdir FreeDOS_13\ncd FreeDOS_13\n~~~\n\nI initially tried the CD images but ran into odd problems with\nqemu (possibly due to my lack of experience with qemu).\nAfter looking at that various options the USB Full release\nseemed like a good choice. It comes both as an image you can\n\"burn\" to your USB drive both also as a \"vmdk\" file used with\nemulators.\n\n~~~\ncurl -L -O https://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/distributions/1.3/previews/1.3-rc4/FD13-FullUSB.zip\nunzip FD13-FullUSB.zip\n~~~\n\nAt this point you should see the FreeDOS \"vmdk\" file, and \"img\" file and readme files if you list the directory out. I'm going to use the \"vmdk\" file to install FreeDOS on my virtual harddrive freedos.img.\n\n~~~\nls -l \n~~~\n\nPrepping my virtual machine\n---------------------------\n\nA virtual machine is not just a CPU and some random\naccess memory. A machine can include storage devices. For\nthe retro \"DOS\" experience you might looking virtual devices\nfor a \"harddrive\", \"floppy drive\" and \"CD-ROM drive\". \nQemu provides a tool called `qemu-img` for creating \nthese types of virtual devices.\n\nThe basic command is `qemu-img` using the \"create\" option with\nsome parameters.  The parameter are filename and size (see\n`man qemu-img` for gory details). I am calling my virtual\nharddrive \"freedos.img\".  With `qemu-img` the size can be\nspecified with a suffix like \"K\" for kilobytes,  \"M\" for\nmegabytes and \"G\" for gigabytes. DOS is a minimal requirements\na small (by today's standards) 750 megabyte harddrive seems\nappropriate.\n\n~~~\nqemu-img create freedos.img 750M\n~~~\n\nFor my purposes I need a harddrive so I stopped there. You\ncan always create other drives and then restart your virtual\nmachine with the appropriate options.\n\nBring up my FreeDOS box\n-----------------------\n\nNow I was ready to boot from installation media and install\nFreeDOS 1.3rc4 on my virtual harddrive.  For that I\nuse a \"qemu\" command for the system I want to emulate.\nI picked `qemu-system-i386` (see can see\nthe gory details of that command using `man qemu-system-i386`).\nTo install FreeDOS I'm going to boot from the vmdk file \nprovided for the purpose of installation. I then use the FreeDOS\ninstaller to make my freedos.img file bootable with all the\nDOS software I want to play with.\n\n~~~\nqemu-system-i386 \\\n   -m 8 \\\n   -boot menu=on,strict=on \\\n   -hda freedos.img \\\n   -hdb FD13FULL.vmdk\n~~~\n\nAt this point you should see the machine start to boot, press Esc\nwhen prompted and select the second hard drive to boot from (that's\nour vmdk drive).  The drive is then treated like the CD-ROM, follow\nthe programs instructions for installation. You will need to reboot\nseveral times during the process. Until your full installation is\ncomplete you'll need to select the second harddrive as the boot drive\nand continue the installation.\n\nThe first time I successfully installed FreeDOS 1.3rc4 I just installed\nthe plain dos. When I re-did the process I install everything. It\nfills up my 750M virtual harddrive but rc4 includes development tools\nlike a C compiler.  That I think made it worth it.\n\nHere's a Bash script you can use to build your FreeDOS machine.\n\n~~~\n#!/bin/bash\n\nif [ ! -f freedos.img ]; then\n  echo \"Creating fresh Harddisk as drive C:\"\n  qemu-img create freedos.img 750M\nfi\necho \"Booting machine using FD13FULL.vmdk for installation\"\nqemu-system-i386 \\\n    -m 8 \\\n    -boot menu=on,strict=on \\\n    -hda freedos.img \\\n    -hdb FD13FULL.vmdk\n~~~\n\nAnd here is one for running it.\n\n~~~\n#!/bin/bash\n\necho \"Booting machine using freedos.img as drive C:\"\nqemu-system-i386 \\\n    -m 8 \\\n    -boot menu=on,strict=on \\\n    -hda freedos.img\n~~~\n\nNext step, explore FreeDOS and see what I can build.\n\nPutting everything together\n---------------------------\n\nBelow is a [script](run-freedos-1.3rc4.bash) I developed automating either building or running your FreeDOS setup.\n\n~~~\n#!/bin/bash\n\nif [ ! -f FD13FULL.vmdk ]; then\n    if [ ! -f FD13-FullUSB.zip ]; then\n      echo \"Missing FD13FULL.vmdk, downloading FD13-FullUSB.zip\"\n      curl -L -O https://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/distributions/1.3/previews/1.3-rc4/FD13-FullUSB.zip\n    fi\n    echo \"Unzipping FD13-FullUSB.zip\"\n    unzip FD13-FullUSB.zip\nfi\n\nif [ ! -f freedos.img ]; then\n  echo \"Creating fresh Harddisk as drive C:\"\n  qemu-img create freedos.img 750M\n  echo \"Booting machine using FD13FULL.vmdk as drive C:\"\n  echo \"Installing FreeDOS on drive D:\"\n  qemu-system-i386 \\\n      -name FreeDOS \\\n      -machine pc \\\n      -m 32 \\\n      -boot order=c \\\n      -hda FD13FULL.vmdk \\\n      -hdb freedos.img \\\n      -parallel none \\\n      -vga cirrus \\\n      -display gtk\nelse\n  echo \"Booting machine using freedos.img on drive C:\"\n  qemu-system-i386 \\\n      -name FreeDOS \\\n      -machine pc \\\n      -m 32 \\\n      -boot menu=on,strict=on \\\n      -hda freedos.img \\\n      -parallel none \\\n      -vga cirrus \\\n      -display gtk\nfi\n~~~\n\n\nReference material\n------------------\n\nMy inspiration for this was the description of manual install in\nthe FreeDOS book section of the website, [Manual Install](https://www.freedos.org/books/get-started/june14-manual-install.html).\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-11-27",
        "keywords": [
          "FreeDOS",
          "Qemu"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Setting up FreeDOS 1.3rc4 with Qemu"
      },
      "url": "posts/2021/11/27/FreeDOS-1.3rc4-with-Qemu.json"
    },
    {
      "content": "\nNotes on setting up a Mid-2010 Mac Mini\n=======================================\n\nBy R. S. Doiel, 2021-12-18\n\nI acquired a Mid 2010 Mac Mini. It was in good condition but lacked an OS on the hard drive.  I used a previously purchased copy of Mac OS X Snow Leopard to get an OS up and running on the bare hardware. Then it was a longer effort to get the machine into a state with the software I wanted to use on it. My goal was Mac OS X High Sierra, Xcode 10.1 and Mac Ports. The process was straight forward but very time consuming but I think worth it.  I wound up with a nice machine for experimenting with and writing blog posts.\n\nThe setup process was as follows:\n\n1. Install macOS Snow Leopard on the bare disk of the Mac Mini\n2. Install macOS El Capitan on the Mac Mini after manually downloading it from Apple's support site\n3. Run updates indicated by El Capitan\n4. Install macOS High Sierra on the Mac Mini after manually downloading it from the Apple's support site\n5. Run updates indicated by High Sierra \n6. Manually download and install Xcode 10.1 command line tools \n7. Check and run some updates again\n8. Finally install Mac Ports\n\nThe OS installs took about 45 minutes to 90 minutes each. Installing Xcode took about 45 minutes to an hour. Installing Mac Ports was fast as was installing software via Mac Ports.\n\nReference material\n------------------\n\n- Apple support pages that I found helpful\n    - [How to get old versions of macOS](https://support.apple.com/en-us/HT211683)\n    - [How to create a bootable installer for macOS](https://support.apple.com/en-us/HT201372)\n    - [macOS High Sierra - Technical Specifications](https://support.apple.com/kb/SP765?locale=en_US)\n- Wikipedia page on [Xcode](https://en.wikipedia.org/wiki/Xcode) is how I sorta out what version of Xcode I needed to install\n- Links to old macOS and Xcode\n    - Download [Mac OS X El El Capitan](http://updates-http.cdn-apple.com/2019/cert/061-41424-20191024-218af9ec-cf50-4516-9011-228c78eda3d2/InstallMacOSX.dmg)\n    - Download [Mac OX X High Sierra](https://apps.apple.com/us/app/macos-high-sierra/id1246284741?mt=12)\n    - Download [Xcode 10.1](https://developer.apple.com/download/all/?q=xcode), Scroll down the list until you want it.\n        - [Command Line Tools (macOS 10.13) for Xcode 10.1](https://download.developer.apple.com/Developer_Tools/Command_Line_Tools_macOS_10.13_for_Xcode_10.1/Command_Line_Tools_macOS_10.13_for_Xcode_10.1.dmg)\n        - NOTE: There are two version available, you want the version for macOS 10.13 (High Sierra) NOT Mac OS 10.14.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-12-18",
        "keywords": [
          "macOS",
          "High Sierra",
          "Mac Mini"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Notes on setting up a Mid-2010 Mac Mini"
      },
      "url": "posts/2021/12/18/Notes-on-setting-up-a-2010-Mac-Mini.json"
    },
    {
      "content": "\n\nInstalling Golang from Source on RPi-OS for arm64\n==========================================\n\nBy R. S. Doiel, 2022-02-18\n\nThis are my quick notes on installing Golang from source on the Raspberry Pi OS 64 bit.\n\n1. Get a working compiler\n\ta. go to https://go.dev/dl/ and download go1.17.7.linux-arm64.tar.gz\n\tb. untar the tarball in your home directory (it'll unpack to $HOME/go)\n\tc. `cd go/src` and `make.bash`\n2. Move go directory to go1.17\n3. Clone go from GitHub\n4. Compile with the downloaded compiler\n\ta. `cd go/src`\n\tb. `env GOROOT_BOOTSTRAP=$HOME/go1.17 ./make.bash`\n\tc. Make sure `$HOME/go/bin` is in the path\n\td. `go version`\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2022, R. S. Doiel",
        "date": "2022-02-18",
        "keywords": [
          "raspberry pi",
          "Raspberry Pi OS",
          "arm64"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 1,
        "series": "Raspberry Pi",
        "title": "Installing Golang from source on RPi-OS for arm64"
      },
      "url": "posts/2022/02/18/Installing-Go-from-Source-RPiOS-arm64.json"
    },
    {
      "content": "\nArtemis Project Status, 2022\n============================\n\nIt's been a while since I wrote an Oberon-07 post and even longer since I've worked on Artemis. Am I done with Oberon-07 and abandoning Artemis?  No. Life happens and free time to just hasn't been available. I don't know when that will change.\n\nWhat's the path forward?\n------------------------\n\nSince I plan to continue working Artemis I need to find a way forward in much less available time. Time to understand some of my constraints. \n\n1. I work on a variety of machines, OBNC is the only compiler I've consistently been able to use across all my machines\n2. Porting between compilers takes energy and time, and those compilers don't work across all my machines\n3. When I write Oberon-07 code I quickly hit a wall for the things I want to do, this is what original inspired Artemis, so there is still a need for a collection of modules\n4. Oberon/Oberon-07 on Wirth RISC virtual machine is not sufficient for my development needs\n5. A2, while very impressive, isn't working for me either (mostly because I need to work on ARM CPUs)\n\nThese constraints imply Artemis is currently too broadly scoped. I think I need to focus on what works in OBNC for now. Once I have a clear set of modules then I can revisit portability to other compilers.\n\nWhat modules do I think I need? If I look at my person projects I tend to work allot with text, often structured text (e.g. XML, JSON, CSV). I also tend to be working with network services. Occasionally I need to interact with database (e.g. SQLite3, MySQL, Postgres).  Artemis should provide modules to make it easy to write code in Oberon-07 that works in those areas. Some of that I can do by wrapping existing C libraries. Some I can simply write from scratch in Oberon-07 (e.g. a JSON encoder/decoder). That's going to me my focus as my hobby time becomes available and then.\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2022, R. S. Doiel",
        "date": "2022-07-27",
        "keywords": [
          "Oberon",
          "Oberon-07",
          "Artemis"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 22,
        "series": "Mostly Oberon",
        "title": "Artemis Project Status, 2022"
      },
      "url": "posts/2022/07/27/Artemis-Status-Summer-2022.json"
    },
    {
      "content": "\nTurbo Oberon, the dream\n=======================\n\nby R. S. Doiel, 2022-07-30\n\nSometimes I have odd dreams and that was true last night through early this morning. The dream was set in the future. I was already retired. It was a dream about \"Turbo Oberon\".\n\n\"Turbo Oberon\" was an Oberon language. The language compiler was named \"TO\" in my dream. A module's file extension was \".tom\", in honor of Tom Lopez (Meatball Fulton) of ZBS. There were allot of ZBS references in the dream.\n\n\"TO\" was very much a language in the Oberon-07 tradition with minor extensions when it came to bringing in modules. It allowed for a multi path search for module names. You could also express a Module import as a string allowing providing paths to the imported module.\n\nCompilation was similar to Go. Cross compilation was available out of the box by setting a few environment variables. I remember answering questions about the language and its evolution. I remember mentioning in the conversation about how I thought Go felling into the trap of complexity like Rust or C/C++ before it. The turning point for Go was generics. Complexity was the siren song to be resisted in \"Turbo Oberon\". Complexity is seductive to language designers and implementers. I was only an implementer.\n\nEvolution wise \"TO\" was built initially on the Go tool chain. As a result it featured easily cross-compiled binaries and had a rich standard set of Modules like Go but also included portable libraries for implementing graphic user interfaces. \"Turbo Oberon\" evolved as a conversation between Go and the clean simplicity of Oberon-07. Two example applications \"shipped\" with the \"TO\" compiler. They were an Oberon like Operating System (stand alone and hosted) and a Turbo Pascal like IDE. The IDE was called \"toe\" for Turbo Oberon Editor. I don't remember the name of the OS implementation but it might have been \"toos\". I remember \"TO\" caused problems for search engines and catalog systems.\n\nI remember remarking in the dream that programming in \"Turbo Oberon\" was a little like returning to my roots when I first learned to program in Turbo Pascal. Except I could run my programs regardless of the operating system or CPU architecture. \"\"TO\" compiler supported cross compilation for Unix, macOS, Windows on ARM, Intel, RISC-V. The targets were inherited from Go implementation roots.\n\nIn my dream I remember forking Go 1.18 and first replacing the front end of the compiler. I remember it was a challenge understanding the implementation and generate a Go compatible AST. The mapping between Oberon-07 and Go had its challenges. I remember first sticking to a strict Oberon-07 compiler targeting POSIX before enhancing module imports. I remember several failed attempts at getting module imports \"right\". I remember being on the fence about a map data type and going with a Maps module.  I don't remember how introspection worked but saying it was based on an ETH paper for Oberon 2.  I remember the compiler, like Go, eventually became self hosting. It supported a comments based DSL to annotating RECORD types making encoding and decoding convenient, an influence of Go and it's tool chain.\n\nI believe the \"Turbo Oberon Editor\" came first and that was followed by the operating system implementation.\n\nI remember talking about a book that influenced me called, \"Operating Systems through compilers\" but don't know who wrote it. I remember a discussion about the debt owed to Prof. Wirth. I remember that the book showed how once you really understood building the compile you could then build the OS. There was a joke riffing on the old Lisp joke but rephrased, \"all applications evolve not to a Lisp but to an embedded OS\".\n\nIt was a pleasant dream, in the dream I was older and already retired but still writing \"TO\" code and having fun with computers. I remember a closing video shot showing me typing away at what looked like the old Turbo Pascal IDE. As Mojo Sam said in **Somewhere Next Door to Reality**, \"it was a sorta a retro future\".\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "byline": "R. S. Doiel",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2022-07-30",
        "keywords": [
          "Oberon",
          "Wirth",
          "ETH",
          "dreams",
          "compilers",
          "operating systems"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Turbo Oberon, the dream"
      },
      "url": "posts/2022/07/30/Turbo-Oberon.json"
    }
  ]
}