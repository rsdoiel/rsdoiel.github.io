{
  "page": 1,
  "total_pages": 1,
  "has_more": false,
  "next_page": null,
  "values": [
    {
      "content": "\n\nOPML to Markdown and back\n=========================\n\nBy R. S. Doiel 2016-05-28\n\n## Overview\n\nI wrote a Go language package to sort [OPML](http://dev.opml.org/spec2.html) outlines. \nI wrote this because my preferred [feed reader ](http://goread.io) supports manual \nsorting but not automatic alpha sorting by the _outline_ element's _text_ attribute. \n\n## Observations\n\nOut of the box the OPML 2 Spec provides attributes indicating inclusion of other OPML files,\nscripts, basic metadata (create, modified, authorship), and even directory structures.\n\n[Fargo](http://fargo.io) allows user defined attributes to be applied to the _outline_ \nelement in OPML. This could be used in support some of the \n[Scrivener](https://www.literatureandlatte.com/scrivener.php)\nfeatures I miss such as describing how to render a project to various formats such as\nrtf, pdf, ePub, web pages or even [Final Draft fdx](https://www.finaldraft.com/) files.\n\nI write allot of Markdown formatted text.  Markdown is simple to index, \nsearch and convert into useful formats. Markdown is not good at expressing more\ncomplex structures such as metadata. Website generators that use markdown often\nrequire a preamble or _front matter_ in the markdown to provide any metadata. This\nleaves your document head cluttered and less human readable.\n\nAnother approach is to include a parallel document with the metadata.  It occurred to me \nthat an OPML file could easily hold that metadata. It can even hold Markdown content.\nThe trouble with OPML is that it is not quick to edit by hand.\n\n    Is there a round trip semantic mapping between OPML and Markdown?\n\n\n## Germination of an idea\n\nEntering a web link in Fargo the link is URL encoded and saved in the _text_ attribute of the \n_outline_ element.\n\nThe source view of a web links in Fargo's _outline_ element looks like\n\n```OPML\n    <outline text=\"&gt; href=&quot;http://example.org&quot;&lt;My example.org&gt;/a&lt;\" />\n```\n\nThat _outline_ element might render in Markdown as\n\n```\n    + [My element.org](http://example.org)\n```\n\nThe steps to create the Markdown view are simple\n\n1. URL decode the _text_ attribute\n2. Convert HTML to Markdown\n\nMaking a round trip could be done by\n\n3. Convert Markdown into HTML\n4. For each _li_ element covert to an _outline_ element URL encoding the inner HTML of the _li_\n\nSo far so good. What about something more complex?\n\n\nHere's an _outline_ element example from http://hosting.opml.org/dave/spec/directory.opml \n\n```OPML\n    <outline text=\"Scripting News sites\" created=\"Sun, 16 Oct 2005 05:56:10 GMT\" type=\"link\" url=\"http://hosting.opml.org/dave/mySites.opml\"/>\n```\n\nTo me that should look like \n\n```\n    + [Scripting News Sites](http://hosting.opml.org/dave/mySites.opml)\n```\n\nWhat about the _created_ attribute? Could we render this case as an additional set of anchors using data uri?\n\nThis suggest a rule like\n\n+ if the _text_ attribute contains HTML markup\n    + URL decode into HTML\n    + Convert HTML to Markdown\n+ else render attributes as additional anchors using data URI\n\nThis might work as follows. \n\n```OPML\n    <outline text=\"Scripting News sites\" \n        created=\"Sun, 16 Oct 2005 05:56:10 GMT\" \n        type=\"link\" \n        url=\"http://hosting.opml.org/dave/mySites.opml\"/>\n```\n\nWould become \n\n```Markdown\n    + [Scripting News Sites](http://hosting.opml.org/dave/mySites.opml) [type](data:text/plain;link) [created](data:text/date;Sun, 16 Oct 2005 05:56:10 GMT)\n```\n\nIn HTML this would look like\n\n```HTML\n    <li><a href=\"http://histing.opml.org/dave/mySites.opml\">Scripting News Sites</a>\n        <a href=\"data:text/plain;link\">type</a>\n        <a href=\"data:text/date;Sun, 16 Oct 2005 05:56:10 GMT\">created</a></li>\n```\n\n### Markdown to OPML\n\nComing back to OPML from Markdown then becomes\n\n+ Convert Markdown to HTML\n+ For each _li_ element inspect anchors, \n    + if anchors contain data URI then map _outline_ element\n    + else URL encode and embed in _outline_ _text_ attribute\n\nIs this viable? Does it have any advantages?\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2016, R. S. Doiel",
        "date": "2016-05-28",
        "keywords": [
          "golang",
          "opml",
          "markdown"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "OPML to Markdown and back"
      },
      "url": "posts/2016/05/28/OPML-to-Markdown-and-back.json"
    },
    {
      "content": "\n\nOberon to Markdown\n==================\n\nThis is the twelfth post in the [Mostly Oberon](https://rsdoiel.github.io/blog/2020/04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\nA nice feature of Oberon\n------------------------\n\nOberon source code has a very nice property in that anything\nafter the closing end statement is ignored by the compiler.\nThis makes it a nice place to write documentation, program\nnotes and other ideas.\n\nI've gotten in the habit of writing up program docs and\nnotes there. When I prep to make a web document I used to\ncopy the source file, doing a cut and paste to re-order\nthe module code to the bottom of the document. I'd follow\nthat with adding headers and code fences. Not hard but\ntedious. Of course if I changed the source code I'd also\nhave to do another cut and paste edit. This program,\n`ObnToMd.Mod` automates that process.\n\nProgram Documentation\n---------------------\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n  ObnToMd\n\nFUNCTION\n\n  This is a simple program that reads Oberon modules\n  from standard in and re-renders that to standard output\n  such that it is suitable to process with Pandoc or other\n  text processing system.\n\nEXAMPLE\n\n  Read the source for this program and render a file\n  called \"blog-post.md\". Use Pandoc to render HTML.\n\n    ObnToMd <ObnToMd.Mod > blog-post.md\n    pandoc -s --metadata title=\"Blog Post\" \\\n        blog-post.md >blog-post.html\n\nBUGS\n\n  It uses a naive line analysis to identify the module\n  name and then the end of module statement. Might be\n  tripped up by comments containing the same strings.\n  The temporary file created is called \"o2m.tmp\" and\n  this filename could potentially conflict with another\n  file.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\nSource code for **ObnToMd.Mod**\n-------------------------------\n\n~~~\n\n(* ObnToMd.Mod - an simple filter process for reading\nan Oberon-07 module source file and rendering a markdown\nfriendly output suitable for piping into Pandoc. The\nfilter reads from standard input and writes to standard\noutput and makes use of a temp file name o2m.tmp which\nit removes after successful rendering.\n\n@Author R. S. Doiel, <rsdoiel@gmail.com>\ncopyright (c) 2020, all rights reserved.\nReleased under the BSD 2-clause license\nSee: https://opensource.org/licenses/BSD-2-Clause\n*)\nMODULE ObnToMd;\n  IMPORT In, Out, Files, Strings;\n\nCONST\n  MAXLENGTH = 1024;\n  LF = CHR(10);\n\nVAR\n  endOfLine : ARRAY 2 OF CHAR;\n\n(*\n * Helper methods\n *)\nPROCEDURE GenTempName(prefix, suffix : ARRAY OF CHAR; VAR name : ARRAY OF CHAR);\nBEGIN\n  name := \"\";\n  Strings.Append(prefix, name);\n  Strings.Append(\".\", name);\n  Strings.Append(suffix, name);\nEND GenTempName;\n\nPROCEDURE GenTempFile(name : ARRAY OF CHAR; VAR r : Files.Rider; VAR f : Files.File);\nBEGIN\n  f := Files.New(name);\n  IF f = NIL THEN\n    Out.String(\"ERROR: can't create \");Out.String(name);Out.Ln();\n    ASSERT(FALSE);\n  END;\n  Files.Register(f);\n  Files.Set(r, f, 0);\nEND GenTempFile;\n\n\nPROCEDURE StartsWith(target, source : ARRAY OF CHAR) : BOOLEAN;\n  VAR res : BOOLEAN;\nBEGIN\n  IF Strings.Pos(target, source, 0) > -1 THEN\n    res := TRUE;\n  ELSE\n    res := FALSE;\n  END;\n  RETURN res\nEND StartsWith;\n\nPROCEDURE ClearString(VAR s : ARRAY OF CHAR);\n  VAR i : INTEGER;\nBEGIN\n  FOR i := 0 TO LEN(s) - 1 DO\n    s[i] := 0X;\n  END;\nEND ClearString;\n\n\nPROCEDURE ProcessModuleDef(VAR r : Files.Rider; VAR modName : ARRAY OF CHAR);\n  VAR\n    line, endStmt : ARRAY MAXLENGTH OF CHAR;\n    start, end : INTEGER;\nBEGIN\n  line := \"\";\n  endStmt := \"\";\n  modName := \"\";\n  (* Find the name of the module and calc the \"END {NAME}.\" statement *)\n  REPEAT\n    ClearString(line);\n    In.Line(line);\n    IF In.Done THEN\n      Files.WriteString(r, line); Files.WriteString(r, endOfLine);\n      (* When `MODULE {NAME};` is encountered extract the module name *)\n      IF StartsWith(\"MODULE \", line) THEN\n        start := 7;\n        end := Strings.Pos(\";\", line, 0);\n        IF (end > -1) & (end > start) THEN\n            Strings.Extract(line, start, end - start, modName);\n            endStmt := \"END \";\n            Strings.Append(modName, endStmt);\n            Strings.Append(\".\", endStmt);\n        END;\n      END;\n    END;\n  UNTIL (In.Done # TRUE) OR (endStmt # \"\");\n\n  (* When `END {NAME}.` is encountered  stop writing tmp file *)\n  REPEAT\n    In.Line(line);\n    IF In.Done THEN\n      Files.WriteString(r, line); Files.WriteString(r, endOfLine);\n    END;\n  UNTIL (In.Done # TRUE) OR StartsWith(endStmt, line);\nEND ProcessModuleDef;\n\nPROCEDURE WriteModuleDef(name : ARRAY OF CHAR; VAR r : Files.Rider; VAR f : Files.File);\n  VAR s : ARRAY MAXLENGTH OF CHAR; res : INTEGER;\nBEGIN\n  Files.Set(r, f, 0);\n  REPEAT\n    Files.ReadString(r, s);\n    IF r.eof # TRUE THEN\n      Out.String(s);\n    END;\n  UNTIL r.eof;\n  Files.Close(f);\n  Files.Delete(name, res);\nEND WriteModuleDef;\n\n\nPROCEDURE OberonToMarkdown();\nVAR\n  tmpName, modName, line : ARRAY MAXLENGTH OF CHAR;\n  f : Files.File;\n  r : Files.Rider;\n  i : INTEGER;\nBEGIN\n  tmpName := \"\"; modName := \"\";  line := \"\";\n  (* Open temp file *)\n  GenTempName(\"o2m\", \"tmp\", tmpName);\n  GenTempFile(tmpName, r, f);\n\n  (* Read the Oberon source from standard input echo the lines tmp file *)\n  ProcessModuleDef(r, modName);\n\n  (* Write remainder of file to standard out *)\n  REPEAT\n    In.Line(line);\n    IF In.Done THEN\n      Out.String(line);Out.Ln();\n    END;\n  UNTIL In.Done # TRUE;\n\n  (* Write two new lines *)\n  Out.Ln(); Out.Ln();\n  (* Write heading `Source code for {NAME}` *)\n  ClearString(line);\n  line := \"Source code for **\";\n  Strings.Append(modName, line);\n  Strings.Append(\".Mod**\", line);\n  Out.String(line); Out.Ln();\n  FOR i := 0 TO Strings.Length(line) - 1 DO\n    Out.String(\"-\");\n  END;\n  Out.Ln();\n  (* Write code fence *)\n  Out.Ln();Out.String(\"~~~\");Out.Ln();\n  (* Reset rider to top of tmp file\n     Write temp file to standard out\n     cleanup demp file *)\n  WriteModuleDef(tmpName, r, f);\n  (* Write code fence *)\n  Out.Ln();Out.String(\"~~~\");Out.Ln();\n  (* Write tailing line and exit procedure *)\n  Out.Ln();\nEND OberonToMarkdown;\n\nBEGIN\n  endOfLine[0] := LF;\n  endOfLine[1] := 0X;\n  OberonToMarkdown();\nEND ObnToMd.\n\n~~~\n\n### Next, Previous\n\n+ Next [Assembling Pages](../../10/19/Assemble-pages.html)\n+ Previous [Portable Oberon-07](../../08/15/Portable-Oberon-07.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-10-03",
        "keywords": [
          "Oberon",
          "portable",
          "markdown",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 12,
        "series": "Mostly Oberon",
        "title": "Oberon to Markdown"
      },
      "url": "posts/2020/10/03/Oberon-to-markdown.json"
    },
    {
      "content": "\n\nAssembling pages\n================\n\nThis is the thirteenth post in the [Mostly Oberon](https://rsdoiel.github.io/blog/2020/04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\nPandoc and JSON\n---------------\n\nI use [Pandoc](https://pandoc.org) to process Markdown documents. I like to keep my\nfront matter in JSON rather than Pandoc's YAML. Fortunately Pandoc\ndoes support working with JSON as a metadata file include. Normally I would\nmanually split the JSON front matter and the rest of the markup into two\nseparate files, then process with Pandoc and other tooling like\n[LunrJS](https://lunrjs.com). [AssemblePage](AssemblePage.Mod) automates this\nprocess.\n\nExample shell usage:\n\n~~~\n\n   AssemblePage MyText.txt \\\n      metadata=document.json \\\n      document=document.md\n   pandoc --from markdown --to html \\\n      --metadata-file document.json \\\n      --standalone \\\n      document.md >MyText.html\n\n~~~\n\nSource code for **AssemblePage.Mod**\n------------------------------------\n\n~~~\n\nMODULE AssemblePage;\n  IMPORT Out, Strings, Files, Args := extArgs;\n\nVAR\n  srcName, metaName, docName : ARRAY 1024 OF CHAR;\n\n(* FrontMatter takes a \"read\" Rider, r, and a \"write\" Rider \"w\".\nIf the first character read by r is an opening curly bracket\n(the start of the front matter) it writes it out with w, until\nit finds a matching closing curly bracket or the file ends. *)\nPROCEDURE FrontMatter*(VAR r : Files.Rider; VAR w : Files.Rider);\n  VAR c : BYTE; cCnt : INTEGER;\nBEGIN\n  (* Scan for opening JSON front matter *)\n  cCnt := 0;\n  REPEAT\n    Files.Read(r, c);\n    IF r.eof = FALSE THEN\n      IF c = ORD(\"{\") THEN\n        cCnt := cCnt + 1;\n      ELSIF c = ORD(\"}\") THEN\n        cCnt := cCnt - 1;\n      END;\n      Files.Write(w, c);\n    END;\n  UNTIL (r.eof = TRUE) OR (cCnt = 0);\n  IF cCnt # 0 THEN\n    Out.String(\"ERROR: mis matched '{' and '}' in front matter\");\n    ASSERT(FALSE);\n  END;\nEND FrontMatter;\n\n(* CopyIO copies the characters from a \"read\" Rider to a \"write\" Rider *)\nPROCEDURE CopyIO*(VAR r : Files.Rider; VAR w: Files.Rider);\n  VAR c : BYTE;\nBEGIN\n  REPEAT\n    Files.Read(r, c);\n    IF r.eof = FALSE THEN\n      Files.Write(w, c);\n    END;\n  UNTIL r.eof = TRUE;\nEND CopyIO;\n\nPROCEDURE ProcessParameters(VAR sName, mName, dName : ARRAY OF CHAR);\n  VAR\n    arg : ARRAY 1024 OF CHAR;\n    i, res : INTEGER;\nBEGIN\n  mName := \"document.json\";\n  dName := \"document.txt\";\n  arg := \"\";\n  FOR i := 0 TO (Args.count - 1) DO\n    Args.Get(i, arg, res);\n    IF Strings.Pos(\"metadata=\", arg, 0) = 0 THEN\n      Strings.Extract(arg, 9, Strings.Length(arg), mName);\n    ELSIF Strings.Pos(\"document=\", arg, 0) = 0 THEN\n      Strings.Extract(arg, 9, Strings.Length(arg), dName);\n    ELSE\n      Strings.Extract(arg, 0, Strings.Length(arg), sName);\n    END;\n  END;\nEND ProcessParameters;\n\nPROCEDURE AssemblePage(srcName, metaName, docName : ARRAY OF CHAR);\nVAR\n  src, meta, doc : Files.File;\n  reader, writer : Files.Rider;\nBEGIN\n  src := Files.Old(srcName);\n  IF src # NIL THEN\n    Files.Set(reader, src, 0);\n    IF metaName # \"\" THEN\n      meta := Files.New(metaName);\n      Files.Register(meta);\n      Files.Set(writer, meta, 0);\n      FrontMatter(reader, writer);\n      Files.Close(meta);\n    END;\n    IF docName # \"\" THEN\n      doc := Files.New(docName);\n      Files.Register(doc);\n      Files.Set(writer, doc, 0);\n      CopyIO(reader, writer);\n      Files.Close(doc);\n    END;\n  ELSE\n    Out.String(\"ERROR: Could not read \");Out.String(srcName);Out.Ln();\n    ASSERT(FALSE);\n  END;\n  Files.Close(src);\nEND AssemblePage;\n\nBEGIN\n  ProcessParameters(srcName, metaName, docName);\n  AssemblePage(srcName, metaName, docName);\nEND AssemblePage.\n\n~~~\n\n### Next, Previous\n\n+ Next [Dates & Clock](../../11/27/Dates-and-Clock.html)\n+ Previous [Oberon To Markdown](../../10/03/Oberon-to-markdown.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-10-19",
        "keywords": [
          "Oberon-07",
          "portable",
          "markdown",
          "pandoc",
          "frontmatter"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 13,
        "series": "Mostly Oberon",
        "title": "Assembling Pages"
      },
      "url": "posts/2020/10/19/Assemble-pages.json"
    }
  ]
}