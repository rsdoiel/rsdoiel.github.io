{
  "page": 1,
  "total_pages": 1,
  "has_more": false,
  "next_page": null,
  "values": [
    {
      "content": "\nBeyond Oakwood, Modules and Aliases\n===================================\n\nBy R. S. Doiel, 2021-05-16\n\nOakwood is the name used to refer to an early Oberon language\nstandardization effort in the late 20th century.  It's the name\nof a hotel where compiler developers and the creators of Oberon\nand the Oberon System met to discuss compatibility. The lasting\ninfluence on the 21st century Oberon-07 language can be seen\nin the standard set of modules shipped with POSIX based Oberon-07\ncompilers like\n[OBNC](https://miasap.se/obnc/), [Vishap Oberon Compiler](https://github.com/vishaps/voc) and the \n[Oxford Oberon Compiler](http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler).\n\nThe Oakwood guidelines described a minimum expectation for\na standard set of modules to be shipped with compilers.\nThe modules themselves are minimalist in implementation.\nMinimalism can assist in easing the learning curve\nand encouraging a deeper understanding of how things work.\n\nThe Oberon-07 language is smaller than the original Oberon language\nand the many dialects that followed.  I think of Oberon-07 as the\ndistillation of all previous innovation.  It embodies the\nspirit of \"Simple but not simpler than necessary\". Minimalism is\na fit description of the adaptions of the Oakwood modules for \nOberon-07 in the POSIX environment.\n\n\nWhen simple is too simple\n-------------------------\n\nSometimes I want more than the minimalist module.  A good example\nis standard [Strings](https://miasap.se/obnc/obncdoc/basic/Strings.def.html)\nmodule.  Thankfully you can augment the standard modules with your own.\nIf you are creative you can even create a drop in replacement.\nThis is what I wound up doing with my \"Chars\" module.\n\nIn the spirit of \"Simple but no simpler\" I originally kept Chars \nvery minimal. I only implemented what I missed most from Strings.\nI got down to a handful of functions for testing characters,\ntesting prefixes and suffixes as well as trim procedures. It was\nall I included in `Chars` was until recently.\n\nOver the last couple of weeks I have been reviewing my own Oberon-07\ncode in my personal projects.  I came to understand that\nin my quest for minimalism I had fallen for \"too simple\".\nThis was evidenced by two observations.  Everywhere I had used\nthe `Strings` module I also included `Chars`. It was boiler plate.\nThe IMPORT sequence was invariably a form of --\n\n~~~\n    IMPORT Strings, Chars, ....\n~~~\n\nOn top of that I found it distracting to see `Chars.*` and `Strings.*`\ncomingled and operating on the same data. If felt sub optimal. It\nfelt baroque. That got me thinking.\n\n> What if Chars included the functionality of Strings?\n\nI see two advantages to merging Chars and Strings. First I\nonly need to include one module instead of two. The second\nis my code becomes more readable. I think that is because\nexpanding Strings to include new procedures and constants allows\nfor both the familiar and for evolution. The problem is renaming\n`Chars.Mod` to `Strings.Mod` implies I'm supplying the standard\n`Strings` module. Fortunately Oberon provides a mechanism for\nsolving this problem. The solution Oberon provides is to allow\nmodule names to be aliased.  Look at my new import statement.\n\n~~~\n    IMPORT Strings := Chars, ...\n~~~\n\nIt is still minimal but at the same time shows `Chars` is going\nto be referenced as `Strings`. By implication `Chars` provides\nthe functionality `Strings` but is not the same as `Strings`.\nMy code reads nicely.  I don't loose the provenance of what\nis being referred to by `Strings` because it is clearly \nprovided in the IMPORT statement.\n\nIn my new [implementation](Chars.Mod) I support all the standard\nprocedures you'd find in an Oakwood compliant `Strings`.  I've\nincluded additional additional constants and functional procedures\nlike `StartsWith()` and `EndsWith()` and a complement of trim\nprocedures like `TrimLeft()`, `TrimRight()`, `Trim()`.\n`TrimPrefix()`, and `TrimSuffix()`.\n\nHere's how `Chars` definition stacks up as rendered by the\nobncdoc tool.\n\n```\n(* Chars.Mod - A module for working with CHAR and \n   ARRAY OF CHAR data types.\n\nCopyright (C) 2020, 2021 R. S. Doiel <rsdoiel@gmail.com>\nThis Source Code Form is subject to the terms of the\nMozilla PublicLicense, v. 2.0. If a copy of the MPL was\nnot distributed with thisfile, You can obtain one at\nhttp://mozilla.org/MPL/2.0/. *)\nDEFINITION Chars;\n\n(*\nChars.Mod provides a modern set of procedures for working\nwith CHAR and ARRAY OF CHAR. It is a drop in replacement\nfor the Oakwood definition \nStrings module.\n\nExample:\n\n    IMPORT Strings := Chars;\n\nYou now have a Strings compatible Chars module plus all the Chars\nextra accessible through the module alias of Strings. *)\n\nCONST\n  (* MAXSTR is exported so we can use a common\n     max string size easily *)\n  MAXSTR = 1024;\n  (* Character constants *)\n  EOT = 0X;\n  TAB = 9X;\n  LF  = 10X;\n  FF  = 11X;\n  CR  = 13X;\n  SPACE = \" \";\n  DASH  = \"-\";\n  LODASH = \"_\";\n  CARET = \"^\";\n  TILDE = \"~\";\n  QUOTE = 34X;\n\n  (* Constants commonly used characters to quote things.  *)\n  QUOT   = 34X;\n  AMP    = \"&\";\n  APOS   = \"'\";\n  LPAR   = \")\";\n  RPAR   = \"(\";\n  AST    = \"*\";\n  LT     = \"<\";\n  EQUALS = \"=\";\n  GT     = \">\";\n  LBRACK = \"[\";\n  RBRACK = \"]\";\n  LBRACE = \"}\";\n  RBRACE = \"{\";\n\nVAR\n  (* common cutsets, ideally these would be constants *)\n  spaces : ARRAY 6 OF CHAR;\n  punctuation : ARRAY 33 OF CHAR;\n\n(* InRange -- given a character to check and an inclusive range of\n    characters in the ASCII character set. Compare the ordinal values\n    for inclusively. Return TRUE if in range FALSE otherwise. *)\nPROCEDURE InRange(c, lower, upper : CHAR) : BOOLEAN;\n\n(* InCharList checks if character c is in list of chars *)\nPROCEDURE InCharList(c : CHAR; list : ARRAY OF CHAR) : BOOLEAN;\n\n(* IsUpper return true if the character is an upper case letter *)\nPROCEDURE IsUpper(c : CHAR) : BOOLEAN;\n\n(* IsLower return true if the character is a lower case letter *)\nPROCEDURE IsLower(c : CHAR) : BOOLEAN;\n\n(* IsDigit return true if the character in the range of \"0\" to \"9\" *)\nPROCEDURE IsDigit(c : CHAR) : BOOLEAN;\n\n(* IsAlpha return true is character is either upper or lower case letter *)\nPROCEDURE IsAlpha(c : CHAR) : BOOLEAN;\n\n(* IsAlphaNum return true is IsAlpha or IsDigit *)\nPROCEDURE IsAlphaNum (c : CHAR) : BOOLEAN;\n\n(* IsSpace returns TRUE if the char is a space, tab, carriage return or line feed *)\nPROCEDURE IsSpace(c : CHAR) : BOOLEAN;\n\n(* IsPunctuation returns TRUE if the char is a non-alpha non-numeral *)\nPROCEDURE IsPunctuation(c : CHAR) : BOOLEAN;\n\n(* Length returns the length of an ARRAY OF CHAR from zero to first\n    0X encountered. [Oakwood compatible] *)\nPROCEDURE Length(source : ARRAY OF CHAR) : INTEGER;\n\n(* Insert inserts a source ARRAY OF CHAR into a destination \n    ARRAY OF CHAR maintaining a trailing 0X and truncating if\n    necessary [Oakwood compatible] *)\nPROCEDURE Insert(source : ARRAY OF CHAR; pos : INTEGER; VAR dest : ARRAY OF CHAR);\n\n(* AppendChar - this copies the char and appends it to\n    the destination. Returns FALSE if append fails. *)\nPROCEDURE AppendChar(c : CHAR; VAR dest : ARRAY OF CHAR) : BOOLEAN;\n\n(* Append - copy the contents of source ARRAY OF CHAR to end of\n    dest ARRAY OF CHAR. [Oakwood complatible] *)\nPROCEDURE Append(source : ARRAY OF CHAR; VAR dest : ARRAY OF CHAR);\n\n(* Delete removes n number of characters starting at pos in an\n    ARRAY OF CHAR. [Oakwood complatible] *)\nPROCEDURE Delete(VAR source : ARRAY OF CHAR; pos, n : INTEGER);\n\n(* Replace replaces the characters starting at pos with the\n    source ARRAY OF CHAR overwriting the characters in dest\n    ARRAY OF CHAR. Replace will enforce a terminating 0X as\n    needed. [Oakwood compatible] *)\nPROCEDURE Replace(source : ARRAY OF CHAR; pos : INTEGER; VAR dest : ARRAY OF CHAR);\n\n(* Extract copies out a substring from an ARRAY OF CHAR into a dest\n    ARRAY OF CHAR starting at pos and for n characters\n    [Oakwood compatible] *)\nPROCEDURE Extract(source : ARRAY OF CHAR; pos, n : INTEGER; VAR dest : ARRAY OF CHAR);\n\n(* Pos returns the position of the first occurrence of a pattern\n    ARRAY OF CHAR starting at pos in a source ARRAY OF CHAR. If\n    pattern is not found then it returns -1 *)\nPROCEDURE Pos(pattern, source : ARRAY OF CHAR; pos : INTEGER) : INTEGER;\n\n(* Cap replaces each lower case letter within source by an uppercase one *)\nPROCEDURE Cap(VAR source : ARRAY OF CHAR);\n\n(* Equal - compares two ARRAY OF CHAR and returns TRUE\n    if the characters match up to the end of string,\n    FALSE otherwise. *)\nPROCEDURE Equal(a : ARRAY OF CHAR; b : ARRAY OF CHAR) : BOOLEAN;\n\n(* StartsWith - check to see of a prefix starts an ARRAY OF CHAR *)\nPROCEDURE StartsWith(prefix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR) : BOOLEAN;\n\n(* EndsWith - check to see of a prefix starts an ARRAY OF CHAR *)\nPROCEDURE EndsWith(suffix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR) : BOOLEAN;\n\n(* Clear - resets all cells of an ARRAY OF CHAR to 0X *)\nPROCEDURE Clear(VAR a : ARRAY OF CHAR);\n\n(* Shift returns the first character of an ARRAY OF CHAR and shifts the\n    remaining elements left appending an extra 0X if necessary *)\nPROCEDURE Shift(VAR source : ARRAY OF CHAR) : CHAR;\n\n(* Pop returns the last non-OX element of an ARRAY OF CHAR replacing\n    it with an OX *)\nPROCEDURE Pop(VAR source : ARRAY OF CHAR) : CHAR;\n\n(* TrimLeft - remove the leading characters in cutset\n    from an ARRAY OF CHAR *)\nPROCEDURE TrimLeft(cutset : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimRight - remove tailing characters in cutset from\n    an ARRAY OF CHAR *)\nPROCEDURE TrimRight(cutset : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* Trim - remove leading and trailing characters in cutset\n    from an ARRAY OF CHAR *)\nPROCEDURE Trim(cutset : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimLeftSpace - remove leading spaces from an ARRAY OF CHAR *)\nPROCEDURE TrimLeftSpace(VAR source : ARRAY OF CHAR);\n\n(* TrimRightSpace - remove the trailing spaces from an ARRAY OF CHAR *)\nPROCEDURE TrimRightSpace(VAR source : ARRAY OF CHAR);\n\n(* TrimSpace - remove leading and trailing space CHARS from an \n    ARRAY OF CHAR *)\nPROCEDURE TrimSpace(VAR source : ARRAY OF CHAR);\n\n(* TrimPrefix - remove a prefix ARRAY OF CHAR from a target \n    ARRAY OF CHAR *)\nPROCEDURE TrimPrefix(prefix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimSuffix - remove a suffix ARRAY OF CHAR from a target\n    ARRAY OF CHAR *)\nPROCEDURE TrimSuffix(suffix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimString - remove cutString from beginning and end of ARRAY OF CHAR *)\nPROCEDURE TrimString(cutString : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\nEND Chars.\n```\n\nMy new `Chars` module has proven to be both more readable\nand more focused in my projects. I get all the functionality\nof `Strings` and the additional functionality I need in my own\nprojects. This improved the focus in my other modules and I think\nmaintained the spirit of \"Simple but not simpler\".\n\n+ [Chars.Mod](Chars.Mod)\n\nUPDATE: The current version of my `Chars` module can be found in \nmy [Artemis](https://github.com/rsdoiel/Artemis) repository. The\nrepository includes additional code and modules suitable to working\nwith Oberon-07 in a POSIX envinronment.\n\n### Next, Previous\n\n+ Next [Combining Oberon-07 with C using Obc-3](/blog/2021/06/14/Combining-Oberon-07-with-C-using-Obc-3.html)\n+ Prev [Dates & Clocks](/blog/2020/11/27/Dates-and-Clock.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-05-16",
        "keywords": [
          "Oberon",
          "Modules",
          "Oakwood",
          "Strings",
          "Chars"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 18,
        "title": "Beyond Oakwood, Modules and Aliases"
      },
      "url": "posts/2021/05/16/Beyond-Oakwood-Modules-and-Aliases.json"
    },
    {
      "content": "\nPortable conversions (Integers)\n===============================\n\nBy R. S. Doiel, 2021-11-26\n\nAn area in working with Oberon-07 on a POSIX machine that has proven problematic is type conversion. In particular converting to and from INTEGER or REAL and ASCII.  None of the three compilers I am exploring provide a common way of handling this. I've explored relying on C libraries but that approach has it's own set of problems.  I've become convinced a better approach is a pure Oberon-07 library that handles type conversion with a minimum of assumptions about the implementation details of the Oberon compiler or hardware. I'm calling my conversion module \"Types\". The name is short and descriptive and seems an appropriate name for a module consisting of type conversion tests and transformations.  My initial implementation will focusing on converting integers to and from ASCII.\n\nINTEGER to ASCII and back again\n-------------------------------\n\nI don't want to rely on the representation of the INTEGER value in the compiler or at the machine level. That has lead me to think in terms of an INTEGER as a signed whole number. \n\nThe simplest case of converting to/from ASCII is the digits from zero to nine (inclusive). Going from an INTEGER to an ASCII CHAR is just looking up the offset of the character representing the \"digit\". Like wise going from ASCII CHAR to a INTEGER is a matter of mapping in the reverse direction.  Let's call these procedures `DigitToChar` and  `CharToDigit*`.\n\nSince INTEGER can be larger than zero through nine and CHAR can hold non-digits I'm going to add two additional procedures for validating inputs -- `IsIntDigit` and `IsCharDigit`. Both return TRUE if valid, FALSE if not.\n\nFor numbers larger than one digit I can use decimal right shift to extract the ones column value or a left shift to reverse the process.  Let's called these `IntShiftRight` and `IntShiftLeft`.  For shift right it'd be good to capture the ones column being lost. For shift left it would be good to be able to shift in a desired digit. That way you could shift/unshift to retrieve to extract and put back values.\n\nA draft definition for \"Types\" should look something like this.\n\n~~~\nDEFINITION Types;\n\n(* Check if an integer is a single digit, i.e. from 0 through 9 returns\n   TRUE, otherwise FALSE *)\nPROCEDURE IsIntDigit(x : INTEGER) : BOOLEAN;\n\n(* Check if a CHAR is \"0\" through \"9\" and return TRUE, otherwise FALSE *)\nPROCEDURE IsCharDigit(ch : CHAR) : BOOLEAN;\n\n(* Convert digit 0 through 9 into an ASCII CHAR \"0\" through \"9\",\n   ok is TRUE if conversion successful, FALSE otherwise *)\nPROCEDURE DigitToChar(x : INTEGER; VAR ch : CHAR; VAR ok : BOOLEAN);\n\n(* Convert a CHAR \"0\" through \"9\" into a digit 0 through 9, ok\n   is TRUE is conversion successful, FALSE otherwise *)\nPROCEDURE CharToDigit(ch : CHAR; VAR x : INTEGER; VAR ok : BOOLEAN);\n\n(* Shift an integer to the right (i.e. x * 0.1) set \"r\" to the\n   value shifted out (ones column lost) and return the shifted value.\n   E.g.  x becomes 12, r becomes 3.\n\n       x := IntShiftRight(123, r);\n   \n *)\nPROCEDURE IntShiftRight(x : INTEGER; VAR r : INTEGER) : INTEGER;\n\n(* Shift an integer to the left (i.e. x * 10) adding the value y\n   after the shift.\n\n   E.g. x before 123\n\n       x := IntShiftRight(12, 3);\n\n *)\nPROCEDURE IntShiftLeft(x, y : INTEGER) : INTEGER;\n\n(* INTEGER to ASCII *)\nPROCEDURE Itoa(src : INTEGER; VAR value : ARRAY OF CHAR; VAR ok : BOOLEAN);\n\n(* ASCII to INTEGER *)\nPROCEDURE Atoi(src : ARRAY OF CHAR; VAR value : INTEGER; VAR ok : BOOLEAN);\n\nEND Types.\n~~~\n\n\nNOTE: Oberon-07 provides us the ORD and CHR built as part of the\nlanguage.  These are for working with the encoding and decoding\nvalues as integers. This is not the same thing as the meaning\nof \"0\" versus the value of 0.  Getting to and from the encoding\nto the meaning of the presentation can be done with some simple\narithmetic.\n\nPutting it all together\n-----------------------\n\n~~~\n(* DigitToChar converts an INTEGER less than to a character. E.g.\n   0 should return \"0\", 3 returns \"3\", 0 returns \"9\" *)\nPROCEDURE DigitToChar*(i : INTEGER) : CHAR;\nBEGIN\n  RETURN (CHR(ORD(\"0\") + i))\nEND DigitToChar;\n\n(* CharToDigit converts a single \"Digit\" character to an INTEGER value.\n   E.g. \"0\" returns 0, \"3\" returns 3, \"9\" returns 9. *)\nPROCEDURE CharToDigit(ch : CHAR) : INTEGER;\nBEGIN\n  RETURN (ORD(ch) - ORD(\"0\"))\nEND CharToDigit;\n~~~\n\nThis implementation is naive. It assumes the ranges of the input values\nwas already checked. In practice this is going to encourage bugs.\n\nIn a language like Go or Python you can return multiple values (in\nPython you can return a tuple). In Oberon-07 I could use a\nRECORD type to do that but that feels a little too baroque. Oberon-07\nlike Oberon-2, Oberon, Modula and Pascal does support \"VAR\" parameters. \nWith a slight modification to our procedure signatures I can support\neasy assertions about the conversion. Let's create two functional\nprocedures `IsIntDigit()` and `IsCharDigit()` then update our\n`DigitToChar()` and `CharToDigit()` with an a  \"VAR ok : BOOLEAN\"\nparameter.\n\n~~~\n(* IsIntDigit returns TRUE is the integer value is zero through nine *)\nPROCEDURE IsIntDigit(i : INTEGER) : BOOLEAN;\nBEGIN \n  RETURN ((i >= 0) & (i <= 9))\nEND IsIntDigit;\n\n(* IsCharDigit returns TRUE if character is zero through nine. *)\nPROCEDURE IsCharDigit(ch : CHAR) : BOOLEAN;\nBEGIN\n  RETURN ((ch >= \"0\") & (ch <= \"9\"))\nEND IsCharDigit;\n\n(* DigitToChar converts an INTEGER less than to a character. E.g.\n   0 should return \"0\", 3 returns \"3\", 0 returns \"9\" *)\nPROCEDURE DigitToChar*(i : INTEGER; VAR ok : BOOLEAN) : CHAR;\nBEGIN\n  ok := IsIntDigit(i);\n  RETURN (CHR(ORD(\"0\") + i))\nEND DigitToChar;\n\n(* CharToDigit converts a single \"Digit\" character to an INTEGER value.\n   E.g. \"0\" returns 0, \"3\" returns 3, \"9\" returns 9. *)\nPROCEDURE CharToDigit(ch : CHAR; VAR ok : BOOLEAN) : INTEGER;\nBEGIN\n  ok := IsCharDigit(ch);\n  RETURN (ORD(ch) - ORD(\"0\"))\nEND CharToDigit;\n~~~\n\nWhat about values are greater nine? Here we can take advantage\nof our integer shift procedures.  `IntShiftRight` will move the\nINTEGER value right reducing it's magnitude (i.e. x * 0.1). It\nalso captures the ones column lost in the shift.  Repeatedly calling\n`IntShiftRight` will let us peal off the ones columns until the\nvalue \"x\" is zero. `IntShiftLeft` shifts the integer to the\nleft meaning it raises it a magnitude (i.e. x * 10). `IntShiftLeft`\nalso rakes a value to shift in on the right side of the number.\nIn this way we can shift in a zero and get `x * 10` or shift in\nanother digit and get `(x * 10) + y`. This means you can use\n`IntShiftRight` and recover an `IntShiftLeft`.\n\n~~~\n\n(* IntShiftRight converts the input integer to a real, multiplies by 0.1\n   and converts by to an integer. The value in the ones column is record\n   in the VAR parameter r.  E.g. IntShiftRight(123) return 12, r is set to 3. *)\nPROCEDURE IntShiftRight*(x : INTEGER; VAR r : INTEGER) : INTEGER;\n  VAR i : INTEGER; isNeg : BOOLEAN;\nBEGIN\n  isNeg := (x < 0);\n  i := FLOOR(FLT(ABS(x)) * 0.1);\n  r := ABS(x) - (i * 10);\n  IF isNeg THEN\n    i := i * (-1);\n  END;\n  RETURN i\nEND IntShiftRight;\n\n(* IntShiftLeft multiples input value by 10 and adds y. E.g. IntShiftLeft(123, 4) return 1234 *)\nPROCEDURE IntShiftLeft*(x, y : INTEGER) : INTEGER;\n  VAR i : INTEGER; isNeg : BOOLEAN;\nBEGIN\n  isNeg := (x < 0);\n  i := (ABS(x) * 10) + y;\n  IF isNeg THEN\n    i := i * (-1);\n  END;\n  RETURN i\nEND IntShiftLeft;\n\n~~~\n\nI have what I need for implementing `Itoa` (integer to ASCII).\n\n\n~~~\n\n(* Itoa converts an INTEGER to an ASCII string setting ok BOOLEAN to\n   TRUE if value ARRAY OF CHAR holds the full integer, FALSE if\n   value was too small to hold the integer value.  *)\nPROCEDURE Itoa*(x : INTEGER; VAR value : ARRAY OF CHAR; ok : BOOLEAN);\n  VAR i, j, k, l, minL : INTEGER; tmp : ARRAY BUFSIZE OF CHAR; isNeg : BOOLEAN;\nBEGIN\n  i := 0; j := 0; k := 0; l := LEN(value); isNeg := (x < 0);\n  IF isNeg THEN\n    (* minimum string length for value is 3, negative sign, digit and 0X *)\n    minL := 3;\n  ELSE \n    (* minimum string length for value is 2, one digit and 0X *)\n    minL := 2; \n  END;\n  ok := (l >= minL) & (LEN(value) >= LEN(tmp));\n  IF ok THEN\n    IF IsIntDigit(ABS(x)) THEN\n      IF isNeg THEN\n         value[i] := \"-\"; INC(i);\n      END;\n      value[i] := DigitToChar(ABS(x), ok); INC(i); value[i] := 0X;\n    ELSE\n      x := ABS(x); (* We need to work with the absolute value of x *)\n      i := 0; tmp[i] := 0X;\n      WHILE (x >= 10) & ok DO\n        (* extract the ones columns *)\n        x := IntShiftRight(x, k); (* a holds the shifted value, \n                                     \"k\" holds the ones column \n                                     value shifted out. *)\n        (* write append k to our temp array holding values in\n           reverse number magnitude *)\n        tmp[i] := DigitToChar(k, ok); INC(i); tmp[i] := 0X;\n      END;\n      (* We now can convert the remaining \"ones\" column. *)\n      tmp[i] := DigitToChar(x, ok); INC(i); tmp[i] := 0X;\n      IF ok THEN\n        (* now reverse the order of tmp string append each\n           character to value *)\n        i := 0; j := Strings.Length(tmp) - 2;\n        IF isNeg THEN\n          value[i] := \"-\"; INC(i);\n        END;\n        j := Strings.Length(tmp) - 1;\n        WHILE (j > -1) DO\n          value[i]:= tmp[j]; \n          INC(i); DEC(j);\n          value[i] := 0X;\n        END;\n        value[i] := 0X;\n      END;\n    END; \n  ELSE\n    ok := FALSE;\n  END;\nEND Itoa;\n\n~~~\n\nIntegers in Oberon are signed. So I've chosen to capture the sign in the `isNeg` variable. This lets me work with the absolute value for the actual conversion.  One failing in this implementation is I don't detect an overflow.  Also notice that I am accumulating the individual column values in reverse order (lowest magnitude first).  That is what I need a temporary buffer. I can then copy the values in reverse order into the VAR ARRAY OF CHAR. Finally I also maintain the ok BOOLEAN to track if anything went wrong.\n\nWhen moving from an ASCII representation I can simplified the code by having a local (to the module) procedure for generating magnitudes.\n\nGoing the other way I can simplify my `Atoi` if I have an local to the module \"magnitude\" procedure.\n\n~~~\n\n(* magnitude takes x and multiplies it be 10^y, If y is positive zeros\n   are appended to the right side (i.e. multiplied by 10). If y is\n   negative then the result is shifted left (i.e.. multiplied by\n   0.1 via IntShiftRight().).  The digit(s) shift to the fractional\n   side of the decimal are ignored. *)\nPROCEDURE magnitude(x, y : INTEGER) : INTEGER;\n  VAR z, w : INTEGER;\nBEGIN\n  z := 1;\n  IF y >= 0 THEN\n    WHILE y > 0 DO\n      z := IntShiftLeft(z, 0);\n      DEC(y);\n    END;\n  ELSE\n    WHILE y < 0 DO\n      x := IntShiftRight(x, w);\n      INC(y);\n    END;\n  END;\n  RETURN (x * z)\nEND magnitude;\n\n~~~\n\nAnd with that I can put together my `Atoi` (ASCII to integer) procedure.  I'll need to add some sanity checks as well.\n\n~~~\n\n(* Atoi converts an ASCII string to a signed integer value\n   setting the ok BOOLEAN to TRUE on success and FALSE on error. *)\nPROCEDURE Atoi*(source : ARRAY OF CHAR; VAR value : INTEGER; VAR ok : BOOLEAN);\n  VAR i, l, a, m: INTEGER; isNeg : BOOLEAN;\nBEGIN\n  (* \"i\" is the current CHAR position we're analyzing, \"l\" is the\n     length of our string, \"a\" holds the accumulated value,\n     \"m\" holds the current magnitude we're working with *)\n  i := 0; l := Strings.Length(source);\n  a := 0; m := l - 1; isNeg := FALSE; ok := TRUE;\n  (* Validate magnitude and sign behavior *)\n  IF (l > 0) & (source[0] = \"-\") THEN\n    INC(i); DEC(m);\n    isNeg := TRUE;\n  ELSIF (l > 0) & (source[0] = \"+\") THEN\n    INC(i); DEC(m);\n  END;\n\n  (* The accumulator should always hold a positive integer, if the\n     sign flips we have overflow, ok should be set to FALSE *)\n  ok := TRUE;\n  WHILE (i < l) & ok DO\n    a := a + magnitude(CharToDigit(source[i], ok), m);\n    IF a < 0 THEN\n      ok := FALSE; (* we have an overflow condition *)\n    END;\n    DEC(m);\n    INC(i);\n  END;\n  IF ok THEN\n    IF (i = l) THEN\n      IF isNeg THEN\n        value := a * (-1);\n      ELSE\n        value := a;\n      END;\n    END;\n  END;\nEND Atoi;\n\n~~~\n\nHere's an example using the procedures.\n\nConverting an integer 1234 to an string \"1234\".\n\n~~~\n\n   x := 1234; s := \"\"; ok := FALSE;\n   Types.Itoa(x, s, ok);\n   IF ok THEN \n     Out.String(s); Out.String(\" = \");\n     Out.Int(x,1);Out.Ln;\n   ELSE\n     Out.String(\"Something went wrong\");Out.Ln;\n   END;\n\n~~~\n\nConverting a string \"56789\" to integer 56789.\n\n~~~\n\n   x := 0; src := \"56789\"; ok := FALSE;\n   Types.Atoi(src, x, ok);\n   IF ok THEN \n     Out.Int(x,1); Out.String(\" = \"); Out.String(s); \n     Out.Ln;\n   ELSE\n     Out.String(\"Something went wrong\");Out.Ln;\n   END;\n\n~~~\n\n\nReferences and resources\n------------------------\n\nImplementations for modules for this article are linked here [Types](./Types.Mod), [TypesTest](./TypesTest.Mod) and [Tests](./Tests.Mod). \n\nExpanded versions of the `Types` module will be available as part of Artemis Project -- [github.com/rsdoiel/Artemis](https://github.com/rsdoiel/Artemis).\n\nPrevious\n--------\n\n- [Revisiting Files](../../11/22/Revisiting-Files.html)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-11-26",
        "keywords": [
          "Oberon",
          "Modules",
          "Types",
          "conversion"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 21,
        "title": "Portable Conversions (Integers)"
      },
      "url": "posts/2021/11/26/Portable-Conversions-Integers.json"
    }
  ]
}