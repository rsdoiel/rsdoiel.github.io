{
  "page": 1,
  "total_pages": 1,
  "has_more": false,
  "next_page": null,
  "values": [
    {
      "content": "\n\nSoftware Tools, Filters\n=======================\n\nOverview\n--------\n\nThis post is the second in a series revisiting the programs\ndescribed in the 1981 book by Brian W. Kernighan and P. J.\nPlauger's called [Software Tools in Pascal](https://archive.org/details/softwaretoolsinp00kern). The book is available from the\n[Open Library](https://openlibrary.org/) and physical copies\nare still (2020) commonly available from used book sellers.\nThe book was an late 20th century text on creating portable\ncommand line programs using ISO standard Pascal of the era.\n\nIn this chapter K & P focuses on developing the idea of filters.\nFilters are programs which typically process standard input, do\nsome sort of transformation or calculation and write to standard\noutput.  They are intended to work either standalone or in a pipeline\nto solve more complex problems. I like to think of filters as\nsoftware [LEGO](https://en.wikipedia.org/wiki/Lego).\nFilter programs can be \"snapped\" together creating simple shapes\ndata shapes or combined to for complex compositions.\n\nThe programs from this chapter include:\n\n+ **entab**, respecting tabstops, convert strings of spaces to tabs\n+ **overstrike**, this is probably not useful anymore, it would allow \"overstriking\" characters on devices that supported it. From [wikipedia](https://en.wikipedia.org/wiki/Overstrike), \"In typography, overstrike is a method of printing characters that are missing from the printer's character set. The character was created by placing one character on another one — for example, overstriking \"L\" with \"-\" resulted in printing a \"Ł\" (L with stroke) character.\"\n+ **compress**, an early UNIX style compress for plain text files\n+ **expand**, an early UNIX style expand for plain text files, previously run through with **compress**\n+ **echo**, write echo's command line parameters to standard output, introduces working with command line parameters\n+ **translit**, transliterate characters using a simple from/to substitution with a simple notation to describe character sequences and negation. My implementation diverges from K & P\n\nImplementing in Oberon-07\n------------------------\n\nWith the exception of **echo** (used to introduce command line parameter processing) each program increases in complexity.  The last program **translit**is the most complex in this chapter.  It introducing what we a \"domain specific language\" or \"DSL\".  A DSL is a notation allowing us to describe something implicitly rather than explicitly. All the programs except **translit** follow closely the original Pascal translated to Oberon-07.  **translit** book implementation is very much a result of the constraints of Pascal of the early 1980s as well as the minimalist assumption that could be made about the host operating system. I will focus on revising that program in particular bring the code up to current practice as well as offering insights I've learned.\n\n\nThe program **translit** introduces what is called a \"Domain Specific Language\".Domain specific languages or DSL for short are often simple notations to describe how to solve vary narrow problems.  If you've used any of the popular spreadsheet programs where you've entered a formula to compute something you've used a domain specific language.  If you've ever search for text in a document using a regular expression you've used a domain specific language.  By focusing a notation on a small problem space you can often come up with simple ways of expressing or composing programmatic solutions to get a job done.\n\nIn **translit** the notation let's us describe what we want to translate. At the simplest level the **translit** program takes a character and replaces it with another character. What make increases **translit** utility is that it can take a set of characters and replace it with another.  If you want to change all lower cases letters and replace them with uppercase letters. This \"from set\" and \"to set\" are easy to describe as two ranges, \"a\" to \"z\" and \"A\" to \"Z\".  Our domain notation allows us to express this as \"a-z\" and \"A-Z\".  K & P include several of features in there notation including characters to exclude from a translation as well as an \"escape notation\" for describing characters like new lines, tabs, or the characters that describe a range and exclusion (i.e. dash and caret).\n\n\n\n2.1 Putting Tabs Back\n=====================\n\n[Page 31](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/31/mode/1up)\n\nImplementing **entab** in Oberon-07 is straight forward.\nLike my [Detab](Detab.Mod) implementation I am using\na second modules called [Tabs](Tabs.Mod). This removes\nthe need for the `#include` macros used in the K & P version.\nI have used the same loop structure as K & P this time.\nThere is a difference in my `WHILE` loop. I separate the\ncharacter read from the `WHILE` conditional test.  Combining the\ntwo is common in \"C\" and is consistent with the programming style\nother books by Kernighan.  In Oberon-07 doesn't make sense at all.\nOberon's `In.Char()` is not a function returning as in the Pascal\nprimitives implemented for the K & P book or indeed like in the \"C\"\nlanguage. In Oberon's \"In\" module the status of a read operation is\nexposed by `In.Done`. I've chosen to put the next call to\n`In.Char()` at the bottom of my `WHILE` loop because it is clear\nthat it is the last think done before ether iterating again or\nexiting the loop. Other than that the Oberon version looks much\nlike K & P's Pascal.\n\n\nProgram Documentation\n---------------------\n\n[Page 32](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/32/mode/1up)\n\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n  entab\tconvert runs of blanks into tabs\n\nUSAGE\n\n  entab\n\nFUNCTION\n\n  entab copies its input to its output, replacing strings of\n  blanks by tabs so the output is visually the same as the\n  input, but contains fewer characters. Tab stops are assumed\n  to be set every four columns (i.e. 1, 5, 9, ...), so that\n  each sequence of one to four blanks ending on a tab stop\n  is replaced by a tab character\n\nEXAMPLE\n\n  Using -> as visible tab:\n\n    entab\n      col  1   2   34  rest\n    ->col->1->2->34->rest\n\nBUGS\n\n  entab is naive about backspaces, virtical motions, and\n  non-printing characters. entab will convert  a single blank\n  to a tab if it occurs at a tab stop. The entab is not an\n  exact inverse of detab.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSource code for **Entab.Mod**\n-----------------------------\n\n~~~\n\nMODULE Entab;\n  IMPORT In, Out, Tabs;\n\nCONST\n  NEWLINE = 10;\n  TAB = 9;\n  BLANK = 32;\n\nPROCEDURE Entab();\nVAR\n  c : CHAR;\n  col, newcol : INTEGER;\n  tabstops : Tabs.TabType;\nBEGIN\n  Tabs.SetTabs(tabstops);\n  col := 1;\n  REPEAT\n    newcol := col;\n    In.Char(c);\n    IF In.Done THEN (* NOTE: We check that the read was successful! *)\n      WHILE (ORD(c) = BLANK) DO\n        newcol := newcol + 1;\n        IF (Tabs.TabPos(newcol, tabstops)) THEN\n          Out.Char(CHR(TAB));\n          col := newcol;\n        END;\n        (* NOTE: Get the next char, check the loop condition\n           and either iterate or exit the loop *)\n        In.Char(c);\n      END;\n      WHILE (col < newcol) DO\n        Out.Char(CHR(BLANK)); (* output left over blanks *)\n        col := col + 1;\n      END;\n      (* NOTE: Since we may have gotten a new char in the first WHILE\n         we need to check again if the read was successful *)\n      IF In.Done THEN\n        Out.Char(c);\n        IF (ORD(c) = NEWLINE) THEN\n          col := 1;\n        ELSE\n          col := col + 1;\n        END;\n      END;\n    END;\n  UNTIL In.Done # TRUE;\nEND Entab;\n\nBEGIN\n  Entab();\nEND Entab.\n\n~~~\n\n\n\n2.2 Overstrikes\n===============\n\n\n[Page 34](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/34/mode/1up)\n\n\nOverstrike isn't a tool that is useful today but I've included it\nsimply to be follow along the flow of the K & P book. It very much\nreflects an error where teletype like devices where still common and\nprinters printed much like typewriters did. On a 20th century\nmanual type writer you could underline a word or letter by backing\nup the carriage then typing the underscore character. Striking out\na word was accomplished by a similar technique. The mid to late\n20th century computers device retained this mechanism though by\n1980's it was beginning to disappear along with manual typewriters.\nThis program relies on the the nature of ASCII character set and\nreflects some of the non-print character's functionality. I\nfound it did not work on today's terminal emulators reliably. Your\nmileage may very nor do I have a vintage printer to test it on.\n\nOur module follows K & P design almost verbatim. The differences\nare those suggested by differences between Pascal and Oberon-07.\nLike in previous examples we don't need to use an ENDFILE constant\nas we can simply check the value of `In.Done` to determine\nif the last read was successful. This simplifies some of\nthe `IF/ELSE` logic and the termination of the `REPEAT/UNTIL`\nloop.  It makes the `WHILE/DO` loop a little more verbose.\n\nOne thing I would like to point out in the original Pascal of the\nbook is a problem often referred to as the \"dangling else\" problem.\nWhile this is usually discussed in the context of compiler\nimplementation I feel like it is a bigger issue for the person\nreading the source code. It is particularly problematic when you\nhave complex \"IF/ELSE\" sequences that are nested.  This is not\nlimited to the 1980's era Pascal. You see it in other languages\nlike C.  It is a convenience for the person typing the source code\nbut a problem for those who maintain it. We see this ambiguity in\nthe Pascal procedure **overstrike** inside the repeat loop\non [page 35](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/35/mode/1up).\nIt is made worse by the fact that K & P have taken advantage of\nomitting the semi-colons where optional. If you type in this\nprocedure and remove the indication if quickly becomes ambiguous\nabout where on \"IF/ELSE\" begins and the next ends. In Oberon-07 it\nis clear when you have a dangling \"IF\" statement. This vintage\nPascal, not so much.\n\nK & P do mention the dangling \"ELSE\" problem later in the text.\nTheir recommend practice was include the explicit final \"ELSE\"\nat a comment to avoid confusion. But you can see how easy an\nomitting the comment is in the **overstrike** program.\n\nLimitations\n-----------\n\nThis is documented \"BUG\" section describes the limitations\nwell, \"**overstrike** is naive about vertical motions and non-\nprinting characters. It produces one over struck line for each\nsequence of backspaces\". But in addition to that most printing\ndevices these days either have their own drivers or expect to work\nwith a standard like Postscript. This limited the usefulness of\nthis program today though controlling character movement in a\n\"vt100\" emulation using old fashion ASCII control codes is\nstill interesting if only for historical reasons.\n\n\nProgram Documentation\n---------------------\n\n[Page 36](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/36/mode/1up)\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n  overstrike    replace overstrikes by multiple-lines\n\nUSAGE\n\n  overstrike\n\nFUNCTION\n\n  overstrike copies in input to its output, replacing lines\n  containing backspaces by multiple lines that overstrike\n  to print the same as input, but containing no backspaces.\n  It is assumed that the output is to be printed on a device\n  that takes the first character of each line as a carriage\n  control; a blank carriage control causes normal space before\n  print, while a plus sign '+' suppresses space before print\n  and hence causes the remainder of the line to overstrike\n  the previous line.\n\nEXAMPLE\n\n  Using <- as a visible backspace:\n\n    overstrike\n    abc<-<-<-___\n     abc\n    +___\n\nBUGS\n\n  overstrike is naive about vertical motions and non-printing\n  characters. It produces one over struck line for each sequence\n  of backspaces.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nSource code for **Overstrike.Mod**\n----------------------------------\n\n~~~\n\nMODULE Overstrike;\nIMPORT In, Out;\n\nCONST\n  NEWLINE = 10;\n  BLANK = 32;\n  PLUS = 43;\n  BACKSPACE = 8;\n\nPROCEDURE Max(x, y : INTEGER) : INTEGER;\nVAR max : INTEGER;\nBEGIN\n  IF (x > y) THEN\n    max := x\n  ELSE\n    max := y\n  END;\n  RETURN max\nEND Max;\n\nPROCEDURE Overstrike;\nCONST\n  SKIP = BLANK;\n  NOSKIP = PLUS;\nVAR\n  c : CHAR;\n  col, newcol, i : INTEGER;\nBEGIN\n  col := 1;\n  REPEAT\n    newcol := col;\n    In.Char(c);\n    (* NOTE We check In.Done on each loop evalution *)\n    WHILE (In.Done = TRUE) & (ORD(c) = BACKSPACE) DO (* eat the backspaces *)\n      newcol := Max(newcol, 1);\n      In.Char(c);\n    END;\n    (* NOTE: We check In.Done again, since we may have\n       additional reads when eating the backspaces. If\n       the previous while loop has taken us to the end of file.\n       this will be also mean In.Done = FALSE. *)\n    IF In.Done THEN\n      IF (newcol < col) THEN\n        Out.Char(CHR(NEWLINE)); (* start overstrike line *)\n        Out.Char(CHR(NOSKIP));\n        FOR i := 0 TO newcol DO\n          Out.Char(CHR(BLANK));\n        END;\n        col := newcol;\n      ELSIF (col = 1) THEN (* NOTE: In.Done already check for end of file *)\n        Out.Char(CHR(SKIP)); (* normal line *)\n      END;\n      (* NOTE: In.Done already was checked so we are in mid line *)\n      Out.Char(c);    (* normal character *)\n      IF (ORD(c) = NEWLINE) THEN\n        col := 1\n      ELSE\n        col := col + 1\n      END;\n    END;\n  UNTIL In.Done # TRUE;\nEND Overstrike;\n\nBEGIN\n  Overstrike();\nEND Overstrike.\n\n~~~\n\n\n2.3 Text Compression\n====================\n\n[Page 37](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/37/mode/1up)\n\nIn 20th century computing everything is expensive, memory,\npersistent storage computational ability in CPU.  If you were\nprimarily working with text you still worried about running out of\nspace in your storage medium. You see it in the units\nof measurement used in that era such as bytes, kilobytes, hertz and\nkilohertz. To day we talk about megabytes, gigabytes, terabytes and\npetabytes. Plain text files are a tiny size compared to must\ndigital objects today but in the late 20th century\ntheir size in storage was still a concern.  One way to solve this\nproblem was to encode your plain text to use less storage space.\nEarly attempts at file compression took advantage of repetition to\nsave space. Many text documents have repeated characters\nwhether spaces or punctuation or other formatting. This is what\ninspired the K & P implementation of **compress** and **expand**.\nToday we'd use other approaches to save space whether we were\nstoring text or a digital photograph.\n\n\nProgram Documentation\n---------------------\n\n[Page ](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/40/mode/1up)\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n    compress    compress input by encoding repeated characters\n\nUSAGE\n\n    compress\n\nFUNCTION\n\n    compress copies its input to its output, replacing strings\n    of four or more identical characters by a code sequence so\n    that the output generally contains fewer characters than the\n    input. A run of x's is encoded as -nx, where the count n is\n    a character: 'A' calls for a repetition of one x, 'B' a\n    repetition of two x's, and so on. Runs longer than 26 are\n    broken into several shorter ones. Runs of -'s of any length\n    are encoded.\n\nEXAMPLE\n\n    compress\n    Item     Name           Value\n    Item-D Name-I Value\n    1       car             -$7,000.00\n    1-G car-J -A-$7,000.00\n    <ENDFILE>\n\nBUGS\n\n    The implementation assumes 26 legal characters beginning with A.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nSource code for **Compress.Mod**\n--------------------------------\n\n~~~\n\nMODULE Compress;\nIMPORT In, Out;\n\nCONST\n    TILDE = \"~\";\n    WARNING = TILDE;    (* ~ *)\n\n(* Min -- compute minimum of two integers *)\nPROCEDURE Min(x, y : INTEGER) : INTEGER;\nVAR min : INTEGER;\nBEGIN\n    IF (x < y) THEN\n        min := x\n    ELSE\n        min := y\n    END;\n    RETURN min\nEND Min;\n\n(* PutRep -- put out representation of run of n 'c's *)\nPROCEDURE PutRep (n : INTEGER; c : CHAR);\nCONST\n    MAXREP = 26;    (* assuming 'A' .. 'Z' *)\n    THRESH = 4;\nVAR i : INTEGER;\nBEGIN\n    WHILE (n >= THRESH) OR ((c = WARNING) & (n > 0)) DO\n        Out.Char(WARNING);\n        Out.Char(CHR((Min(n, MAXREP) - 1) + ORD(\"A\")));\n        Out.Char(c);\n        n := n - MAXREP;\n    END;\n    FOR i := n TO 1 BY (-1) DO\n        Out.Char(c);\n    END;\nEND PutRep;\n\n(* Compress -- compress standard input *)\nPROCEDURE Compress();\nVAR\n    c, lastc : CHAR;\n    n : INTEGER;\nBEGIN\n    n := 1;\n    In.Char(lastc);\n    WHILE (In.Done = TRUE) DO\n        In.Char(c);\n        IF (In.Done = FALSE) THEN\n            IF (n > 1) OR (lastc = WARNING) THEN\n                PutRep(n, lastc)\n            ELSE\n                Out.Char(lastc);\n            END;\n        ELSIF (c = lastc) THEN\n            n := n + 1\n        ELSIF (n > 1) OR (lastc = WARNING) THEN\n            PutRep(n, lastc);\n            n := 1\n        ELSE\n            Out.Char(lastc);\n        END;\n        lastc := c;\n    END;\nEND Compress;\n\n\nBEGIN\n    Compress();\nEND Compress.\n\n~~~\n\n\n\n2.4 Text Expansion\n==================\n\n[Page 41](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/41/mode/1up)\n\nOur procedures map closely to the original Pascal with a few\nsignificant differences.  As previously I've chosen a\n`REPEAT ... UNTIL` loop structure because we are always attempting\nto read at least once. The `IF THEN ELSIF ELSE` logic is a little\ndifferent. In the K & P version they combine retrieving\na character and testing its value.  This is a style common in\nlanguages like C. As previous mentioned I split the read of the\ncharacter from the test.  Aside from the choices imposed by the\n\"In\" module I also feel that retrieving the value, then testing is\na simpler statement to read. There is little need to worry about a\nside effect when you separate the action from the test. It does\nchange the structure of the inner and outer `IF` statements.\n\n\n\nProgram Documentation\n---------------------\n\n[Page 43](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/43/mode/1up)\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n    expand  expand compressed input\n\nUSAGE\n\n    expand\n\nFUNCTION\n\n    expand copies its input, which has presumably been encoded by\n    compress, to its output, replacing code sequences -nc by the\n    repeated characters they stand for so that the text output\n    exactly matches that which was originally encoded. The\n    occurrence of the warning character - in the input means that\n    which was originally encoded. The occurrence of the warning\n    character - in the input means that the next character is a\n    repetition count; 'A' calls for one instance of the following\n    character, 'B' calls for two, and so on up to 'Z'.\n\nEXAMPLE\n\n    expand\n    Item~D Name~I Value\n    Item    Name        Value\n    1~G car~J ~A~$7,000.00\n    1       car         -$7,000.00\n    <ENDFILE>\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nSource code for **Expand.Mod**\n------------------------------\n\n~~~\nMODULE Expand;\nIMPORT In, Out;\n\nCONST\n    TILDE = \"~\";\n    WARNING = TILDE;    (* ~ *)\n    LetterA = ORD(\"A\");\n    LetterZ = ORD(\"Z\");\n\n(* IsUpper -- true if c is upper case letter *)\nPROCEDURE IsUpper (c : CHAR) : BOOLEAN;\nVAR res : BOOLEAN;\nBEGIN\n    IF (ORD(c) >= LetterA) & (ORD(c) <= LetterZ) THEN\n        res := TRUE;\n    ELSE\n        res := FALSE;\n    END\n    RETURN res\nEND IsUpper;\n\n(* Expand -- uncompress standard input *)\nPROCEDURE Expand();\nVAR\n    c : CHAR;\n    n, i : INTEGER;\nBEGIN\n    REPEAT\n        In.Char(c);\n        IF (c # WARNING) THEN\n            Out.Char(c);\n        ELSE\n            In.Char(c);\n            IF IsUpper(c) THEN\n                n := (ORD(c) - ORD(\"A\")) + 1;\n                In.Char(c);\n                IF (In.Done) THEN\n                    FOR i := n TO 1 BY -1 DO\n                        Out.Char(c);\n                    END;\n                ELSE\n                    Out.Char(WARNING);\n                    Out.Char(CHR((n - 1) + ORD(\"A\")));\n                END;\n            ELSE\n                Out.Char(WARNING);\n                IF In.Done THEN\n                    Out.Char(c);\n                END;\n            END;\n        END;\n    UNTIL In.Done # TRUE;\nEND Expand;\n\nBEGIN\n    Expand();\nEND Expand.\n\n~~~\n\n\n2.5 Command Arguments\n=====================\n\n[Page 44](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/44/mode/1up)\n\n\nProgram Documentation\n---------------------\n\n[Page 45](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/45/mode/1up)\n\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n    echo    echo arguments to standard output\n\nUSAGE\n\n    echo [ argument ... ]\n\nFUNCTION\n\n    echo copies its command line arguments to its output as a line\n    of text with one space\n    between each argument. IF there are no arguments, no output is\n    produced.\n\nEXAMPLE\n\n    To see if your system is alive:\n\n        echo hello world!\n        hello world!\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nSource code for **Echo.Mod**\n----------------------------\n\n~~~\n\nMODULE Echo;\nIMPORT Out, Args := extArgs;\n\nCONST\n    MAXSTR = 1024; (* or whatever *)\n    BLANK = \" \";\n\n(* Echo -- echo command line arguments to output *)\nPROCEDURE Echo();\nVAR\n    i, res : INTEGER;\n    argstr : ARRAY MAXSTR OF CHAR;\nBEGIN\n    i := 0;\n    FOR i := 0 TO (Args.count - 1) DO\n        Args.Get(i, argstr, res);\n        IF (i > 0) THEN\n            Out.Char(BLANK);\n        END;\n        Out.String(argstr);\n    END;\n    IF Args.count > 0 THEN\n        Out.Ln();\n    END;\nEND Echo;\n\nBEGIN\n    Echo();\nEND Echo.\n\n~~~\n\n\n2.6 Character Transliteration\n=============================\n\n[Page 47](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/47/mode/1up)\n\n\n**translit** is the most complicated program so far in the book.\nMost of the translation process from Pascal to Oberon-07 has\nremained similar to the previous examples.\n\nMy implementation of **translit** diverges from the K & P\nimplementation at several points. Much of this is a result of\nOberon evolution beyond Pascal. First Oberon counts arrays from\nzero instead of one so I have opted to use -1 as a value to\nindicate the index of a character in a string was not found.\nEqually I have simplified the logic in `xindex()` to make it clear\nhow I am handling the index lookup described in `index()` of the\nPascal implementation. K & P implemented `makeset()` and `dodash()`.\n`dodash()` particularly looked troublesome. If you came across the\nfunction name `dodash()` without seeing the code comments\n\"doing a dash\" seems a little obscure.  I have chosen to name\nthat process \"Expand Sequence\" for clarity. I have simplified the\ntask of making sets of characters for translation into three cases\nby splitting the test conditions from the actions. First check to\nsee if we have an escape sequence and if so handle it. Second check\nto see if we have an expansion sequence and if so handle it else\nappend the char found to the end of the set being assembled. This\nresulted in `dodash()` being replaced by `IsSequence()` and\n`ExpandSequence()`.  Likewise `esc()` was replaced with `IsEscape()`\nand `ExpandEscape()`. I renamed `addchar()` to `AppendChar()`\nin the \"Chars\" module as that seemed more specific and clearer.\n\nI choose to advance the value used when expanding a set description\nin the loop inside of my `MakeSet()`. I minimized the side effects\nof the expand functions to the target destination.  It is clearer\nwhile in the `MakeSet()` loop to see the relationship of the test\nand transformation and how to advance through the string. This also\nallowed me to use fewer parameters to procedures which tends to\nmake things more readable as well as simpler.\n\nI have included an additional procedure not included in the K & P\nPascal of this program. `Error()` displays a string and halts.\nK & P provide this as part of their Pascal environment. I have\nchosen to embed it here because it is short and trivial.\n\nTranslit suggested the \"Chars\" module because of the repetition in\nprevious programs. In K & P the approach to code reuse is to create\na separate source file and to included via a pre-processor. In\nOberon we have the module concept.\n\nMy [Chars](Chars.Mod) module provides a useful set of test\nprocedures like `IsAlpha(c)`, `IsUpper(c)`, `IsLower()` in addition\nto the `CharInRange()` and `IsAlphaNum()`.  It also includes\n`AppendChar()` which can be used to append a single character value\nto an end of an array of char.\n\n\nProgram Documentation\n---------------------\n\n[Page 56](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/56/mode/1up)\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n    translit    transliterate characters\n\nUSAGE\n\n    translit    [^]src [dest]\n\nFUNCTION\n\n    translit maps its input, on a character by character basis, and\n    writes the translated version to its output.In the simplest case,\n    each character is the argument src is translated to the\n    corresponding character is the argument dest; all other characters\n    are copies as is. Both the src and dest may contain substrings of\n    the form c1 - c2 as shorthand for all the characters in the range\n    c1..c2 and c2 must both be digits, or both be letter of the same\n    case. If dest is absent, all characters represented by src are\n    deleted. Otherwise, if dest is shorter than src, all characters\n    is src that would map to or beyond the last character in\n    dest are mapped to the last character in dest; moreover adjacent\n    instances of such characters in the input are represented in the\n    output by a single instance of the last character in dest. The\n\n        translit 0-9 9\n\n    converts each string of digits to the single digit 9.\n    Finally, if src is precedded by ^, then all but the characters\n    represented by src are taken as the source string; i.e., they are\n    all deleted if dest is absent, or they are all collapsed if the\n    last character in dest is present.\n\nEXAMPLE\n\n    To convert upper case to lower:\n\n        translit A-Z a-z\n\n    To discard punctualtion and isolate words by spaces on each line:\n\n        translit ^a-zA-Z@n \" \"\n        This is a simple-minded test, i.e., a test of translit.\n        This is a simple minded test i e a test of translit\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPascal Source\n-------------\n\n[translit.p, Page 48](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/48/mode/1up)\n\n[makeset.p, Page 52](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/52/mode/2up)\n\n\n[addstr.p, Page 53](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/53/mode/1up)\n\n[dodash.p, Page 53](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/53/mode/1up)\n\n[isalphanum.p, Page 54](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/54/mode/1up)\n\n[esc.p, Page 55](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/55/mode/1up)\n\n\n[length.p, Page 46](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/46/mode/1up)\n\n\nThe impacts of having a richer language than 1980s ISO Pascal and\nevolution in practice suggest a revision in the K & P approach. I\nhave attempted to keep the spirit of their example program while\nreflecting changes in practice that have occurred in the last four\ndecades.\n\n\nSource code for **Translit.Mod**\n--------------------------------\n\n~~~\nMODULE Translit;\nIMPORT In, Out, Args := extArgs, Strings, Chars;\n\nCONST\n    MAXSTR = 1024; (* or whatever *)\n    DASH = Chars.DASH;\n    ENDSTR = Chars.ENDSTR;\n    ESCAPE = \"@\";\n    TAB* = Chars.TAB;\n\n(* Error -- write an error string to standard out and\n   halt program *)\nPROCEDURE Error(s : ARRAY OF CHAR);\nBEGIN\n    Out.String(s);Out.Ln();\n    ASSERT(FALSE);\nEND Error;\n\n(* IsEscape - this procedure looks to see if we have an\nescape sequence at position in variable i *)\nPROCEDURE IsEscape*(src : ARRAY OF CHAR; i : INTEGER) : BOOLEAN;\nVAR res : BOOLEAN; last : INTEGER;\nBEGIN\n  res := FALSE;\n  last := Strings.Length(src) - 1;\n  IF (i < last) & (src[i] = ESCAPE) THEN\n    res := TRUE;\n  END;\n  RETURN res\nEND IsEscape;\n\n(* ExpandEscape - this procedure takes a source array, a\n   position and appends the escaped value to the destintation\n   array.  It returns TRUE on successuss, FALSE otherwise. *)\nPROCEDURE ExpandEscape*(src : ARRAY OF CHAR; i : INTEGER; VAR dest : ARRAY OF CHAR) : BOOLEAN;\nVAR res : BOOLEAN; j : INTEGER;\nBEGIN\n res := FALSE;\n j := i + 1;\n IF j < Strings.Length(src)  THEN\n    res := Chars.AppendChar(src[j], dest)\n END\n RETURN res\nEND ExpandEscape;\n\n(* IsSequence - this procedure looks at position i and checks\n   to see if we have a sequence to expand *)\nPROCEDURE IsSequence*(src : ARRAY OF CHAR; i : INTEGER) : BOOLEAN;\nVAR res : BOOLEAN;\nBEGIN\n  res := Strings.Length(src) - i >= 3;\n  (* Do we have a sequence of alphumeric character\n     DASH alpanumeric character? *)\n  IF res & Chars.IsAlphaNum(src[i]) & (src[i+1] = DASH) &\n            Chars.IsAlphaNum(src[i+2]) THEN\n      res := TRUE;\n  END;\n  RETURN res\nEND IsSequence;\n\n(* ExpandSequence - this procedure expands a sequence x\n   starting at i and append the sequence into the destination\n   string. It returns TRUE on success, FALSE otherwise *)\nPROCEDURE ExpandSequence*(src : ARRAY OF CHAR; i : INTEGER; VAR dest : ARRAY OF CHAR) : BOOLEAN;\nVAR res : BOOLEAN; cur, start, end : INTEGER;\nBEGIN\n  (* Make sure sequence is assending *)\n  res := TRUE;\n  start := ORD(src[i]);\n  end := ORD(src[i+2]);\n  IF start < end THEN\n    FOR cur := start TO end DO\n      IF res THEN\n        res := Chars.AppendChar(CHR(cur), dest);\n      END;\n    END;\n  ELSE\n    res := FALSE;\n  END;\n  RETURN res\nEND ExpandSequence;\n\n\n(* makeset -- make sets based on src expanded into destination *)\nPROCEDURE MakeSet* (src : ARRAY OF CHAR; start : INTEGER; VAR dest : ARRAY OF CHAR) : BOOLEAN;\nVAR i : INTEGER; makeset : BOOLEAN;\nBEGIN\n    i := start;\n    makeset := TRUE;\n    WHILE (makeset = TRUE) & (i < Strings.Length(src)) DO\n        IF IsEscape(src, i) THEN\n            makeset := ExpandEscape(src, i, dest);\n            i := i + 2;\n        ELSIF IsSequence(src, i) THEN\n            makeset := ExpandSequence(src, i, dest);\n            i := i + 3;\n        ELSE\n            makeset := Chars.AppendChar(src[i], dest);\n            i := i + 1;\n        END;\n    END;\n    RETURN makeset\nEND MakeSet;\n\n\n(* Index -- find position of character c in string s *)\nPROCEDURE Index* (VAR s : ARRAY OF CHAR; c : CHAR) : INTEGER;\nVAR\n    i, index : INTEGER;\nBEGIN\n    i := 0;\n    WHILE (s[i] # c) & (s[i] # ENDSTR) DO\n        i := i + 1;\n    END;\n    IF (s[i] = ENDSTR) THEN\n        index := -1; (* Value not found *)\n    ELSE\n        index := i; (* Value found *)\n    END;\n    RETURN index\nEND Index;\n\n(* XIndex -- conditionally invert value found in index *)\nPROCEDURE XIndex* (VAR inset : ARRAY OF CHAR; c : CHAR;\n    allbut : BOOLEAN; lastto : INTEGER) : INTEGER;\nVAR\n    xindex : INTEGER;\nBEGIN\n    (* Uninverted index value *)\n    xindex := Index(inset, c);\n    (* Handle inverted index value *)\n    IF (allbut = TRUE) THEN\n        IF (xindex = -1)  THEN\n            (* Translate as an inverted the response *)\n            xindex := 0; (* lastto - 1; *)\n        ELSE\n            (* Indicate no translate *)\n            xindex := -1;\n        END;\n    END;\n    RETURN xindex\nEND XIndex;\n\n(* Translit -- map characters *)\nPROCEDURE Translit* ();\nCONST\n    NEGATE = Chars.CARET; (* ^ *)\nVAR\n    arg, fromset, toset : ARRAY MAXSTR OF CHAR;\n    c : CHAR;\n    i, lastto : INTEGER;\n    allbut, squash : BOOLEAN;\n    res : INTEGER;\nBEGIN\n    i := 0;\n    lastto := MAXSTR - 1;\n    (* NOTE: We are doing low level of string manimulation. Oberon\n       strings are terminated by 0X, but Oberon compilers do not\n       automatically initialize memory to a specific state. In the\n       OBNC implementation of Oberon-07 assign \"\" to an assignment\n       like `s := \"\";` only writes a 0X to position zero of the\n       array of char. Since we are doing position based character\n       assignment and can easily overwrite a single 0X.  To be safe\n       we want to assign all the positions in the array to 0X so the\n       memory is in a known state.  *)\n    Chars.Clear(arg);\n    Chars.Clear(fromset);\n    Chars.Clear(toset);\n    IF (Args.count = 0) THEN\n        Error(\"usage: translit from to\");\n    END;\n    (* NOTE: I have not used an IF ELSE here because we have\n       additional conditions that lead to complex logic.  The\n       procedure Error() calls ASSERT(FALSE); which in Oberon-07\n       halts the program from further execution *)\n    IF (Args.count > 0) THEN\n        Args.Get(0, arg, res);\n        allbut := (arg[0] = NEGATE);\n        IF (allbut) THEN\n            i := 1;\n        ELSE\n            i := 0;\n        END;\n        IF MakeSet(arg, i, fromset) = FALSE THEN\n            Error(\"from set too long\");\n        END;\n    END;\n    (* NOTE: We have initialized our array of char earlier so we only\n       need to know if we need to update toset to a new value *)\n    Chars.Clear(arg);\n    IF (Args.count = 2) THEN\n        Args.Get(1, arg, res);\n        IF MakeSet(arg, 0, toset) = FALSE THEN\n            Error(\"to set too long\");\n        END;\n    END;\n\n    lastto := Strings.Length(toset);\n    squash := (Strings.Length(fromset) > lastto) OR (allbut);\n    REPEAT\n        In.Char(c);\n        IF In.Done THEN\n            i := XIndex(fromset, c, allbut, lastto);\n            IF (squash) & (i>=lastto) & (lastto>0) THEN (* translate *)\n                Out.Char(toset[lastto]);\n            ELSIF (i >= 0) & (lastto > 0) THEN    (* translate *)\n                Out.Char(toset[i]);\n            ELSIF i = -1 THEN                        (* copy *)\n              (* Do not translate the character *)\n              Out.Char(c);\n              (* NOTE: No else clause needed as not writing out\n\t\t\t     a cut value is deleting *)\n            END;\n        END;\n    UNTIL (In.Done # TRUE);\nEND Translit;\n\nBEGIN\n    Translit();\nEND Translit.\n\n~~~\n\n\n\nIn closing\n==========\n\nIn this chapter we interact with some of the most common features\nof command line programs available on POSIX systems. K & P have given\nus a solid foundation on which to build more complex and ambitious\nprograms. In the following chapters the read will find an\naccelerated level of complexity bit also programs that are\nsignificantly more powerful.\n\nOberon language evolved with the Oberon System which had a very\ndifferent rich text user interface when compared with POSIX.\nFortunately Karl's OBNC comes with a set of modules that make\nOberon-07 friendly for building programs for POSIX operating systems.\nI've taken advantage of his `extArgs` module much in the way\nthat K & P relied on a set of primitive tools to provide a common\nprogramming environment. K & P's version of\n[implementation of primitives](https://archive.org/details/softwaretoolsinp00kern/page/315/mode/1up)\nlisted in their appendix. Karl's OBNC extensions modules are\ndescribed on [website](https://miasap.se/obnc/obncdoc/ext/).\nOther Oberon compilers provide similar modules though implementation\nspecific. A good example is Spivey's [Oxford Oberon-2 Compiler](https://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler).\nK & P chose to target multiple Pascal implementations, I have the\nluxury of targeting one Oberon-07 implementation. That said if you\nadded a pre-processor like K & P did you could also take their approach\nto allow you Oberon-07 code to work across many Oberon compiler\nimplementations. I leave that as an exercise for the reader.\n\nI've chosen to revise some of the code presented in K & P's book. I\nbelieve the K & P implementations still contains wisdom in their\nimplementations. They had different constraints and thus made\ndifferent choices in implementation. Understand the trade offs and\nchallenges to writing portable code capable of running in very\ndivergent set of early 1980's operating systems remains useful today.\n\nCompiling with OBNC:\n\n~~~\n\n    obnc -o entab Entab.Mod\n    obnc -o overstrike Overstrike.Mod\n    obnc -o compress Compress.Mod\n    obnc -o expand Expand.Mod\n    obnc -o echo Echo.Mod\n    obnc -o translit Translit.Mod\n\n~~~\n\n+ [Entab](Entab.Mod)\n    + [Tabs](Tabs.Mod), this one visited this one in last installment.\n+ [Overstrike](Overstrike.Mod)\n+ [Compress](Compress.Mod)\n+ [Expand](Expand.Mod)\n+ [Echo](Echo.Mod)\n+ [Translit](Translit.Mod)\n\t+ [Chars](Chars.Mod)\n\n<!--\nNext and Previous\n-----------------\n\n+ Next: [Files]()\n-->\n\nPrevious\n--------\n\n+ Previous: [Getting Started](../../09/29/Software-Tools-1.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "keywords": [
          "Oberon",
          "Pascal",
          "Programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 2,
        "series": "Software Tools",
        "title": "Software Tools, Filters"
      },
      "url": "posts/2020/10/31/Filters.json"
    }
  ]
}s declared as a \"VAR\" parameter\nin our procedure heading. Our `SetDString` will also need to handle\ncreating new elements in our dynamic string. That is what Oberon's\nbuilt-in `NEW()` procedure does. It allocates new memory for our\nlist of records.\n\n\n~~~{.oberon}\n\n    PROCEDURE SetDString(VAR s : DString; buf : ARRAY OF CHAR);\n        VAR i : INTEGER; cur, tmp : DString;\n    BEGIN\n      (* Handle the case where s is NIL *)\n      IF s = NIL THEN\n        NEW(s);\n        s.value := 0X;\n        s.next := NIL;\n      END;\n      cur := s;\n      i := 0;\n      (* check to see if we are at end of string or array *)\n      WHILE (buf[i] # 0X) & (i < LEN(buf)) DO\n        cur.value := buf[i];\n        IF cur.next = NIL THEN\n          NEW(tmp);\n          tmp.value := 0X;\n          tmp.next := NIL;\n          cur.next := tmp;\n        END;\n        (* Advance our current pointer to the next element *)\n        cur := cur.next;\n        i := i + 1;\n      END;\n    END SetDString;\n\n~~~\n\n\nWe can move our string back into a fixed length array of char\nwith a similar procedure.\n\n\n~~~{.oberon}\n\n    PROCEDURE DStringToCharArray(s : DString; VAR buf : ARRAY OF CHAR);\n      VAR cur : DString; i, l : INTEGER;\n    BEGIN\n      l := LEN(buf);\n      i := 0;\n      cur := s;\n      WHILE (i < l) & (cur # NIL) DO\n        buf[i] := cur.value; \n        cur := cur.next;\n        i := i + 1;\n      END;\n      (* Zero out the rest of the string. *)\n      WHILE (i < l) DO\n        buf[i] := 0X;\n        i := i + 1;\n      END;\n    END DStringToCharArray;\n\n~~~\n\n\nAt this stage we have the basics of data organization. Modules\nallow us to group operations and data into cohesive focused units.\nProcedures allow us to define consistent ways of interacting with\nout data, and types singularly and collectively allow us to structure\ndata in a way that is useful to solving problems.\n\n## Putting it all together\n\nHere is a [module demoing our basic type](BasicTypeDemo.Mod). In it\nwe can define procedures to demo our assignments, display their results\nall called from inside the module's initialization block.\n\n\n~~~{.oberon}\n\n    MODULE BasicTypeDemo;\n      IMPORT Out;\n    \n      (* These are our custom data types definitions. *)\n      TYPE\n          TopThreeScoreboard = RECORD\n            gameName : ARRAY 24 OF CHAR;\n            playerNames : ARRAY 3, 24 OF CHAR;\n            scores : ARRAY 3 OF INTEGER\n          END;\n    \n          DStringDesc = RECORD\n            value : CHAR;\n            next : POINTER TO DStringDesc\n          END;\n    \n          DString = POINTER TO DStringDesc;\n    \n      (* Here are our private variables. *)\n      VAR \n        i : INTEGER;\n        a : REAL;\n        c: CHAR;\n        name : ARRAY 24 OF CHAR;\n        scores : ARRAY 10 OF INTEGER;\n        scoreboard : TopThreeScoreboard;\n        s : DString;\n    \n    \n      PROCEDURE SimpleTypes;\n      BEGIN\n        i := 7;\n        a := 7.1;\n        c := \"Z\";\n      END SimpleTypes;\n    \n      PROCEDURE DisplaySimpleTypes;\n      BEGIN\n        Out.String(\" i: \");Out.Int(i, 1);Out.Ln;\n        Out.String(\" a: \");Out.Real(a, 1);Out.Ln;\n        Out.String(\" c: \");Out.Char(c);Out.Ln;\n      END DisplaySimpleTypes;\n    \n    \n      PROCEDURE MoreComplexTypes;\n      BEGIN\n        scores[0] := 102;\n        name := \"Ada Lovelace\";\n        scoreboard.gameName := \"Basketball\";\n        scoreboard.playerNames[0] := \"Ada Lovelace\";\n        scoreboard.scores[0] := 102;\n        scoreboard.playerNames[1] := \"Blaise Pascal\";\n        scoreboard.scores[0] := 101;\n        scoreboard.playerNames[2] := \"John McCarthy\";\n        scoreboard.scores[0] := 100;\n      END MoreComplexTypes;\n    \n      PROCEDURE DisplayMoreComplexTypes;\n        VAR i : INTEGER;\n      BEGIN\n        i := 0;\n        Out.String(\" Game: \");Out.String(scoreboard.gameName);Out.Ln;\n        WHILE i < LEN(scoreboard.playerNames) DO\n          Out.String(\"    player, score: \");\n          Out.String(scoreboard.playerNames[i]);Out.String(\", \");\n          Out.Int(scoreboard.scores[i], 1);\n          Out.Ln;\n          i := i + 1;\n        END;\n      END DisplayMoreComplexTypes;\n    \n      PROCEDURE SetDString(VAR s : DString; buf : ARRAY OF CHAR);\n          VAR i : INTEGER; cur, tmp : DString;\n      BEGIN\n        (* Handle the case where s is NIL *)\n        IF s = NIL THEN\n          NEW(s);\n          s.value := 0X;\n          s.next := NIL;\n        END;\n        cur := s;\n        i := 0;\n        (* check to see if we are at end of string or array *)\n        WHILE (buf[i] # 0X) & (i < LEN(buf)) DO\n          cur.value := buf[i];\n          IF cur.next = NIL THEN\n            NEW(tmp);\n            tmp.value := 0X;\n            tmp.next := NIL;\n            cur.next := tmp;\n          END;\n          cur := cur.next;\n          i := i + 1;\n        END;\n      END SetDString;\n    \n      PROCEDURE DStringToCharArray(s : DString; VAR buf : ARRAY OF CHAR);\n        VAR cur : DString; i, l : INTEGER;\n      BEGIN\n        l := LEN(buf);\n        i := 0;\n        cur := s;\n        WHILE (i < l) & (cur # NIL) DO\n          buf[i] := cur.value; \n          cur := cur.next;\n          i := i + 1;\n        END;\n        (* Zero out the rest of the string. *)\n        WHILE (i < l) DO\n          buf[i] := 0X;\n          i := i + 1;\n        END;\n      END DStringToCharArray;\n    \n    BEGIN\n      SimpleTypes;\n      DisplaySimpleTypes;\n      MoreComplexTypes;\n      DisplayMoreComplexTypes;\n      (* Demo our dynamic string *)\n      Out.String(\"Copy the phrase 'Hello World!' into our dynamic string\");Out.Ln;\n      SetDString(s, \"Hello World!\");\n      Out.String(\"Copy the value of String s into 'name' our array of char\");Out.Ln;\n      DStringToCharArray(s, name);\n      Out.String(\"Display 'name' our array of char: \");Out.String(name);Out.Ln;\n    END BasicTypeDemo.\n\n~~~\n\n\n## Reading through the code\n\nThere are some nuances in Oberon syntax that can creep up on you.\nFirst while most statements end in a semi-colon there are noticeable\nexceptions. Look at the record statements in particular.  The last\nelement of your record before the `END` does not have a semicolon.\nIn that way it is a little like a `RETURN` value in a function\nlike procedure.\n\nIn creating our `DString` data structure the Oberon idiom is to first\ncreate a description record, `DStringDesc` then create a pointer to\nthe descriptive type, i.e. `DString`. This is a very common\nidiom in building out complex data structures. A good place to learn\nabout implementing algorithms and data structures in Oberon-07 is \nProf. Wirth's 2004 edition of [Algorithms and Data Structures](https://inf.ethz.ch/personal/wirth/AD.pdf) which\nis available from his personal website in PDF.\n\n\n### Next and Previous\n\n+ Next [Loops and Conditions](../19/Mostly-Oberon-Loops-and-Conditions.html)\n+ Previous [Modules and Procedures](../12/Mostly-Oberon-Modules.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-04-18",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 3,
        "series": "Mostly Oberon",
        "title": "Oberon Basic Types"
      },
      "url": "posts/2020/04/18/Mostly-Oberon-Basic-Types.json"
    },
    {
      "content": "\nOberon Loops and Conditions\n===========================\n\nBy R. S. Doiel, 2020-04-19\n\nThis is the four post in the [Mostly Oberon](../11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\n## Data Flow\n\nOberon is a small systems language and while it is minimalist.\nIt provides you with the necessary primitives to get things done.\nI've touched on code organization, basic types and basic type\nextensions in the previous articles.  I have shown the basic\ncontrol statements but have not talked about them yet.\n\nOberon offers four basic control statements. \n\nIF, ELSIF, ELSE\n: Basic condition test and execution\n\nASSERT\n: A mechanism to trigger a program halt\n\nWHILE DO, ELSIF DO\n: The Loop structure in the language (aside from recursive procedures)\n\nFOR TO, FOR TO BY\n: A counting Loop where incrementing a counter by an integer value (e.g. 1 or by a specified constant).\n\n## IF, ELSIF, ELSE\n\nThe first two provide for conditional statements of the form\nif a condition is true do something. Almost ever computer language\nhas some form of a conditional express and the Oberon IF, ELSIF,\nELSE typical of what you find is more computer languages today.\nBoth ELSIF and ELSE are optional.\n\n```Oberon\n    IF (s = \"Freda\") OR (s = \"Mojo\") THEN\n      Out.String(\"Wowie Zowie! I remember you from ZBS stories.\");Out.Ln;\n    ELSIF (s = \"Bilbo\") OR (s = \"Gandolf\") THEN\n      Out.String(\"Greets, I remember from the Hobbit.\");Out.Ln;\n    ELSE\n      Out.String(\"Glad to meet you \");Out.String(s);Out.Ln;\n    END;\n```\n\n## ASSERT\n\nThe second expression, ASSERT, is a little different. If ASSERT\nevaluates an expression that is FALSE then your program is halted.\nThis is like combining an \"if EXPR is false then system exit\".\n\n```Oberon\n    Out.String(\"Should I continue? Y/n \");\n    In.Line(s);\n    Out.Ln;\n    ASSERT((s = \"Y\") OR (s = \"y\"));\n    (* If you didn't enter Y or y the program will halt *)\n```\n\n\n## WHILE DO, ELSIF DO\n\nOberon-07 also provides two loop structures. These are very \nsimilar to other languages as well. The only expectation is that\na while loop may contain an ELSIF which continues the loop\nexecution until both clauses return FALSE.\n\nThe basic while loop, counting 1 to 10.\n\n```Oberon\n    i := 0;\n    WHILE i < 10 DO\n       i := i + 1;\n       Out.Int(i, 1);Out.String(\" \");\n    END;\n```\n\nA while, elsif loop, counting 1 to 10, then 10 to 100 by 10.\n\n```Oberon\n    i := 0;\n    WHILE i < 10 DO\n       i := i + 1;\n       Out.Int(i, 1); Out.String(\" \");\n    ELSIF i < 100 DO\n       i := i + 10;\n       Out.Int(i, 1);Out.String(\" \");\n    END;\n```\n\n\n## FOR Loops\n\nThe FOR loop in Oberon is very similar to modern FOR loops.\nThe FOR loop increments an integer value with in a range.\nYou the default increments the start value by 1 but if a \nBY clause is included you can control how the increment value\nworks.\n\nRegular for loop, `i` is incremented by 1.\n\n```Oberon\n    FOR i := 1 TO 10 DO\n       Out.Int(i, 1);Out.String(\" \");\n    END;\n```\n\nUsing a BY clause incrementing `i` by 2.\n\n```Oberon\n    FOR i := 0 TO 20 BY 2  DO\n       Out.Int(i, 1);Out.String(\" \");\n    END;\n```\n\n\n## Putting it all together\n\nThe following [module](LoopsAndConditions.Mod) demonstrates\nthe conditional and loop syntax.\n\n```Oberon\n    MODULE LoopsAndConditions;\n      IMPORT In, Out;\n    \n    PROCEDURE IfElsifElseDemo;\n      VAR s : ARRAY 128 OF CHAR;\n    BEGIN\n      Out.String(\"Enter your name: \");\n      In.Line(s);\n      Out.Ln;\n      IF (s = \"Freda\") OR (s = \"Mojo\") THEN\n        Out.String(\"Wowie Zowie! I remember you from ZBS stories.\");Out.Ln;\n      ELSIF (s = \"Bilbo\") OR (s = \"Gandolf\") THEN\n        Out.String(\"Greets, I remember from the Hobbit.\");Out.Ln;\n      ELSE\n        Out.String(\"Glad to meet you \");Out.String(s);Out.Ln;\n      END;\n    END IfElsifElseDemo;\n    \n    PROCEDURE AssertDemo;\n      VAR s : ARRAY 128 OF CHAR;\n    BEGIN\n      Out.String(\"Should I continue? Y/n \");\n      In.Line(s);\n      Out.Ln;\n      ASSERT((s = \"Y\") OR (s = \"y\"));\n    END AssertDemo;\n    \n    PROCEDURE WhileDemo;\n      VAR i : INTEGER;\n    BEGIN\n      Out.String(\"Basic WHILE counting from 1 to 10\");Out.Ln;\n      i := 0;\n      WHILE i < 10 DO\n         i := i + 1;\n         Out.Int(i, 1);Out.String(\" \");\n      END;\n      Out.Ln;\n      Out.String(\"WHILE ELSIF, count 1 to 10 THEN 10 to 100\");Out.Ln;\n      i := 0;\n      WHILE i < 10 DO\n         i := i + 1;\n         Out.Int(i, 1); Out.String(\" \");\n      ELSIF i < 100 DO\n         i := i + 10;\n         Out.Int(i, 1);Out.String(\" \");\n      END;\n      Out.Ln;\n      Out.String(\"Demo of while loop counting one to ten, then by tenths.\");\n    END WhileDemo;\n    \n    PROCEDURE ForDemo;\n      VAR i : INTEGER;\n    BEGIN\n      Out.String(\"Basic FOR LOOP counting from 1 to 10\");Out.Ln;\n      FOR i := 1 TO 10 DO\n         Out.Int(i, 1);Out.String(\" \");\n      END;\n      Out.Ln;\n      Out.String(\"FOR loop counting by twos 1 to 20\");Out.Ln;\n      FOR i := 0 TO 20 BY 2  DO\n         Out.Int(i, 1);Out.String(\" \");\n      END;\n      Out.Ln;\n    END ForDemo;\n    \n    BEGIN\n      IfElsifElseDemo;\n      AssertDemo;\n      WhileDemo;\n      ForDemo;\n    END LoopsAndConditions.\n```\n\n\n### Next and Previous\n\n+ Next [Combining Oberon-07 and C with OBNC](../../05/01/Combining-Oberon-and-C.html)\n+ Previous [Basic Types](../18/Mostly-Oberon-Basic-Types.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-04-19",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 4,
        "series": "Mostly Oberon",
        "title": "Oberon Loops and Conditions"
      },
      "url": "posts/2020/04/19/Mostly-Oberon-Loops-and-Conditions.json"
    },
    {
      "content": "\n\n# Combining Oberon-07 and C with OBNC\n\nBy R. S. Doiel, 2020-05-01\n\nThis is the fifth post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html)\nseries. Mostly Oberon documents my exploration of the Oberon\nLanguage, Oberon System and the various rabbit holes I will\ninevitably fall into.\n\nIn my day job I write allot of code in Go and\norchestration code in Python.  It's nice having\nthe convenience of combining code written one\nlanguage with an another.  You can do the same\nwith [OBNC](https://miasap.se/obnc/).  The OBNC\ncompiler supports inclusion of C code in a\nstraight forward manner. In fact Karl's compiler\nwill generate the C file for you!\n\nIn learning how to combine C code and Oberon-07\nI started by reviewing Karl's [manual page](https://miasap.se/obnc/man/obnc.txt).\nThe bottom part of that manual page describes\nthe steps I will repeat below. The description\nsounds more complicated but when you walk through\nthe steps it turns out to be pretty easy.\n\n## Basic Process\n\nCreating a C extension for use with OBNC is very\nstraight forward.\n\n1. Create a Oberon module with empty exported procedures\n2. Create a Oberon test module that uses your module\n3. Compile your test module with OBNC\n4. Copy the generated module `.c` file to the same directory as your Oberon module source\n5. Edit the skeleton `.c`,  re-compile and test\n\nFive steps may sound complicated but in practice is\nstraight forward.\n\n## Fmt, an example\n\nIn my demonstration of Karl's instructions I will be\ncreating a module named `Fmt` that includes two\nprocedures `Int()` and `Real()` that let you use\na C-style format string to format an INTEGER\nor REAL as an ARRAY OF CHAR. We retain the idiomatic\nway Oberon works with types but allow a little more\nflexibility in how the numbers are converted and\nrendered as strings.\n\n### Step 1\n\nCreate [Fmt.Mod](Fmt.Mod) defining two exported procedures\n`Int*()` and `Real*()`. The procedures body should be\nempty. Karl's practice is to use exported comments to\nexplain the procedures.\n\n\n~~~ {.oberon}\n\n    MODULE Fmt;\n\n    \tPROCEDURE Int*(value : INTEGER; fmt: ARRAY OF CHAR;\n                       VAR dest : ARRAY OF CHAR);\n    \tEND Int;\n\n    \tPROCEDURE Real*(value : REAL; fmt: ARRAY OF CHAR;\n                        VAR dest : ARRAY OF CHAR);\n    \tEND Real;\n\n    BEGIN\n    END Fmt.\n\n~~~\n\n\n### Step 2\n\nCreate a test module, [FmtTest.Mod](FmtTest.Mod), for\n[Fmt.Mod](Fmt.Mod).\n\n\n~~~ {.oberon}\n\n    MODULE FmtTest;\n      IMPORT Out, Fmt;\n\n    PROCEDURE TestInt(): BOOLEAN;\n      VAR\n        fmtString : ARRAY 24 OF CHAR;\n        dest : ARRAY 128 OF CHAR;\n        i : INTEGER;\n    BEGIN\n        i := 42;\n        fmtString := \"%d\";\n        Fmt.Int(i, fmtString, dest);\n        Out.String(dest);Out.Ln;\n        RETURN TRUE\n    END TestInt;\n\n    PROCEDURE TestReal(): BOOLEAN;\n      VAR\n        fmtString : ARRAY 24 OF CHAR;\n        dest : ARRAY 128 OF CHAR;\n        r : REAL;\n    BEGIN\n        r := 3.145;\n        fmtString := \"%d\";\n        Fmt.Real(r, fmtString, dest);\n        Out.String(dest);Out.Ln;\n        RETURN TRUE\n    END TestReal;\n\n    BEGIN\n      ASSERT(TestInt());\n      ASSERT(TestReal());\n      Out.String(\"Success!\");Out.Ln;\n    END FmtTest.\n\n~~~\n\n\n### Step 3\n\nGenerate a new [Fmt.c](Fmt.c) by using the\nOBNC compiler.\n\n\n~~~ {.shell}\n\n    obnc FmtTest.Mod\n    mv .obnc/Fmt.c ./\n\n~~~\n\n\nthe file `.obnc/Fmt.c` is your C template file. Copy it\nto the directory where Fmt.Mod is.\n\n### Step 4\n\nUpdate the skeleton `Fmt.c` with the necessary C code.\nHere's what OBNC generated version.\n\n\n~~~ {.c}\n\n    /*GENERATED BY OBNC 0.16.1*/\n\n    #include \"Fmt.h\"\n    #include <obnc/OBNC.h>\n\n    #define OBERON_SOURCE_FILENAME \"Fmt.Mod\"\n\n    void Fmt__Int_(OBNC_INTEGER value_, const char fmt_[], \n                   OBNC_INTEGER fmt_len, char dest_[], \n                   OBNC_INTEGER dest_len)\n    {\n    }\n\n\n    void Fmt__Real_(OBNC_REAL value_, const char fmt_[],\n                    OBNC_INTEGER fmt_len, char dest_[],\n                    OBNC_INTEGER dest_len)\n    {\n    }\n\n\n    void Fmt__Init(void)\n    {\n    }\n\n~~~\n\n\nHere's the skeleton revised with do what we need to be done.\n\n\n~~~ {.c}\n\n    #include \".obnc/Fmt.h\"\n    #include <obnc/OBNC.h>\n    #include <stdio.h>\n\n    #define OBERON_SOURCE_FILENAME \"Fmt.Mod\"\n\n    void Fmt__Int_(OBNC_INTEGER value_, \n                   const char fmt_[], OBNC_INTEGER fmt_len,\n                   char dest_[], OBNC_INTEGER dest_len)\n    {\n        sprintf(dest_, fmt_, value_);\n    }\n\n\n    void Fmt__Real_(OBNC_REAL value_, const char fmt_[],\n                    OBNC_INTEGER fmt_len, char dest_[],\n                    OBNC_INTEGER dest_len)\n    {\n        sprintf(dest_, fmt_, value_);\n    }\n\n\n    void Fmt__Init(void)\n    {\n    }\n\n~~~\n\n\nNOTE: You need to change the path for the `Fmt.h` file reference.\nI also add the `stdio.h` include so I have access to the C\nfunction I wish to use. Also notice how OBNC the signature\nfor the functions use the `_` character to identify mapped values\nas well as the char arrays being provided with a length parameter.\nIf you are doing more extensive string work you'll want to take\nadvantage of these additional parameters so insure that the\nas strings are terminated properly for Oberon's reuse.\n\n\n### Step 5\n\nRecompile and test.\n\n\n~~~ {.shell}\n\n    obnc FmtTest.Mod\n    ./FmtTest\n\n~~~\n\n\n### Next and Previous\n\n+ Next [Compiling OBNC on macOS](../06/Compiling-OBNC-on-macOS.html)\n+ Previously [Oberon Loops and Conditions](../../04/19/Mostly-Oberon-Loops-and-Conditions.html)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-05-01",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 5,
        "series": "Mostly Oberon",
        "title": "Combining Oberon-07 and C with OBNC"
      },
      "url": "posts/2020/05/01/Combining-Oberon-and-C.json"
    },
    {
      "content": "\nCompiling OBNC on macOS \n=======================\n\nBy R. S. Doiel, 2020-05-06\n\nThis is the sixth post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\nCompiling OBNC v0.16.1 on macOS (10.13.6) using MacPorts (2.6.2) \nis straight forward if you have the required dependencies and \nenvironment setup up. Below are my notes to get everything working.\n\n## Prerequisites\n\n+ OBNC v0.16.1\n+ SDL v1.2\n+ Boehm-Demers-Weiser GC\n+ A C compiler and linker (OBNC uses this to generate machine specific code)\n\n### SDL 1.2\n\nMacPorts has libsdl 1.2 available as a package called \"libsdl\"\n(not surprisingly). There are other versions of the SDL available\nin ports but this is the one we're using.\n\n\n~~~\n\n   sudo port install libsdl\n\n~~~\n\n\n### The Boehm-Demers-Weiser GC\n\nYou need to install the Boehm-Demers-Weiser GC installed. Using\nMacPorts it is almost as easy as installing under Debian. The\npackage is less obviously named than under Debian. The package\nyou want is \"beohmgc\".\n\n\n~~~\n\n    sudo port install boehmgc\n\n~~~\n\n\nMore info on the GC.\n\n+ [The Boehm-Demers-Weiser GC](https://www.hboehm.info/gc/)\n+ [MacPorts page](https://ports.macports.org/port/boehmgc/summary)\n\n### C compiler and linker\n\nXCode is provides a C compiler and linker. That is what is installed on my\nmachine. It can be a bit of a pain at times with obscure errors, particularly with regards to the linker. Your milleage may very. I know you can\ninstall other C compilers (e.g. Clang) but I haven't tried them yet.\n\n## Setting up my environment\n\nYou need to update your CC variables to find the header and\nshared library files for compilation of obnc with `build`. (I added\nthese to my `.bash_profile`). New Macs ships with zsh and\nyour settings might be in a different location. MacPorts puts \nits libraries under the `/opt/local` directory.\n\n\n~~~\n\n    export C_INCLUDE_PATH=\"/usr/include:/usr/local/include:/opt/local/include\"\n    export LIBRARY_PATH=\"/usr/lib:/usr/local/lib:/opt/local/lib\"\n    export LD_LIBRARY_PATH=\"/usr/lib:/usr/local/lib:/opt/local/lib\"\n\n~~~\n\n\n## OBNC environment variables\n\nThis follows' Karl's docs.  Additionally if you install OBNC extlib so\nyou can do POSIX shell programs you'll need to set your\n`OBNC_IMPORT_PATH` environment.  An example of including a default\ninstall location and local home directory location.\n\n\n~~~\n\n    export OBNC_IMPORT_PATH=\"/usr/local/lib/obnc:$HOME/lib/obnc\"\n\n~~~\n\n\n### Next and Previous\n\n+ Next [Oberon-07 and the file system](../09/Oberon-07-and-the-filesystem.html)\n+ Previous [Combining Oberon-07 and C](../01/Combining-Oberon-and-C.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-05-06",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 6,
        "series": "Mostly Oberon",
        "title": "Compiling OBNC on macOS"
      },
      "url": "posts/2020/05/06/Compiling-OBNC-on-macOS.json"
    },
    {
      "content": "\n\n# Oberon-07 and the file system\n\nBy R. S. Doiel, 2020-05-09 (updated: 2021-10-29)\n\nThis is the seventh post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\n## Working with files in Oberon-07\n\nIn a POSIX system we often talk of opening files,\nwriting and reading files and close files. The Oberon\nlanguage reflects a more Oberon System point of view.\n\nThe Oberon System generally avoids modality in favor\nof action. Modality is where a context must be set\nbefore a set of actions are possible. The `vi` \ntext editor is a \"modal\" editor. You are in either\nedit (typing) mode or command mode. At the function\nlevel POSIX's `open()`, is also modal. You can \nopen a file for reading, open a file for writing,\nyou can open a file for appending, etc. The Oberon\nlanguage and base modules avoids modality.\n\nThe Oberon System is highly interactive but\nhas a very different idea about code, data and computer\nresources. In POSIX the basic unit of code is a program\nand the basic unit of execution is a program. In Oberon\nthe basic unit of code is the module and the basic unit\nof execution is the procedure.  Modules are brought into \nmemory and persist. As a result it is common in \nthe Oberon System to need to have file representations \nthat can persist across procedure calls. It provides\na set of abstractions that are a little bit like views\nand cursors found in database systems. In taking\nthis approach Oberon language eschews modality at the\nprocedure level. \n\nNOTE: Modules can be explicitly unload otherwise they persist until the computer is turned off\n\n## Key Oberon Concepts\n\nThe following are exported in the `Files` module.\n\nFile\n: is a handle to the representation of a file, a File and Rider form a view into a file.\n\nRider\n: similar to a database cursor, it is the mechanism that lets you navigate in a file\n\nNew\n: Creates a new file (in memory but not on disc).\n\nRegistration\n: Associates a file handle created with New with the file system. A file must be registered to persist in the file system.\n\nOld\n: Opens an existing file for use.\n\nSet\n: Set the position of a rider in a file\n\nPos\n: Gets the position of a rider in a file\n\nClose\n: Writes out unwritten buffers in file to disc, file handle is still value as is the rider.\n\nPurge\n: Sets a file's length to zero.\n\nDelete\n: Unregister the filename with the file system.\n\nIn the Oberon Systems a file can be \"opened\" many\ntimes with only one copy maintained in memory. This allows\nefficient operations across a module's procedures.\nLikewise a file can have one or more Riders associated with\nit. Each rider can move through the file independently operating on\nthe common in memory file. If a file is created with `New` but\nnot registered it can be treated like an in-memory temp file.\nClosing a file writes its buffers but the file remains accessible\nthrough it handle and riders. If a file is not modified it\ndoesn't need to be closed.\n\nIn POSIX we generally want to explicitly close the file when\nwe're through. In the Oberon language we only need to close\na file if we've modified it.\n\nThe behavior of files and riders in Oberon creates interesting\nnuances around deleting files.  The Delete operation can in\nprinciple happen multiple times before the file is deleted on\ndisc.  That is because the file handles and riders may still\nbe operating on it.  To know when a file is finally deleted \nwhen `Delete` procedure is called it includes a results\nparameter. When that value is set to zero by the `Delete`\nprocedure you know your file has been deleted.\n\nThe `Files` module provides a number of methods\nto read and write basic Oberon types. These use the rider\nrather than the file handle. Calling them automatically\nupdates the riders position. The procedures themselves\nmap to what we've seen in the modules `In` and `Out`.  \nThere are a few additional commands for file system house \nkeeping such as `Length`, `GetDate`, `Base`.\nSee the OBNC documentation for the `Files` module for\ndetails <https://miasap.se/obnc/obncdoc/basic/Files.def.html>.\n\nIn the following examples we'll be using the `Files`\nmodule to create, update and delete a file called \n`HelloWorld.txt`.\n\n### Creating a file\n\nThe recipe we want to follow for creating a file is\nNew (creates an empty file in memory), Register\n(associations the filename with the file system), \nSet the rider position, with the rider write our\ncontent and with the file call close because we've\nhave changed the file.\n\nLike our origin `SayingHi` we'll demonstrate this code\nin a new module called `TypingHi.Mod`. Below is\na procedure called `WriteHelloWorld`. It shows how\nto create, write and close the new file called\n\"HelloWorld.txt\".\n\n\n~~~\n\n  PROCEDURE WriteHelloWorld;\n    VAR\n      (* Define a file handle *)\n      f : Files.File;\n      (* Define a file rider *)\n      r : Files.Rider;\n  BEGIN\n    (* Create our file, New returns a file handle *)\n    f := Files.New(\"HelloWorld.txt\");\n    (* Register our file with the file system *)\n    Files.Register(f);\n    (* Set the position of the rider to the beginning *)\n    Files.Set(r, f, 0);\n    (* Use the rider to write out \"Hello World!\" *)\n    Files.WriteString(r, \"Hello World!\");\n    (* Write a end of line *)\n    Files.Write(r, 10);\n    (* Close our modified file *)\n    Files.Close(f);\n  END WriteHelloWorld;\n\n~~~\n\n\n#### Receipt in review\n\n+ New, creates our file\n+ Register, associates the file handle with the file system \n+ Set initializes the rider's position\n+ WriteString, writes our \"Hello World!\" to the file\n+ Close, closes the file, flushing unwritten content to disc\n\n\n### Working with an existing file\n\nIf we're working with an existing file we swap `New` for \na procedure named `Old`. We don't need to register the\nfile because it already exists.  We still need to set\nour rider and we want to read back the string we previously wrote.\nWe don't need to close it because we haven't\nmodified it. To demonstrate a new procedure is added to\nour module called `ReadHelloWorld`.\n\n\n~~~\n\n  PROCEDURE ReadHelloWorld;\n    VAR\n      f : Files.File;\n      r : Files.Rider;\n      (* We need a string to store what we have read *)\n      src : ARRAY 256 OF CHAR;\n  BEGIN\n    (* Create our file, New returns a file handle *)\n    f := Files.Old(\"HelloWorld.txt\");\n    (* Set the position of the rider to the beginning *)\n    Files.Set(r, f, 0);\n    (* Use the rider to write out \"Hello World!\" *)\n    Files.ReadString(r, src);\n    (* Check the value we read, if it is not the name, \n       halt the program with an error *)\n    ASSERT(src = \"Hello World!\");\n  END ReadHelloWorld;\n\n~~~\n\n\n#### Receipt in review\n\n+ Old, gets returns a file handle for an existing file\n+ Set initializes the rider's position\n+ ReadString, read our \"Hello World!\" string from the file\n+ Check the value we read with an ASSERT\n\n### Removing a file\n\nDeleting the file only requires knowing the name of the file.\nLike in `ReadHelloWorld` we'll use the built-in ASSERT\nprocedure to check if the file was successfully removed.\n\n\n~~~\n\n  PROCEDURE DeleteHelloWorld;\n    VAR\n      result : INTEGER;\n  BEGIN\n    (* Delete our file *)\n    Files.Delete(\"HelloWorld.txt\", result);\n    (* Check our result, if not zero then halt program with error *)\n    ASSERT(result = 0);\n  END DeleteHelloWorld;\n\n~~~\n\n\n#### Receipt in review\n\n+ Delete the file setting a result value\n+ Check the value with ASSERT to make sure it worked\n\n## Putting it all together.\n\nHere is the full listing of our module.\n\n\n~~~\n\n    MODULE TypingHi;\n      IMPORT Files;\n    \n      PROCEDURE WriteHelloWorld;\n        VAR\n          (* Define a file handle *)\n          f : Files.File;\n          (* Define a file rider *)\n          r : Files.Rider;\n      BEGIN\n        (* Create our file, New returns a file handle *)\n        f := Files.New(\"HelloWorld.txt\");\n        (* Register our file with the file system *)\n        Files.Register(f);\n        (* Set the position of the rider to the beginning *)\n        Files.Set(r, f, 0);\n        (* Use the rider to write out \"Hello World!\" *)\n        Files.WriteString(r, \"Hello World!\");\n        (* Write a end of line *)\n        Files.Write(r, 10);\n        (* Close our modified file *)\n        Files.Close(f);\n      END WriteHelloWorld;\n    \n      PROCEDURE ReadHelloWorld;\n        VAR\n          f : Files.File;\n          r : Files.Rider;\n          (* We need a string to store what we have read *)\n          src : ARRAY 256 OF CHAR;\n      BEGIN\n        (* Create our file, New returns a file handle *)\n        f := Files.Old(\"HelloWorld.txt\");\n        (* Set the position of the rider to the beginning *)\n        Files.Set(r, f, 0);\n        (* Use the rider to write out \"Hello World!\" *)\n        Files.ReadString(r, src);\n        (* Check the value we read, if it is not the name, \n           halt the program with an error *)\n        ASSERT(src = \"Hello World!\");\n      END ReadHelloWorld;\n    \n      PROCEDURE DeleteHelloWorld;\n        VAR\n          result : INTEGER;\n      BEGIN\n        (* Delete our file *)\n        Files.Delete(\"HelloWorld.txt\", result);\n        (* Check our result, if not zero then halt program with error *)\n        ASSERT(result = 0);\n      END DeleteHelloWorld;\n    \n    BEGIN\n        WriteHelloWorld();\n        ReadHelloWorld();\n        DeleteHelloWorld();\n    END TypingHi.\n\n~~~\n\n## Post Script, 2021-10-29\n\nOn October 29, 2021 I had an email conversation with Jules. It pointed out a problem in this implementation of Hello World.  I had incorrectly coded the end of line with `Files.WriteString(r, 0AX);` this is wrong.  At best it should have been `Files.Write(r, 10);`. There remains an issues with `Files.WriteString(\"Hello World!\");`. The Oakwood module `Files` defines \"WriteString\" to include the trailing NULL character. This will be output in the file. It all depends on how close to the Oakwood specification that your compiler implements the `Files` module.\n\n\n\n### Next and Previous\n\n+ Next [Dynamic Types](../25/Dynamic-types.html)\n+ Previous [Compiling OBNC on macOS](../06/Compiling-OBNC-on-macOS.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-05-09",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 7,
        "series": "Mostly Oberon",
        "title": "Oberon-07 and the file system",
        "updated": "2021-10-29"
      },
      "url": "posts/2020/05/09/Oberon-07-and-the-filesystem.json"
    },
    {
      "content": "\n\n# Dynamic types\n\nBy R. S. Doiel, 2020-05-25\n\nThis is the eighth post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html)\nseries. Mostly Oberon documents my exploration of the Oberon Language, \nOberon System and the various rabbit holes I will inevitably fall into.\n\n## Dynamic Types in Oberon\n\nOberon-07 is a succinct systems language. It provides a minimal\nbut useful set of basic static types. Relying on them addresses \nmany common programming needs. The Oberon compiler ensures \nstatic types are efficiently allocated in memory. One of the \nstrengths of Oberon is this ability to extend the type system. \nThis means when the basic types fall short you can take \nadvantage of Oberon's type  extension features. This includes \ncreating dynamically allocated data structures. In Oberon-07 \ncombining Oberon's `POINTER TO` and `RECORD` types allows us to\ncreate complex and dynamic data structures. \n\n\n## An example, dynamic strings \n\nStrings in Oberon-07 are typical declared as an `ARRAY OF CHAR` \nwith a specific length. If the length of a string is not \nknown a head of time this presents a challenge. One approach is \nto declare a long array but that would allocate allot of memory \nwhich may not get used. Another approach is to create a dynamic\ndata structure. An example is using a linked list of shorter \n`ARRAY OF CHAR`.  The small fixed strings can combine to \nrepresent much larger strings. When one fills up we add \nanother. \n\n### Pointers and records, an Oberon idiom \n\nOur data model is a pointer to a record where the record \ncontains an `ARRAY OF CHAR` and a pointer to the next record. \nA common idiom in Oberon for dynamic types is to declare a \n`POINTER TO` type and declare a `RECORD` type which contains\nthe `POINTER TO` type as an attribute.  If you see this idiom \nyou are looking at some sort of dynamic data structure. The \npointer type is usually named for the dynamic type you want \nwork with and the record type is declared using the same name \nwith a \"Desc\" suffix. In our case `DynamicString` will be the \nname of our `POINTER TO` type and our record type will be \ncalled `DynamicStringDesc` following the convention.  In our \nrecord structure we include a \"value\" to holding a short \nfixed length `ARRAY OF CHAR`  and a \"next\" to holding the \npointer to our next record.\n\nIn our record the value is declared as a static type. We need\nto know how long our \"short\" string should be? I.e. What length\nis our `ARRAY OF CHAR`? It's a question of tuning. If it is too \nshort we spend more time allocating new records, too long and \nwe are wasting memory in each record. A way to make tuning a \nlittle simpler is to use a constant value to describe our array \nlength. Then if we decide our array is too big \nor too small we can adjust the constant knowing that our record \nstructure and the procedures that use that the length \ninformation will continue to work correctly. \n\nLet's take a look at actual code (NOTE: vSize is our constant value). \n\n~~~\n\n    CONST\n      vSize = 128; \n    \n    TYPE\n      DynamicString* = POINTER TO DynamicStringDesc;\n      DynamicStringDesc* = RECORD \n        value : ARRAY vSize OF CHAR; \n        next : DymamicString; \n      END;\n\n~~~\n\nNOTE: Both `DynamicString` and `DynamicStringDesc` are defined \nusing an `*`. These are public and will be available \nto other modules.  Inside our record `DynamicStringDesc` we \nhave two private to our module attributes, `.value` and \n`.next`. They are private so that we can change our \nimplementation in the future without requiring changes in \nmodules that use our dynamic strings. Likewise our constant `vSize`\nis private as that is an internal implementation detail. This\npractice is called information hiding.\n\nNOTE: The asterisk in Oberon decorates procedures, types, variables\nand constants that are \"public\" to other modules.\n\nNOTE: Variables are always exported read only.\n\nNOTE: With information hiding some details of implementation allow us \nto keep a clean division between implementation inside the module and how\nthat implementation might be used. With out information hiding we often\nhave \"leaky\" abstractions that become brittle and hard to maintain and\nrely on.\n\n\n\n## Working with DynamicString\n\nOur type definitions describe to the compiler how to layout our \ndata in memory. The type system in Oberon-07 also ensures that \naccess to that memory is restricted to assignments, operations \nand procedures compatible with that type. To be useful from \nother modules we need a few procedures to help work with\nthis new data type. What follows is a minimal set needed to be \nuseful.\n\n### `New*(VAR str : DynamicString)`\n\n`New` will initialize a DynamicString object setting `.value` to \nan empty string. \n\n\n~~~\n\n  PROCEDURE New*(VAR str : DynamicString);\n  BEGIN NEW(str);\n    str.value := \"\"; \n    str.next := NIL;\n  END New;\n\n~~~\n\n\n### `Set*(VAR str : DynamicString; source : ARRAY OF CHAR)` \n\n`Set` copies an `ARRAY OF CHAR` into an existing DynamicString. \nThis requires that we add and link additional records if the \n`source` is longer than our current dynamic string. Set is a \nbridge procedure between an existing datatype, `ARRAY OF CHAR` \nand our new data type, `DynamicString`.\n\n\n~~~\n\n  PROCEDURE Set*(VAR str : DynamicString; source : ARRAY OF CHAR); \n    VAR cur, next : DynamicString; tmp : ARRAY vSize OF CHAR; \n        i, l : INTEGER;\n  BEGIN cur := str; cur.value := \"\";\n    l := Strings.Length(source);\n    i := 0; \n    WHILE i < l DO\n      Strings.Extract(source, i, i + vSize, tmp);\n      Strings.Append(tmp, cur.value);\n      i := i + Strings.Length(tmp);\n      IF (i < l) THEN\n        IF cur.next = NIL THEN\n          New(next); cur.next := next;\n        END;\n        cur := cur.next;\n      END; \n    END;\n  END Set;\n\n~~~\n\n### `ToCharArray*(str : DynamicString; VAR dest : ARRAY OF CHAR; VAR ok : BOOLEAN)`\n\n`ToCharArray` copies the contents of our dynamic string into an array \nof char setting `ok` to TRUE on success or FALSE if truncated. \nLike `Set*` it is a bridge procedure to let us move data output \nour new dynamic string type.\n\n\n~~~\n\n  PROCEDURE ToCharArray*(str : DynamicString; \n                         VAR dest : ARRAY OF CHAR; \n                         VAR ok : BOOLEAN);\n    VAR cur : DynamicString; i : INTEGER;\n  BEGIN \n    ok := FALSE;\n    cur := str; i := 0;\n    WHILE cur # NIL DO\n      i := i + Strings.Length(cur.value);\n      Strings.Append(cur.value, dest);\n      cur := cur.next;\n    END;\n    ok := (i = Strings.Length(dest));\n  END ToCharArray;\n\n~~~\n\nTwo additional procedures will likely be needed-- `Append` and \n`AppendCharArray`. This first one is trivial, if we want to add \none dynamic string onto another all we need to do is link the \nlast record of the first and point it to a copy of the second string we're appending.\n\n\n### `Append*(extra : DynamicString; VAR dest : DynamicString);`\n\n`Append` adds the `extra` dynamic string to `dest` dynamic string. Our \n\"input\" is `extra` and our output is a modified dynamic string \nnamed `dest`. This parameter order mimics the standard \n`Strings` module's `Append`.\n\nNOTE: Oberon idiom is often input values, modified value and \nresult values. Modified and result values are declared in the parameter\ndefinition using `VAR`.\n\nAlgorithm:\n\n1. Move to the end of `dest` dynamic string\n2. Create a new record at `cur.next`.\n3. Copy `extra.value` info.value `cur.next.value`\n4. Advance `extra` and `cur`, repeating steps 2 to 4 as needed.\n\nImplemented procedure.\n\n~~~\n\n  PROCEDURE Append*(extra: DynamicString; VAR dest : DynamicString);\n    VAR cur : DynamicString;  \n  BEGIN\n    (* Move to the end of the dest DynamicString *)\n    cur := dest;\n    WHILE cur.next # NIL DO cur := cur.next; END;\n    (* Starting initial pointer of `extra` copy its records\n       input new records created in `cur`. *)\n    WHILE extra # NIL DO\n      (* Create a new record *)\n      NEW(cur.next);\n      cur.next.value := \"\";\n      cur.next.next := NIL;\n      (* Copy extra.value into new record *)\n      Strings.Extract(extra.value, 0, vSize, cur.next.value);\n      (* Advance to next record for both cur and extra *)\n      extra := extra.next;\n      cur := cur.next;\n    END;\n  END Append;\n\n~~~\n\nA second procedure for appending an `ARRAY OF CHAR` also \nbecomes trivial. First convert the `ARRAY OF CHAR` to a dynamic \nstring then append it with the previous procedure.\n\n### `AppendCharArray*(src : ARRAY OF CHAR; VAR str : DynamicString);`\n\nThis procedure appends an ARRAY OF CHAR to an existing dynamic string.\n\n~~~\n\n  PROCEDURE AppendCharArray*(extra: ARRAY OF CHAR; VAR dest : DynamicString);\n    VAR extraStr : DynamicString;    \n  BEGIN\n    (* Convert our extra ARRAY OF CHAR into a DynamicString *)\n    New(extraStr); Set(extraStr, extra);\n    (* Now we can append. *)\n    Append(extraStr, dest);\n  END AppendCharArray;\n\n~~~\n\nAt some point we will want to know the length of our dynamic string.\n\n### `Length(str : DynamicString) : INTEGER`\n\nOur `Length` needs to go through our linked list and total up \nthe length of each value. We will use a variable called `cur` \nto point at the current record and add up our total length as \nwe walk through the list.\n\n~~~\n\n  PROCEDURE Length*( source : DynamicString) : INTEGER;\n    VAR cur : DynamicString; total : INTEGER;\n  BEGIN\n    total := 0;\n    cur := source;\n    WHILE cur # NIL DO\n      total := total + Strings.Length(cur.value);\n      cur := cur.next;\n    END; \n    RETURN total\n  END Length;\n\n~~~\n\n## Extending DynamicStrings module\n\nWith these few procedures we have a basic means of working with \ndynamic strings. Moving beyond this we can look at the standard \nOberon `Strings` module for inspiration.  If we use similar \nprocedure signatures we can create a drop in replacement \nfor `Strings` with `DynamicStrings`.\n\nNOTE: Procedure signatures refer to procedures type along \nwith the order and types of parameters. A quick review of the \nprocedure signatures for the standard module [Strings](https://miasap.se/obnc/obncdoc/basic/Strings.def.html) is \nprovided by the [OBNC](https://miasap.se/obnc) compiler docs. \n\nLet's look at recreating `Insert` as a potential guide to\na more fully featured [\"DynamicStrings.Mod\"](DynamicStrings.Mod). \nIn our `Insert` we modify the procedure signature so the \nsource and destinations are dynamic strings.\n\n\n### `Insert(source : DynamicString; pos : INTEGER; VAR dest : DynamicString)`\n\nThe `Insert` procedure inserts a `source` dynamic string at the \nposition provided into our `dest` dynamic string. We are implementing\nthe same signature  for our `DynamicStrings.Insert()` as \n`Strings.Insert()`. Only the parameters for source and destination\nare changed to `DynamicString`.\n\nInternally our procedure for `Insert` is a more complicated than\nthe ones we've written so far. It needs to do all the housing \nkeeping for making sure we add the right content in the correct\nspot.  The general idea is to find the record holding the split \npoint. Split that record into two records. The first retains \nthe characters before the insert position. The second holds the \ncharacters after the insert position and points to next record \nin the dynamic string. Once the split is accomplished it then \nis a matter of linking everything up. The record before the \ninsert position is set to point at the dynamic string to be \ninserted, the inserted dynamic string is set to point at the \nrecord that contained the rest of the characters after the \nsplit.\n\nIt is easy to extract a sub-string from an `ARRAY OF CHAR` \nusing the standard `Strings` module.  We can store the characters\nin the `.value` of the record after the split in a temporary \n`ARRAY OF CHAR`.  The temporary `ARRAY OF CHAR` can be used to \ncreate a new dynamic string record which will be linked to the \nrest of our destination dynamic string. The record which held \nthe characters before the insert position needs to be truncated \nand it needs to be linked to the dynamic string we want to \ninsert. NOTE: This will leave a small amount of unused \nmemory.\n\nNOTE: If conserving memory is critical then re-packing the \ndynamic string could be implemented as another procedure. The \ncost would be complexity and time to shift characters between \nlater records and earlier ones replacing excess NULL values.\n\nWe need to find the record where the split will occur. In the \nrecord to be split we need to calculate a relative \nsplit point. We then can copy the excess characters in that \nsplit record to a new record and truncate the `.value`'s \n`ARRAY OF CHAR` to create our split point. Truncating is easy \nin that we replace the CHAR in the `.values` that are not \nneeded with a NULL character. We can do that with a \nsimple loop. Likewise calculating the relative insertion \nposition can be done by taking the modulo of the `vSize` of \n`.value`.\n\nNOTE: In Oberon stings are terminated with a NULL \ncharacter. A NULL character holds the ASCII value `0X`.\n\nOur algorithm:\n\n1. Set `cur` to point to the start of our destination dynamic string\n2. Move `cur` to the record in the link list where the insertion will take place\n3. Calculate the relative split point in `cur.value`\n4. Copy the characters in `cur.value` from relative split point to end of `.value` into a temporary `ARRAY OF CHAR`\n5. Make a new record, `rest`, using the temporary `ARRAY OF CHAR` and update the value of `.next` to match that of `cur.next`\n6. Truncate the record (cur) at the relative split point\n7. Set `cur.next` to point to our `extra` dynamic string.\n8. Move to the end of extra with `cur`\n9. Set the `cur.next` to point at `rest`\n\nOur procedure:\n\n~~~\n\n  PROCEDURE Insert*(extra : DynamicString; \n                    pos : INTEGER; \n                    VAR dest : DynamicString);\n    VAR cur, rest : DynamicString;\n        tmp : ARRAY vSize OF CHAR;\n        i, splitPos : INTEGER; continue : BOOLEAN;\n  BEGIN\n    (* 1. Set `cur` to the start of our `dest` dynamic string *)\n    cur := dest;\n\n    (* 2. Move to the record which holds the split point *)\n    i := 0;\n    continue := (i < pos);\n    WHILE continue DO\n      i := i + Strings.Length(cur.value);\n      continue := (i < pos);\n      IF continue & (cur.next # NIL) THEN\n        cur := cur.next;\n      ELSE\n        continue := FALSE;\n      END;\n    END;\n\n    (* 3. Copy the characters in `cur.value` from relative\n          split point to end of `.value` into a \n          temporary `ARRAY OF CHAR` *)\n    splitPos := pos MOD vSize;\n    Strings.Extract(cur.value, splitPos,\n                    Strings.Length(cur.value), tmp);\n\n    (* 4. Make a new record, `rest`, using the temporary \n          `ARRAY OF CHAR` and update the value of `.next` to\n          match that of `cur.next` *)\n    New(rest); Set(rest, tmp);\n    rest.next := cur.next;\n\n    (* 5. Truncate `cur.value` at the relative split point *)\n    i := splitPos;\n    WHILE i < LEN(cur.value) DO\n      cur.value[i] := 0X;\n      INC(i);\n    END;\n\n    (* 6. Set `cur.next` to point to our `extra`\n          dynamic string. *)\n    cur.next := extra;\n\n    (* 7. Move to the end of extra with `cur` *)\n    WHILE cur.next # NIL DO cur := cur.next; END;\n\n    (* 8. Set the `cur.next` to point at `rest` *)\n    cur.next := rest;\n  END Insert;\n\n~~~\n\nWhile our `Insert` is the longest procedure so far the steps \nare mostly simple. Additionally we can easily extend this to \nsupport inserting a more traditional `ARRAY OF CHAR` using our\npreviously established design pattern of converting a basic type\ninto our dynamic type before calling the dynamic version of the\nfunction.\n\n~~~\n\n  PROCEDURE InsertCharArray*(source : ARRAY OF CHAR; \n                             pos : INTEGER; \n                             VAR dest : DynamicString);\n    VAR extra : DynamicString;\n  BEGIN\n    New(extra); Set(extra, source);\n    Insert(extra, pos, dest);\n  END InsertCharArray;\n\n~~~\n\n## Where to go next\n\nIt is possible to extend our \"DynamicStrings.Mod\" into a drop \nin replacement for the standard `Strings`.  I've included a \nskeleton of that module as links at the end of this article \nwith stubs for the missing implementations such as `Extract`, \n`Replace`, `Pos`, and `Cap`.  I've also included a \n\"DynamicStringsTest.Mod\" for demonstrating how it works.\n\nThe procedure I suggest is to mirror `Strings` replacing the \nparameters that are `ARRAY OF CHAR` with `DynamicString`. It \nwill be helpful to include some bridging procedures that accept \n`ARRAY OF CHAR` as inputs too. These will use similar names \nwith a suffix of `CharArray`.\n\n## Parameter conventions and order\n\nOberon is highly composable. The trick to creating a drop in \nreplacement module is use the same parameter signatures so \nyou only need to make minor changes like updating the `IMPORT` \nstatement and using a module alias to map the old module to the\nnew one.  The parameter signatures in `Strings` follow a \nconvention you'll see in other Oberon modules. The parameter\norder is based on the \"inputs\", \"modify parameters\", and \n\"output parameters\". Inputs are non-`VAR` parameters. The \nremaining are `VAR` parameters. I think of \"modify parameters\" \nas those objects who reflect side effects. I think of \"output\" \nas values that in other languages would be returned by \nfunctions.  This is only a convention. A variation I've \nread in other Oberon modules is \"object\", \"inputs\", \"outputs\". \n\"object\" and \"outputs\" are `VAR` parameters and \"inputs\" are \nnot. This ordering makes sense when we think of records as \nholding an object. In both cases ordering is a convention \nand not enforced by the language.  Convention and consistency is \nhelpful but readability is the most important.  Oberon is a \nreadable language. It does not reward obfuscation. Readability is \na great virtue in a programming language. When creating your own \nmodules choose readability based on the concepts you want to\nemphasize in the module (e.g. procedural, object oriented).\n\n## The modules so far\n\nYou can read the full source for the module discussed along\nwith a test module in the links that follow.\n\n+ [DynamicStrings.Mod](DynamicStrings.Mod)\n+ [DynamicStringsTest.Mod](DynamicStringsTest.Mod)\n\n\n### Next and Previous \n\n+ Next [Procedures as parameters](../../06/20/Procedures-as-parameters.html)\n+ Previous [Oberon-07 and the file system](../09/Oberon-07-and-the-filesystem.html) \n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-05-25",
        "keywords": [
          "Oberon",
          "programming",
          "type extension",
          "dynamic data"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 8,
        "series": "Mostly Oberon",
        "title": "Dynamic types"
      },
      "url": "posts/2020/05/25/Dynamic-types.json"
    },
    {
      "content": "\n\n# Procedures as parameters\n\nBy R. S. Doiel, 2020-06-20\n\nThis is the ninth post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series.\nMostly Oberon documents my exploration of the Oberon Language, Oberon System and the \nvarious rabbit holes I will inevitably fall into.\n\nOberon-07 supports the passing of procedures as parameters in a procedure. \nLet's create a module name [Noises.Mod](Noises.Mod) to explore this.\n\nThe key to supporting this is Oberon's type system.  We need to decide what our \ngeneric procedure will look like first. In our case our procedures that will display \nan animal noise will include the name of the animal speaking.  We'll call this type \nof procedure \"Noise\". It'll accept an ARRAY OF CHAR for the name as a parameter \nthen use the standard Out module to display the animal name and noise they make.\n\n\n~~~\n\n    TYPE\n      Noise = PROCEDURE (who : ARRAY OF CHAR);\n\n~~~\n\n\nThe two \"Noise\" procedures will be \"BarkBark\" and \"ChirpChirp\". They will\nimplement the same parameter signature as describe in the \"Noise\" type.\n\n\n~~~\n\n    PROCEDURE BarkBark(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Bark, bark\");Out.Ln();\n    END BarkBark;\n\n    PROCEDURE ChirpChirp(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Chirp, chirp\");Out.Ln();\n    END ChirpChirp;\n\n~~~\n\n\nWe'll also create a procedure, MakeNoise, that accepts the animal name and\nour \"Noise\" procedure name and it'll call the \"Noise\" type procedure \npassing in the animal name.\n\n\n~~~\n\n    PROCEDURE MakeNoise(name : ARRAY OF CHAR; noise : Noise);\n    BEGIN\n      (* Call noise with the animal name *)\n      noise(name);\n    END MakeNoise;\n\n~~~\n\n\nIf we invoke MakeNoise with our animal name and pass the name of the \nprocedure we want to do the MakeNoise procedure will generate our\nnoise output. Here' is what is looks like all together.\n\n\n~~~\n\n    MODULE Noises;\n      IMPORT Out;\n    \n    TYPE \n      Noise = PROCEDURE(who : ARRAY OF CHAR);\n    \n    PROCEDURE BarkBark(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Bark, bark\");Out.Ln();\n    END BarkBark;\n    \n    PROCEDURE ChirpChirp(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Chirp, chirp\");Out.Ln();\n    END ChirpChirp;\n    \n    PROCEDURE MakeNoise(name : ARRAY OF CHAR; noise : Noise);\n    BEGIN\n      (* Call noise with the animal name *)\n      noise(name);\n    END MakeNoise;\n    \n    BEGIN\n      MakeNoise(\"Fido\", BarkBark);\n      MakeNoise(\"Tweety\", ChirpChirp);\n      MakeNoise(\"Fido\", ChirpChirp);\n      MakeNoise(\"Tweety\", BarkBark);\n    END Noises.\n\n~~~\n\n\nNote when we pass the procedures we include their name **without** parenthesis.\nOur type definition tells the compiler that the procedure can be a parameter,\nany procedure with the same signature, e.g. `who : ARRAY OF CHAR` as the\nonly parameter will be treated as a \"Noise\" type procedures. \n\n### Next and Previous \n\n+ Next [Procedures in Records](../../07/07/Procedures-in-records.html)\n+ Previous [Dynamic types](../../05/25/Dynamic-types.html) \n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-06-20",
        "keywords": [
          "Oberon",
          "procedures",
          "passing procedures as parameters",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 9,
        "series": "Mostly Oberon",
        "title": "Procedures as parameters"
      },
      "url": "posts/2020/06/20/Procedures-as-parameters.json"
    },
    {
      "content": "\n\n# Procedures in records\n\nBy R. S. Doiel, 2020-07-07\n\nThis is the tenth post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series.\nMostly Oberon documents my exploration of the Oberon Language, Oberon System and the \nvarious rabbit holes I will inevitably fall into.\n\nIn my last post I looked at how Oberon-07 supports the passing of procedures as parameters in a procedure. In this one I am looking at how we can\ninclude procedures as a part of an Oberon RECORD. \n\nLet's modify our module name [Noises.Mod](Noises.Mod) to explore this.\nCopy \"Noises.Mod\" to \"Creatures.Mod\". Replace the \"MODULE Noises;\" line with\n\"MODULE Creatures;\" and the final \"END Noises.\" statement with \"END Creatures.\".\n\n\n~~~\n\n    MODULE Creatures;\n    \n    (* rest of code here *)\n\n    END Creatures.\n\n~~~\n\n\nThe key to supporting records with procedures as record attributes is once again Oberon's type system.  The type `Noise` we created in the previous post can also be used to declare a record attribute similar to how we use this new type to pass the procedure. In this exploration will create a linked list of \"Creature\" types which include a \"MakeNoise\" attribute.\n\nFirst let's define our \"Creature\" as a type as well as a \n`CreatureList`. Add the following under our `TYPE` \ndefinition in [Creatures.Mod](Creatures.Mod).\n\n\n~~~\n\n    Creature = POINTER TO CreatureDesc;\n    CreatureDesc = RECORD\n                     name : ARRAY 32 OF CHAR;\n                     noises : Noises;\n                   END;\n\n~~~\n\n\nLet's create a new `MakeCreature` procedure that will create\na populate a single `Creature` type record.\n\n\n~~~\n\n    PROCEDURE MakeCreature(name : ARRAY OF CHAR; noise : Noise; VAR creature : Creature);\n    BEGIN\n      NEW(creature);\n      creature.name := name;\n      creature.noise := noise;\n    END MakeCreature;\n\n~~~\n\n\nNow lets modify `MakeNoise` to accept the `Creature` type RECORD\nrather than a name and a noise procedure parameter.\n\n\n~~~\n\n    PROCEDURE MakeNoise(creature : Creator);\n    BEGIN\n      creature.noise(creature.name);\n    END MakeNoise;\n\n~~~\n\n\nHow does this all work?  The two \"Noise\" procedures \n\"BarkBark\" and \"ChirpChirp\" remain as in our original \n\"Noises\" module. But our new `MakeNoise` procedure\nlooks takes a `Creature` record rather than accepting a\nname and procedure as parameters. This makes the code \na little more concise as well as lets you evolve the\ncreature record type using an object oriented approach.\n\nOur revised module should look like this.\n\n\n~~~\n\n    MODULE Noises;\n      IMPORT Out;\n    \n    TYPE \n      Noise = PROCEDURE(who : ARRAY OF CHAR);\n\n      Creature = RECORD\n                   name : ARRAY 32 OF CHAR;\n                   noises : Noises;\n                 END;\n    \n    VAR\n      dog, bird : Creature;\n\n    PROCEDURE BarkBark(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Bark, bark\");Out.Ln();\n    END BarkBark;\n    \n    PROCEDURE ChirpChirp(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Chirp, chirp\");Out.Ln();\n    END ChirpChirp;\n    \n    PROCEDURE MakeNoise(creature : Creature);\n    BEGIN\n      (* Call noise with the animal name *)\n      creature.noise(creature.name);\n    END MakeNoise;\n\n    PROCEDURE MakeCreature(name : ARRAY OF CHAR; noise : Noise; VAR creature : Creature);\n    BEGIN\n      NEW(creature);\n      creature.name := name;\n      creature.noise := noise;\n    END MakeCreaturel\n    \n    BEGIN\n      MakeCreature(\"Fido\", BarkBark, dog);\n      MakeCreature(\"Tweety\", ChirpChirp, bird);\n      MakeNoise(dog);\n      MakeNoise(bird);\n    END Noises.\n\n~~~\n\n\nWhere to go from here? Think about evolving [Creatures](Creatures.Mod) so\nthat you can create a dynamic set of creatures that mix and match their\nbehaviors. Another idea would be to add a \"MutateCreature\" procedure\nthat would let you change the noise procedure to something new.\n\n\n### Next and Previous \n\n+ Next [Portable Oberon-07](../../08/15/Portable-Oberon-07.html)\n+ Previous [Procedures as parameters](../../06/20/Procedures-as-parameters.html) \n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-07-07",
        "keywords": [
          "Oberon",
          "procedures",
          "record procedures",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 10,
        "series": "Mostly Oberon",
        "title": "Procedures in records"
      },
      "url": "posts/2020/07/07/Procedures-in-records.json"
    },
    {
      "content": "\n\n# Software Tools, Getting Started\n\n## Overview\n\nThis post is the first in a series revisiting the\nprograms described in the 1981 book by Brian W. Kernighan and\nP. J. Plauger's called [Software Tools in Pascal](https://archive.org/details/softwaretoolsinp00kern).\nThe book is available from the [Open Library](https://openlibrary.org/)\nand physical copies are still (2020) commonly available from used book\nsellers.  The book was an early text on creating portable command\nline programs.  \n\nIn this series I present the K & P (i.e. Software Tools in Pascal)\nprograms re-implemented in Oberon-07. I have testing my implementations\nusing Karl Landström's [OBNC](http://miasap.se/obnc/)\ncompiler and his implementation of the Oakwood Guide's modules\nfor portable Oberon programs. Karl also provides a few additional\nmodules for working in a POSIX environment (e.g. BSD, macOS, Linux,\nWindows 10 with Linux subsystem). I have also tested these\nprograms with Mike Spivey's [Oxford Oberon Compiler](http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler) an aside\nfrom the differences file extensions that both compilers use\nthe source code works the same. \n\nNOTE: OBNC compiler is the work of Karl Langström, it is portable across many systems where the C tool chain is available.\n\nNOTE: POSIX defines a standard of compatibility inspired by [UNIX](https://en.wikipedia.org/wiki/Unix), see <https://en.wikipedia.org/wiki/POSIX>\n\n\n## Getting Started.\n\nChapter one in K & P is the first chapter that presents code. It introduces\nsome challenges and constraints creating portable Pascal suitable for use\nacross hardware architectures and operating systems. In 1981 this included\nmainframes, minicomputers as well as the recent evolution of the microcomputer.\nThe programs presented build up from simple to increasingly complex as\nyou move through the book.  They provide example documentation and discuss\ntheir implementation choices. It is well worth reading the book for those\ndiscussions, while specific to the era, mirror the problems program authors\nface today in spite of the wide spread success of the POXIS model, the\nconsolidation of CPU types and improvements made in development tools in\nthe intervening decades.\n\nThrough out K & P you'll see the bones of many POSIX commands we have today.\n\nPrograms from this chapter include:\n\n1. **copyprog**, this is like \"cat\" in a POSIX system\n2. **charcount**, this is like the \"wc\" POSIX command using the \"-c\" option\n3. **linecount**, this is like the \"wc\" POSIX command using the \"-l\" option\n4. **wordcount**, this is like the \"wc\" POSIX command using the \"-w\" option\n5. **detab**, converts tabs to spaces using tab stops every four characters in a line\n\nAll programs in this chapter rely solely on standard input and output.\nToday's reader will notice an absence to common concepts in today's\ncommand line programs.  First is the lack of interaction with command line\nparameters, the second is no example take advantage of environment variables.\nThese operating system features were not always available across\noperating systems of the early 1980s. Finally I'd like to point out a\nreally nice feature included in the book. It is often left out as a topic\nin programming books.  K & P provide example documentation. It's structure\nlike an early UNIX man page. It very clear and short. This is something\nI wish all programming texts at least mentioned. Documentation is important\nto the program author because it clarifies scope of the problem being\ntackled and to the program user so they understand what they are using.\n\n\n### [1.1. File Copying](https://archive.org/details/softwaretoolsinp00kern/page/7/mode/1up)\n\nHere's how K & P describe \"copyprog.pas\" (referred to as \"copy\" in\nthe documentation).\n\n\n~~~\n\nPROGRAM\n\n    copy    copy input to output\n\nUSAGE\n\n    copy\n\nFUNCTION\n\n    copy copies its input to its output unchanged. It is useful for copying\n    from a terminal to a file, from file to file, or even from terminal to\n    terminal. It may be used for displaying the contents of a file, without\n    interpretation or formatting, by copying from the file to terminal.\n\nEXAMPLE\n\n    To echo lines type at your terminal.\n\n    copy\n    hello there, are you listening?\n    **hello there, are you listening?**\n    yes, I am.\n    **yes, I am.**\n    <ENDFILE>\n\n~~~\n\nThe source code for \"copyprog.pas\" is shown on\n[page 9](https://archive.org/details/softwaretoolsinp00kern/page/9/mode/1up)\nof K & P.  First the authors introduce the __copy__ procedure\nthen a complete the section introducing it in context of the complete Pascal\nprogram. After this first example K & P leave implementation of the full\nprogram up to the reader.\n\nThe body of the Pascal program invokes a procedure called\n[copy](https://archive.org/details/softwaretoolsinp00kern/page/8/mode/1up)\nwhich reads from standard input character by character and writes\nto standard output character by character without modification.  Two\nsupporting procedures are introduced, \"getc\" and \"putc\". These are shown\nin the complete program listing on page 9. They are repeatedly used\nthrough out the book. One of the really good aspects of this simple\nprogram is relying on the idea of standard input and output. This makes\n\"copyprog.pas\" a simple filter and template for writing many of the programs\nthat follow. K & P provide a good explanation for this simple approach.\nAlso note K & P's rational for working character by character versus\nline by line.\n\nMy Oberon-07 version takes a similar approach. The module looks remarkably\nsimilar to the Pascal but is shorter because reading and writing characters are\nprovided for by Oberon's standard modules \"In\" and \"Out\".\nI have chosen to use a \"REPEAT/UNTIL\" loop over the \"WHILE\"\nloop used by K & P is the attempt to read from standard input needs to happen\nat least once. Note in my \"REPEAT/UNTIL\" loop's terminating condition.\nThe value of `In.Done` is true on successful read and false\notherwise (e.g. you hit an end of the file). That means our loop must\nterminate on `In.Done # TRUE` rather than `In.Done = TRUE`. This appears\ncounter intuitive unless you keep in mind our loop stops when we having\nnothing more to read, rather than when we can continue to read.\nIt `In.Done` means the read was successful and does not\nmean \"I'm done and can exit now\". Likewise before writing out the character\nwe read, it is good practice to check the `In.Done` value. If `In.Done` is\nTRUE, I know can safely display the character using `Out.Char(c);`.\n\n~~~\n\nMODULE CopyProg;\nIMPORT In, Out;\n\nPROCEDURE copy;\nVAR\n  c : CHAR;\nBEGIN\n  REPEAT\n    In.Char(c);\n    IF In.Done THEN\n        Out.Char(c);\n    END;\n  UNTIL In.Done # TRUE;\nEND copy;\n\nBEGIN\n  copy();\nEND CopyProg.\n\n~~~\n\n#### Limitations\n\nThis program only works with standard input and output. A more generalized\nversion would work with named files.\n\n### [1.2 Counting Characters](https://archive.org/details/softwaretoolsinp00kern/page/13/mode/1up)\n\n~~~\n\nPROGRAM\n\n  charcount count characters in input\n\nUSAGE\n\n  charcount\n\nFUNCTION\n\n  charcount counts the characters in its input and writes the total\n  as a single line of text to the output. Since each line of text is\n  internally delimited by a NEWLINE character, the total count is the\n  number of lines plus the number of characters within each line.\n\nEXAMPLE\n\n  charcount\n  A single line of input.\n  <ENDFILE>\n  24\n\n~~~\n\n[On page 13](https://archive.org/details/softwaretoolsinp00kern/page/13/mode/1up)\nK & P introduces their second program, **charcount**. It is based on a single\nprocedure that reads from standard input and counts up the number of\ncharacters encountered then writes the total number found to standard out\nfollowed by a newline. In the text only the procedure is shown, it is\nassumed you'll write the outer wrapper of the program yourself as\nwas done with the **copyprog** program. My Oberon-07 version is very similar\nto the Pascal. Like in the our first \"CopyProg\" we will make use of the\n\"In\" and \"Out\" modules. Since we will\nneed to write an INTEGER value we'll also use \"Out.Int()\" procedure which\nis very similar to K & P's \"putdec()\". Aside from the counting this is very\nsimple  like our first program.\n\n~~~\n\nMODULE CharCount;\nIMPORT In, Out;\n\nPROCEDURE CharCount;\nVAR\n  nc : INTEGER;\n  c : CHAR;\nBEGIN\n  nc := 0;\n\n  REPEAT\n    In.Char(c);\n    IF In.Done THEN\n      nc := nc + 1;\n    END;\n  UNTIL In.Done # TRUE;\n  Out.Int(nc, 1);\n  Out.Ln();\nEND CharCount;\n\nBEGIN\n  CharCount();\nEND CharCount.\n\n~~~\n\n#### Limitations\n\nThe primary limitation in counting characters is most readers are\ninterested in visible character count. In our implementation\neven non-printed characters are counted. Like our first program\nthis only works on standard input and output. Ideally this should\nbe written so it works on any file including standard input and\noutput. If the reader implements that it could become part of a\npackage on statistical analysis of plain text files.\n\n### [1.3 Counting Lines](https://archive.org/details/softwaretoolsinp00kern/page/14/mode/1up)\n\n~~~\n\nPROGRAM\n\n  linecount count lines in input\n\nUSAGE\n\n  linecount\n\nFUNCTION\n\n  linecount counts the lines in its input and write the total as a\n  line of text to the output.\n\nEXAMPLE\n\n  linecount\n  A single line of input.\n  <ENDFILE>\n  1\n\n~~~\n\n**linecount**, from [page 15](https://archive.org/details/softwaretoolsinp00kern/page/15/mode/1up)\nis very similar to **charcount** except adding a\nconditional count in the loop for processing the file. In\nour Oberon-07 implementation we'll check if the `In.Char(c)`\ncall was successful but we'll add a second condition to see if the\ncharacter read was a NEWLINE. If it was I increment\nour counter variable.\n\n~~~\n\nMODULE LineCount;\nIMPORT In, Out;\n\nPROCEDURE LineCount;\nCONST\n  NEWLINE = 10;\n\nVAR\n  nl : INTEGER;\n  c : CHAR;\nBEGIN\n  nl := 0;\n  REPEAT\n    In.Char(c);\n    IF In.Done & (ORD(c) = NEWLINE) THEN\n      nl := nl + 1;\n    END;\n  UNTIL In.Done # TRUE;\n  Out.Int(nl, 1);\n  Out.Ln();\nEND LineCount;\n\nBEGIN\n  LineCount();\nEND LineCount.\n\n~~~\n\n#### Limitations\n\nThis program assumes that NEWLINE is ASCII value 10. Line delimiters\nvary between operating systems.  If your OS used carriage returns\nwithout a NEWLINE then this program would not count lines correctly.\nThe reader could extend the checking to support carriage returns,\nnew lines, and carriage return with new lines and cover most versions\nof line endings.\n\n\n### [1.4 Counting Words](https://archive.org/details/softwaretoolsinp00kern/page/14/mode/1up)\n\n~~~\n\nPROGRAM\n\n  wordcount count words in input\n\nUSAGE\n\n  wordcount\n\nFUNCTION\n\n  wordcount counts the words in its input and write the total as a\n  line of text to the output. A \"word\" is a maximal sequence of characters\n  not containing a blank or tab or newline.\n\nEXAMPLE\n\n  wordcount\n  A single line of input.\n  <ENDFILE>\n  5\n\nBUGS\n\n  The definition of \"word\" is simplistic.\n\n~~~\n\n[Page 17](https://archive.org/details/softwaretoolsinp00kern/page/17/mode/1up)\nbrings us to the **wordcount** program. Counting words can be\nvery nuanced but here K & P have chosen a simple definition\nwhich most of the time is \"good enough\" for languages like English.\nA word is defined simply as an run of characters separated by\na space, tab or newline characters.  In practice most documents\nwill work with this minimal definition. It also makes the code\nstraight forward.  This is a good example of taking the simple\nroad if you can. It keeps this program short and sweet.\n\nIf you follow along in the K & P book note their rational\nand choices in arriving at there solutions. There solutions\nwill often balance readability and clarity over machine efficiency.\nWhile the code has progressed from \"if then\" to \"if then else if\"\nlogical sequence, the solution's modeled remains\nclear. This means the person reading the source code can easily verify\nif the approach chosen was too simple to meet their needs or it was\n\"good enough\".\n\nMy Oberon-07 implementation is again very simple. Like in previous programs\nI still have an outer check to see if the read worked (i.e. \"In.Done = TRUE\"),\notherwise the conditional logic is the same as the Pascal implementation.\n\n~~~\n\nMODULE WordCount;\nIMPORT In, Out;\n\nPROCEDURE WordCount;\nCONST\n  NEWLINE = 10;\n  BLANK = 32;\n  TAB = 9;\n\nVAR\n  nw : INTEGER;\n  c : CHAR;\n  inword : BOOLEAN;\nBEGIN\n  nw := 0;\n  inword := FALSE;\n  REPEAT\n    In.Char(c);\n    IF In.Done THEN\n      IF ((ORD(c) = BLANK) OR (ORD(c) = NEWLINE) OR (ORD(c) = TAB)) THEN\n        inword := FALSE;\n      ELSIF (inword = FALSE) THEN\n        inword := TRUE;\n        nw := nw + 1;\n      END;\n    END;\n  UNTIL In.Done # TRUE;\n  Out.Int(nw, 1);\n  Out.Ln();\nEND WordCount;\n\nBEGIN\n  WordCount();\nEND WordCount.\n\n~~~\n\n## [1.5 Removing Tabs](https://archive.org/details/softwaretoolsinp00kern/page/20/mode/1up)\n\n~~~\n\nPROGRAM\n\n  detab convert tabs into blanks\n\nUSAGE\n\n  detab\n\nFUNCTION\n\n  detab copies its input to its output, expanding the horizontal\n  tabs to blanks along the way, so that the output is visually\n  the same as the input, but contains no tab characters. Tab stops\n  are assumed to be set every four columns (i.e. 1, 5, 9, ...), so\n  each tab character is replaced by from one to four blanks.\n\nEXAMPLE\n\n  Usaing \"->\" as a visible tab:\n\n  detab\n  ->col 1->2->34->rest\n      col 1   2   34  rest\n\nBUGS\n\n  detab is naive about backspaces, vertical motions, and\n  non-printing characters.\n\n~~~\n\nThe source code for \"detab\" can be found on\n[page 24](https://archive.org/details/softwaretoolsinp00kern/page/24/mode/1up)\nin the last section of chapter 1. **detab** removes\ntabs and replaces them with spaces. Rather than a simple \"tab\"\nreplaced with four spaces **detab** preserves a concept found on\ntypewriters called \"tab stops\". In 1981 typewrites were still widely\nused though word processing software would become common. Supporting the\n\"tab stop\" model means the program works with what office workers would\nexpect from older tools like the typewriter or even the computer's\nteletype machine. I think this shows an important aspect of writing\nprograms. Write the program for people, support existing common concepts\nthey will likely know.\n\nK & P implementation includes separate source files\nfor setting tab stops and checking a tab stop.  The Pascal K & P\nwrote for didn't support separate source files or program modules. Recent Pascal\nversions did support the concept of modularization (e.g. UCSD Pascal). Since\nand significant goal of K & P was portability they needed to come up\nwith a solution that worked on the \"standard\" Pascal compilers available on\nminicomputers and mainframes and not write their solution to a specific\nPascal system like UCSD Pascal (see Appendix, \"IMPLEMENTATION\nPRIMITIVES [page 315](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/315/mode/1up)).\nModularization facilitates code reuse and like information hiding is an\nimport software technique. Unfortunately the preprocessor approach doesn't\nsupport information hiding.\n\nTo facilitate code reuse the K & P book includes a preprocessor as part\nof the Pascal development tools (see [page 71](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/71/mode/1up)\nfor implementation). The preprocessor written\nin Pascal was based on the early versions of the \"C\" preprocessor\nthey had available in the early UNIX systems. Not terribly Pascal\nlike but it worked and allowed the two files to be shared between\nthis program and one in the next chapter.\n\nOberon-07 of course benefits from all of Wirth's language improvements\nthat came after Pascal. Oberon-07 supports modules and as such\nthere is no need for a preprocessor.  Because of Oberon-07's module\nsupport I've implemented the Oberon version using two files\nrather than three. My main program file is \"Detab.Mod\",\nthe supporting library module is \"Tabs.Mod\". \"Tabs\" is where I\ndefine our tab stop data structure as well as the\nprocedures that operating on that data structure.\n\nLet's look at the first part, \"Detab.Mod\". This is the module\nthat forms the program and it features an module level \"BEGIN/END\" block.\nIn that block I call \"Detab();\" which implements the program's functionality.\nI import \"In\", \"Out\" as before but I also import \"Tabs\" which I will show next.\nLike my previous examples I validate the read was successful before proceeding\nwith the logic presented in the original Pascal and deciding\nwhat to write to standard output.\n\n~~~\n\nMODULE Detab;\n  IMPORT In, Out, Tabs;\n\nCONST\n  NEWLINE = 10;\n  TAB = 9;\n  BLANK = 32;\n\nPROCEDURE Detab;\nVAR\n  c : CHAR;\n  col : INTEGER;\n  tabstops : Tabs.TabType;\nBEGIN\n  Tabs.SetTabs(tabstops); (* set initial tab stops *)\n  col := 1;\n  REPEAT\n    In.Char(c);\n    IF In.Done THEN\n      IF (ORD(c) = TAB) THEN\n        REPEAT\n          Out.Char(CHR(BLANK));\n          col := col + 1;\n        UNTIL Tabs.TabPos(col, tabstops);\n      ELSIF (ORD(c) = NEWLINE) THEN\n        Out.Char(c);\n        col := 1;\n      ELSE\n        Out.Char(c);\n        col := col + 1;\n      END;\n    END;\n  UNTIL In.Done # TRUE;\nEND Detab;\n\nBEGIN\n  Detab();\nEND Detab.\n\n~~~\n\nOur second module is \"Tabs.Mod\". It provides the supporting procedures\nand definition of the our \"TabType\" data structure. For us this\nis the first time we write a module which \"exports\" procedures\nand type definitions. If you are new to Oberon, expected constants,\nvariables and procedures names have a trailing \"*\". Otherwise the\nOberon compiler will assume a local use only. This is a very\npowerful information hiding capability and what allows you to\nevolve a modules' internal implementation independently of the\nprograms that rely on it.\n\n~~~\n\nMODULE Tabs;\n\nCONST\n  MAXLINE = 1000; (* or whatever *)\n\nTYPE\n  TabType* = ARRAY MAXLINE OF BOOLEAN;\n\n(* TabPos -- return TRUE if col is a tab stop *)\nPROCEDURE TabPos*(col : INTEGER; VAR tabstops : TabType) : BOOLEAN;\n  VAR res : BOOLEAN;\nBEGIN\n  res := FALSE; (* Initialize our internal default return value *)\n  IF (col >= MAXLINE) THEN\n    res := TRUE;\n  ELSE\n    res := tabstops[col];\n  END;\n  RETURN res\nEND TabPos;\n\n(* SetTabs -- set initial tab stops *)\nPROCEDURE SetTabs*(VAR tabstops: TabType);\nCONST\n  TABSPACE = 4; (* 4 spaces per tab *)\nVAR\n  i : INTEGER;\nBEGIN\n  (* NOTE: Arrays in Oberon start at zero, we want to\n     stop at the last cell *)\n  FOR i := 0 TO (MAXLINE - 1) DO\n    tabstops[i] := ((i MOD TABSPACE) = 0);\n  END;\nEND SetTabs;\n\nEND Tabs.\n\n~~~\n\nNOTE: This module is used by \"Detab.Mod\" and \"Entab.Mod\"\nand provides for common type definitions and code reuse.\nWe exported `TabType`, `TabPos` and `SetTabs`. Everything else\nis private to this module.\n\n## In closing\n\nThis post briefly highlighted ports of the programs\npresented in Chapter 1 of \"Software Tools in Pascal\".\nBelow are links to my source files of the my\nimplementations inspired by the K & P book. Included\nin each Oberon module source after the module definition\nis transcribed text of the program documentation as well\nas transcribed text of the K & P Pascal implementations.\nEach file should compiler without modification using the\nOBNC compiler.  By default the OBNC compiler will use the\nmodule's name as the name of the executable version. I\nI have used mixed case module names, if you prefer lower\ncase executable names use the \"-o\" option with the OBNC\ncompiler.\n\n~~~\n\n    obnc -o copy CopyProg.Mod\n    obnc -o charcount CharCount.Mod\n    obnc -o linecount LineCount.Mod\n    obnc -o wordcount WordCount.Mod\n    obnc -o detab Detab.Mod\n\n~~~\n\nIf you happen to be using The [Oxford Oberon Compiler](http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler)\nyou need to rename the files ending in \".Mod\" to \".m\" \nand you can compiler with the following command.\n\n~~~\n    obc -07 -o copyprog CopyProg.m\n    obc -07 -o charcount CharCount.m\n    obc -07 -o linecount LineCount.m\n    obc -07 -o wordcount WordCount.m\n    obc -07 -o detab Tabs.m Detab.m\n~~~\n\nNote the line for compiling \"Detab\" with **obc**, your\nlocal modules need to become before the module calling them.\n\n\n+ [CopyProg](CopyProg.Mod)\n+ [CharCount](CharCount.Mod)\n+ [LineCount](LineCount.Mod)\n+ [WordCount](WordCount.Mod)\n+ [Detab](Detab.Mod)\n    + [Tabs](Tabs.Mod), this one we'll revisit in next installment.\n\n\n# Next\n\n+ [Filters](../../10/31/Filters.html)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-09-29",
        "keywords": [
          "Oberon",
          "Pascal",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 1,
        "series": "Software Tools",
        "title": "Software Tools, Getting Started"
      },
      "url": "posts/2020/09/29/Software-Tools-1.json"
    },
    {
      "content": "\n\nOberon to Markdown\n==================\n\nThis is the twelfth post in the [Mostly Oberon](https://rsdoiel.github.io/blog/2020/04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\nA nice feature of Oberon\n------------------------\n\nOberon source code has a very nice property in that anything\nafter the closing end statement is ignored by the compiler.\nThis makes it a nice place to write documentation, program\nnotes and other ideas.\n\nI've gotten in the habit of writing up program docs and\nnotes there. When I prep to make a web document I used to\ncopy the source file, doing a cut and paste to re-order\nthe module code to the bottom of the document. I'd follow\nthat with adding headers and code fences. Not hard but\ntedious. Of course if I changed the source code I'd also\nhave to do another cut and paste edit. This program,\n`ObnToMd.Mod` automates that process.\n\nProgram Documentation\n---------------------\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n  ObnToMd\n\nFUNCTION\n\n  This is a simple program that reads Oberon modules\n  from standard in and re-renders that to standard output\n  such that it is suitable to process with Pandoc or other\n  text processing system.\n\nEXAMPLE\n\n  Read the source for this program and render a file\n  called \"blog-post.md\". Use Pandoc to render HTML.\n\n    ObnToMd <ObnToMd.Mod > blog-post.md\n    pandoc -s --metadata title=\"Blog Post\" \\\n        blog-post.md >blog-post.html\n\nBUGS\n\n  It uses a naive line analysis to identify the module\n  name and then the end of module statement. Might be\n  tripped up by comments containing the same strings.\n  The temporary file created is called \"o2m.tmp\" and\n  this filename could potentially conflict with another\n  file.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\nSource code for **ObnToMd.Mod**\n-------------------------------\n\n~~~\n\n(* ObnToMd.Mod - an simple filter process for reading\nan Oberon-07 module source file and rendering a markdown\nfriendly output suitable for piping into Pandoc. The\nfilter reads from standard input and writes to standard\noutput and makes use of a temp file name o2m.tmp which\nit removes after successful rendering.\n\n@Author R. S. Doiel, <rsdoiel@gmail.com>\ncopyright (c) 2020, all rights reserved.\nReleased under the BSD 2-clause license\nSee: https://opensource.org/licenses/BSD-2-Clause\n*)\nMODULE ObnToMd;\n  IMPORT In, Out, Files, Strings;\n\nCONST\n  MAXLENGTH = 1024;\n  LF = CHR(10);\n\nVAR\n  endOfLine : ARRAY 2 OF CHAR;\n\n(*\n * Helper methods\n *)\nPROCEDURE GenTempName(prefix, suffix : ARRAY OF CHAR; VAR name : ARRAY OF CHAR);\nBEGIN\n  name := \"\";\n  Strings.Append(prefix, name);\n  Strings.Append(\".\", name);\n  Strings.Append(suffix, name);\nEND GenTempName;\n\nPROCEDURE GenTempFile(name : ARRAY OF CHAR; VAR r : Files.Rider; VAR f : Files.File);\nBEGIN\n  f := Files.New(name);\n  IF f = NIL THEN\n    Out.String(\"ERROR: can't create \");Out.String(name);Out.Ln();\n    ASSERT(FALSE);\n  END;\n  Files.Register(f);\n  Files.Set(r, f, 0);\nEND GenTempFile;\n\n\nPROCEDURE StartsWith(target, source : ARRAY OF CHAR) : BOOLEAN;\n  VAR res : BOOLEAN;\nBEGIN\n  IF Strings.Pos(target, source, 0) > -1 THEN\n    res := TRUE;\n  ELSE\n    res := FALSE;\n  END;\n  RETURN res\nEND StartsWith;\n\nPROCEDURE ClearString(VAR s : ARRAY OF CHAR);\n  VAR i : INTEGER;\nBEGIN\n  FOR i := 0 TO LEN(s) - 1 DO\n    s[i] := 0X;\n  END;\nEND ClearString;\n\n\nPROCEDURE ProcessModuleDef(VAR r : Files.Rider; VAR modName : ARRAY OF CHAR);\n  VAR\n    line, endStmt : ARRAY MAXLENGTH OF CHAR;\n    start, end : INTEGER;\nBEGIN\n  line := \"\";\n  endStmt := \"\";\n  modName := \"\";\n  (* Find the name of the module and calc the \"END {NAME}.\" statement *)\n  REPEAT\n    ClearString(line);\n    In.Line(line);\n    IF In.Done THEN\n      Files.WriteString(r, line); Files.WriteString(r, endOfLine);\n      (* When `MODULE {NAME};` is encountered extract the module name *)\n      IF StartsWith(\"MODULE \", line) THEN\n        start := 7;\n        end := Strings.Pos(\";\", line, 0);\n        IF (end > -1) & (end > start) THEN\n            Strings.Extract(line, start, end - start, modName);\n            endStmt := \"END \";\n            Strings.Append(modName, endStmt);\n            Strings.Append(\".\", endStmt);\n        END;\n      END;\n    END;\n  UNTIL (In.Done # TRUE) OR (endStmt # \"\");\n\n  (* When `END {NAME}.` is encountered  stop writing tmp file *)\n  REPEAT\n    In.Line(line);\n    IF In.Done THEN\n      Files.WriteString(r, line); Files.WriteString(r, endOfLine);\n    END;\n  UNTIL (In.Done # TRUE) OR StartsWith(endStmt, line);\nEND ProcessModuleDef;\n\nPROCEDURE WriteModuleDef(name : ARRAY OF CHAR; VAR r : Files.Rider; VAR f : Files.File);\n  VAR s : ARRAY MAXLENGTH OF CHAR; res : INTEGER;\nBEGIN\n  Files.Set(r, f, 0);\n  REPEAT\n    Files.ReadString(r, s);\n    IF r.eof # TRUE THEN\n      Out.String(s);\n    END;\n  UNTIL r.eof;\n  Files.Close(f);\n  Files.Delete(name, res);\nEND WriteModuleDef;\n\n\nPROCEDURE OberonToMarkdown();\nVAR\n  tmpName, modName, line : ARRAY MAXLENGTH OF CHAR;\n  f : Files.File;\n  r : Files.Rider;\n  i : INTEGER;\nBEGIN\n  tmpName := \"\"; modName := \"\";  line := \"\";\n  (* Open temp file *)\n  GenTempName(\"o2m\", \"tmp\", tmpName);\n  GenTempFile(tmpName, r, f);\n\n  (* Read the Oberon source from standard input echo the lines tmp file *)\n  ProcessModuleDef(r, modName);\n\n  (* Write remainder of file to standard out *)\n  REPEAT\n    In.Line(line);\n    IF In.Done THEN\n      Out.String(line);Out.Ln();\n    END;\n  UNTIL In.Done # TRUE;\n\n  (* Write two new lines *)\n  Out.Ln(); Out.Ln();\n  (* Write heading `Source code for {NAME}` *)\n  ClearString(line);\n  line := \"Source code for **\";\n  Strings.Append(modName, line);\n  Strings.Append(\".Mod**\", line);\n  Out.String(line); Out.Ln();\n  FOR i := 0 TO Strings.Length(line) - 1 DO\n    Out.String(\"-\");\n  END;\n  Out.Ln();\n  (* Write code fence *)\n  Out.Ln();Out.String(\"~~~\");Out.Ln();\n  (* Reset rider to top of tmp file\n     Write temp file to standard out\n     cleanup demp file *)\n  WriteModuleDef(tmpName, r, f);\n  (* Write code fence *)\n  Out.Ln();Out.String(\"~~~\");Out.Ln();\n  (* Write tailing line and exit procedure *)\n  Out.Ln();\nEND OberonToMarkdown;\n\nBEGIN\n  endOfLine[0] := LF;\n  endOfLine[1] := 0X;\n  OberonToMarkdown();\nEND ObnToMd.\n\n~~~\n\n### Next, Previous\n\n+ Next [Assembling Pages](../../10/19/Assemble-pages.html)\n+ Previous [Portable Oberon-07](../../08/15/Portable-Oberon-07.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-10-03",
        "keywords": [
          "Oberon",
          "portable",
          "markdown",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 12,
        "series": "Mostly Oberon",
        "title": "Oberon to Markdown"
      },
      "url": "posts/2020/10/03/Oberon-to-markdown.json"
    }
  ]
}