{
  "page": 1,
  "total_pages": 1,
  "has_more": false,
  "next_page": null,
  "values": [
    {
      "content": "\nFeeds, formats, and plain text\n==============================\n\nBy R. S. Doiel, 2022-11-01\n\nThere has been a proliferation of feed formats. My personal preferred format is RSS 2.0. It's stable and proven the test of type. Atom feeds always felt a little like, \"not invented here so we're inventing it again\", type of thing. The claim was they could support read/write but so can RSS 2.0 specially with the namespace possibilities. The innovative work [Dave Winer](https://scripting.com) has done in the past and is doing today with [Feedland](https://feedland.org) is remarkably impressive.\n\nIn my experience the format of the feed is less critical than the how to author the metadata.  Over the last several years I've moved to static hosting as my preferred way of hosting a website. My writing is typically in Markdown or Fountain formats and frontmatter like used in RMarkdown has proven very convenient. The \"blogit\" command that started out from an idea in [mkpage](https://github.com/caltechlibrary/mkpage \"Make Page, a Pandoc preprocessor and tool set\") has been implemented in [pttk](https://github.com/rsdoiel/pttk \"Plain Text Toolkit\"). So for me metadata authoring makes sense in the front matter. That has the advantage that Pandoc can leverage the information in its templates (that is what I use to render HTML, man pages and the occasional PDF). It also is a food source for data to include in a feed.\n\nI've recently become aware of a really simple text format called [twtxt](https://twtxt.readthedocs.io/en/latest/). This simple format is meant for micro blogging but is also useful as a feed source and format. Especially in terms of rendering content for Gopherspace which I've re-engaged in recently. [Yarn.social](https://yarn.social) has built an entire ecosystem around it. Very impressive. The format is so simple it can be done with a pipe and the \"echo\" command in the shell.  It looks promising in terms for personal search ingest as well.\n\nOne of the formats that Dave Winer supports in Feedland and is used in the micro blogging community he has connected with is [jsonfeeds](https://www.jsonfeed.org/). It is lightweight and to me feels allot like RSS 2.0 without the XML-isms that go along with it.  I'm playing with the idea that in pttk it'll be the standard feed format and that from it I can then render our traditional feed friends of RSS 2.0 and Atom.\n\nI've looked at the ActivityPub from the Mastodon community but like [James Mill](https://prologic.github.io/prologic/ \"aka prologic\") I find it too complex. What is needed is something simple, really simple.  That's why I've been looking closely at Gopherspace again. The Gophermap can function as a bookmark file, a \"home page\" a list of feeds. A little archaic but practical in its simplicity. The only challenges I've run into has been figuring out that expectations of the Gopher server software. Currently I've settled on [gophernicus](https://gophernicus.org) as that is was it supported at [sdf.org](https://sdf.org) where I have a gopher \"hole\".\n\nAs pttk grows and I explore where I can take simple text processing I'm not targeting Gopherspace, twtxt and static websites. I've looked at [Gemini](https://gemini.circumlunar.space/docs/specification.gmi) but haven't grokked the point yet.  Their choice of yet another markup for content seems problematic at best. For me gopher solves the problems that would make me look at Gemini and I can use most any structured text I want. The text just needs to be readable easily by humans. The Gophermap provides can be enhanced menus much like \"index.html\" pages have become (a trunk that branches and eventually leads to a leaf). \n\n[OPML](http://home.opml.org/) remains a really nice outline data format.  It's something I'd like to eventually integrate with pttk. It can be easily represented as JSON. Just need to figure what problem I am trying to solve by using it.  Share a list of feeds is the classic case but looking at twtxt as well as the [newsboat](https://newsboat.org/) URL list makes me think it is more than I need. We'll see.  It is certainly reasonable to generate from a simpler source. If I ever write a personal search engine (something I've been thinking about to nearly a decade) it'd be a good way to share curated indexes sources as well as sources to crawl.  I just need to think that through more.\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "keywords": [
          "plain text",
          "small internet",
          "rss",
          "jsonfeed",
          "gopher"
        ],
        "pubDate": "2022-11-01",
        "title": "feeds, formats and plain text"
      },
      "url": "posts/2022/11/01/Feeds-formats-and-plain-text.json"
    },
    {
      "content": "\nRevisiting Files\n================\n\nBy R. S. Doiel, 2021-11-22\n\nIn October I had an Email exchange with Algojack regarding a buggy example in [Oberon-07 and the file system](../../../2020/05/09/Oberon-07-and-the-filesystem.html). The serious bug was extraneous non-printable characters appearing a plain text file containing the string \"Hello World\". The trouble with the example was a result of my misreading the Oakwood guidelines and how **Files.WriteString()** is required to work. The **Files.WriteString()** procedure is supposed to write every element of a string to a file. This __includes the trailing Null character__. The problem for me is **Files.WriteString()** litters plain text files with tailing nulls. What I should have done was write my own **WriteString()** and **WriteLn()**. The program [HelloworldFile](./HelloworldFile.Mod) below is a more appropriate solution to writing strings and line endings than relying directly on **Files**. In a future post I will explorer making this more generalized in a revised \"Fmt\" module.\n\n~~~\nMODULE HelloworldFile;\n\nIMPORT Files, Strings;\n\nCONST OberonEOL = 1; UnixEOL = 2; WindowsEOL = 3;\n\nVAR\n  (* holds the eol marker type to use in WriteLn() *)\n  eolType : INTEGER;\n  (* Define a file handle *)\n    f : Files.File;\n  (* Define a file rider *)\n    r : Files.Rider;\n\nPROCEDURE WriteLn(VAR r : Files.Rider);\nBEGIN\n  IF eolType = WindowsEOL THEN\n    (* A DOS/Windows style line ending, LFCR *)\n    Files.Write(r, 13);\n    Files.Write(r, 10);\n  ELSIF eolType = UnixEOL THEN\n     (* Linux/macOS style line ending, LF *)\n     Files.Write(r, 10);\n  ELSE\n    (* Oberon, RISC OS style line ending, CR *)\n    Files.Write(r, 13);\n  END;\nEND WriteLn;\n\nPROCEDURE WriteString(VAR r : Files.Rider; s : ARRAY OF CHAR);\n  VAR i : INTEGER;\nBEGIN\n  i := 0;\n  WHILE i < Strings.Length(s) DO\n    Files.Write(r, ORD(s[i]));\n    INC(i);\n  END;\nEND WriteString;\n\nBEGIN\n  (* Set the desired eol type to use *)\n  eolType := UnixEOL;\n  (* Create our file, New returns a file handle *)\n  f := Files.New(\"helloworld.txt\"); ASSERT(f # NIL);\n  (* Register our file with the file system *)\n  Files.Register(f);\n  (* Set the position of the rider to the beginning *)\n  Files.Set(r, f, 0);\n  (* Use the rider to write out \"Hello World!\" followed by a end of line *)\n  WriteString(r, \"Hello World!\");\n  WriteLn(r);\n  (* Close our modified file *)\n  Files.Close(f);\nEND HelloworldFile.\n~~~\n\nI have two new procedures \"WriteString\" and \"WriteLn\". These mimic the parameters found in the Files module. The module body is a bit longer.\n\nCompare this to a simple example of \"Hello World\" using the **Out** module.\n\n~~~\nMODULE HelloWorld;\n\nIMPORT Out;\n\nBEGIN\n  Out.String(\"Hello World\");\n  Out.Ln;\nEND HelloWorld.\n~~~\n\nLook at the difference is in the module body. I need to setup our file and rider as well as pick the type of line ending to use in \"WriteLn\". The procedures doing the actual work look very similar, \"String\" versus \"WriteString\" and \"Ln\" versus \"WriteLn\".  \n\n\nLine ends vary between operating systems. Unix-like systems usually use a line feed. DOS/Windows systems use a carriage return and line feed. Oberon Systems use only a carriage return. If we're going to the trouble of re-creating our \"WriteString\" and \"WriteLn\" procedures it also makes sense to handle the different line ending options.  In this case I've chosen to use an INTEGER variable global to the module called \"eolType\". I have a small set of constants to indicate which line ending is needed. In \"WriteLn\" I use that value as a guide to which line ending to use with the rider writing to the file.\n\nThe reason I chose this approach is because I want my writing procedures to use the same procedure signatures as the \"Files\" module. In a future post I will explore type conversion and a revised implementation of my \"Fmt\" module focusing on working with plain text files.\n\nAside from our file setup and picking an appropriate end of line marker the shape of the two programs look very similar.\n\nReferences and resources\n------------------------\n\nYou can see a definition of the [Files](https://miasap.se/obnc/obncdoc/basic/Files.def.html \"My example module definition is based on the on Karl created in OBNC\") at Karl LandstrÃ¶m's documentation for his compiler along with the definitions for [In](https://miasap.se/obnc/obncdoc/basic/In.def.html) and [Out](https://miasap.se/obnc/obncdoc/basic/Out.def.html).\n\n\nNext & Previous\n---------------\n\n- Next [Portable Conversions (Integers)](../../11/26/Portable-Conversions-Integers.html)\n- Prev [Combining Oberon-07 with C using Obc-3](../../06/14/Combining-Oberon-07-with-C-using-Obc-3.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-11-12",
        "keywords": [
          "Oberon",
          "Files",
          "plain text"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 20,
        "title": "Revisiting Files"
      },
      "url": "posts/2021/11/22/Revisiting-Files.json"
    }
  ]
}