{
  "page": 1,
  "total_pages": 1,
  "has_more": false,
  "next_page": null,
  "values": [
    {
      "content": "\n\n# Portable Oberon-07\n\n## using OBNC modules\n\nThis is the eleventh post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series.\nMostly Oberon documents my exploration of the Oberon Language, Oberon System and the\nvarious rabbit holes I will inevitably fall into.\n\n## Working with standard input\n\nBy R. S. Doiel, 2020-08-15 (updated: 2020-09-05)\n\nKarl Landstr√∂m's [OBNC](https://miasap.se/obnc/), Oberon-07 compiler,\ncomes with an Oberon-2 inspired set of modules\ndescribed in the Oakwood Guidelines as well as\nseveral very useful additions making Oberon-07 suitable for\nwriting programs in a POSIX environment.  We're going to\nexplore three of the Oakwood modules and two of Karl's own additions\nin this post as we create a program called [SlowCat](SlowCat.Mod).\nI am using the term \"portable\" to mean the code can be compiled\nusing OBNC on macOS, Linux, and Raspberry Pi OS and Windows 10\n(i.e. wherever OBNC is available). The Oakwood Guideline modules\nfocus on portability between an Oberon System and other systems.\nI'll leave that discussion along with\n[POW!](http://www.fim.uni-linz.ac.at/pow/pow.htm)\nto the end of this post.\n\n\n### SlowCat\n\nRecently while I was reviewing logs at work using [cat](https://en.wikipedia.org/wiki/Cat_(Unix)), [grep](https://en.wikipedia.org/wiki/Grep)\nand [more](https://en.wikipedia.org/wiki/More_(command)) it\nstruck me that it would have been nice if **cat**\nor **more** came with a time delay so you could use them like a\nteleprompter. This would let you casually watch the file scroll\nby while still being able to read the lines. The program we'll build\nin this post is \"SlowCat\" which accepts a command line parameter\nindicating the delay in seconds between display each line read from\nstandard input.\n\n## Working with Standard Input and Output\n\nThe Oakwood guides for Oberon-2 describe two modules\nparticularly useful for working with standard input and output.\nThey are appropriately called `In` and `Out`. On many Oberon Systems\nthese have been implemented such that your code could run under Unix\nor Oberon System with a simple re-compile.  We've used `Out` in our\nfirst program of this series, \"Hello World\". It provides a means to\nwrite Oberon system base types to standard out.  We've used `In`\na few times too. But `In` is worth diving into a bit more.\n\n### In\n\nThe [In](http://miasap.se/obnc/obncdoc/basic/In.def.html) module provides\na mirror of inputs to those of [Out](http://miasap.se/obnc/obncdoc/basic/Out.def.html). In Karl's implementation we are interested in one procedure\nand module status variable.\n\n+ `In.Line(VAR line: ARRAY OF CHAR)` : Read a sequence of characters from standard input from the current position in the file to the end of line.\n+ `In.Done` : Is a status Boolean variable, if the last call to an procedure in `In` was successful then it is set TRUE, otherwise FALSE (e.g. we're at the end of a file)\n\nWe use Karl's `In.Line()` extension to the standard `In` implementation\nbefore and will do so again as it simplifies our code and keeps things\neasily readable.\n\nThere is one nuance with `In.Done` that is easy to get tripped up on.\n`In.Done` indicates if the last operation was successful.\nSo if you're using `In.Line()` then `In.Done`\nshould be true if reading the line was successful. If you hit the end of\nthe file then `In.Done` should be false.  When you write your loop\nthis can be counter intuitive.  Here is a example of testing `In.Done`\nwith a repeat until loop.\n\n\n~~~\n\n    REPEAT\n      In.Line(text);\n      IF In.Done THEN\n        Out.String(text);Out.Ln();\n      END;\n    UNTIL In.Done = FALSE;\n\n~~~\n\n\nSo when you read this it is easy to think of `In.Done` as you're\ndone reading from standard input but actually we need to check for `FALSE`.\nThe value of `In.Done` was indicating the success of reading our line.\nAn unsuccessful line read, meaning we're at the end of the file, sets\n`In.Done` to false!\n\n### Out\n\nAs mention `Out` provides our output functions. We'll be using\ntwo procedure from `Out`, namely `Out.String()` and `Out.Ln()`.\nWe've seen both before.\n\n### Input\n\n\"SlowCat\" needs to calculate how often to write a line of\ntext to standard output with the `Out` module.  To do that\nI need access to the system's current time.  There isn't an\nOakwood module for time. There is a module called \n`Input` which provides a \"Time\" procedure. As a result\nI need to import `Input` as well as `In` even though\nI am using `In` to manage reading the file I am processing\nwith \"SlowCat\".\n\nA note about Karl's implementation.  `Input` is an Oakwood\nmodule that provides access to three system resources -- \nmouse, keyboard and system time.  Karl \nprovides two versions `Input` and `Input0`, the first is\nintended to be used with the `XYPlane` module for graphical\napplications the second for POSIX shell based application.\nIn the case of \"SlowCat\" I've stuck with `Input` as I am \nonly accessing time I've stuck with `Input` to make my source\ncode more portable if you're using another Oberon compiler.\n\n## Working with Karl's extensions\n\nThis is the part of my code which is not portable\nbetween compiler implementations and with Oberon Systems.\nKarl provides a number of extension module wrapping various\nPOSIX calls.  We are going to use two,\n[extArgs](http://miasap.se/obnc/obncdoc/ext/extArgs.def.html)\nwhich provides access to command line arguments and\n[extConvert](http://miasap.se/obnc/obncdoc/ext/extConvert.def.html)\nwhich provides a means of converting strings to integers.\nIf you are using another Oberon compiler you'll need to \nfind their equivalents and change my code example. I\nuse `extArgs` to access the command line parameters\nincluded in my POSIX shell invocation and I've used\n`extConvert` to convert the string presentation of the\ndelay to an integer value for my delay.\n\n\n## Our Approach\n\nTo create \"SlowCat\" we need four procedures and one\nglobal variable.\n\n`Usage()`\n: display a help text if parameters don't make sense\n\n`ProcessArgs()`\n: to get our delay time from the command line\n\n`Delay(count : INTEGER)`\n: a busy wait procedure\n\n`SlowCat(count : INTEGER)`\n: take standard input and display like a teleprompter\n\n`count`\n: is an integer holding our delay value (seconds of waiting) which is set by ProcessArgs()\n\n### Usage\n\nUsage just wraps helpful text and display it to standard out.\n\n## ProcessArgs()\n\nThis a functional procedure. It uses two of Karl's extension\nmodules. It uses `extArgs` to retrieve the command line parameters\nand `extConvert` the string value retrieved into an integer.\n`ProcessArgs()` returns TRUE if we can successful convert the\ncommand line parameter and set the value of count otherwise return\nFALSE.\n\n## Delay(VAR count : INTEGER)\n\nThis procedure uses `Input0` to fetch the current epoch time\nand counts the number of seconds until we've reached our delay\nvalue. It's a busy loop which isn't ideal but does keep the\nprogram simple.\n\n## SlowCat(VAR count: INTEGER);\n\nThis is the heart of our command line program. It reads\na line of text from standard input, if successful writes it\nto standard out and then waits using delay before repeating\nthis process. The delay is only invoked when a reading a\nline was successful.\n\n## Putting it all together\n\nHere's a \"SlowCat\" program.\n\n\n~~~\n\n    MODULE SlowCat;\n      IMPORT In, Out, Input, Args := extArgs, Convert := extConvert;\n\n    CONST\n      MAXLINE = 1024;\n\n    VAR\n      count: INTEGER;\n\n    PROCEDURE Usage();\n    BEGIN\n      Out.String(\"USAGE:\");Out.Ln();\n      Out.Ln();\n      Out.String(\"SlowCat outputs lines of text delayed by\");Out.Ln();\n      Out.String(\"a number of seconds. It takes one parameter,\");Out.Ln();\n      Out.String(\"an integer, which is the number of seconds to\");Out.Ln();\n      Out.String(\"delay a line of output.\");Out.Ln();\n      Out.String(\"SlowCat works on standard input and output.\");Out.Ln();\n      Out.Ln();\n      Out.String(\"EXAMPLE:\");\n      Out.Ln();\n      Out.String(\"    SlowCat 15 < README.md\");Out.Ln();\n      Out.Ln();\n    END Usage;\n\n    PROCEDURE ProcessArgs() : BOOLEAN;\n      VAR i : INTEGER; ok : BOOLEAN; arg : ARRAY MAXLINE OF CHAR;\n          res : BOOLEAN;\n    BEGIN\n      res := FALSE;\n      IF Args.count = 1 THEN\n        Args.Get(0, arg, i);\n        Convert.StringToInt(arg, i, ok);\n        IF ok THEN\n           (* convert seconds to microseconds of clock *)\n           count := (i * 1000);\n           res := TRUE;\n        END;\n      END;\n      RETURN res\n    END ProcessArgs;\n\n    PROCEDURE Delay*(count : INTEGER);\n      VAR start, current, delay : INTEGER;\n    BEGIN\n       start := Input.Time();\n       REPEAT\n         current := Input.Time();\n         delay := (current - start);\n       UNTIL delay >= count;\n    END Delay;\n\n    PROCEDURE SlowCat(count : INTEGER);\n      VAR text : ARRAY MAXLINE OF CHAR;\n    BEGIN\n      REPEAT\n        In.Line(text);\n        IF In.Done THEN\n          Out.String(text);Out.Ln();\n          (* Delay by count *)\n          Delay(count);\n        END;\n      UNTIL In.Done = FALSE;\n    END SlowCat;\n\n    BEGIN\n      count := 0;\n      IF ProcessArgs() THEN\n        SlowCat(count);\n      ELSE\n        Usage();\n      END;\n    END SlowCat.\n\n~~~\n\n\n## Compiling and trying it out\n\nTo compile our program and try it out reading\nour source code do the following.\n\n\n~~~\n\n    obnc SlowCat.Mod\n    # If successful\n    ./SlowCat 2 < SlowCat.Mod\n\n~~~\n\n\n\n## Oakwood Guidelines and POW!\n\nOberon and Oberon-2 were both used in creating and enhancing the\nOberon System(s) as well as for writing programs on other operating\nsystems (e.g. Apple's Mac and Microsoft Windows).\nImplementing Oberon compilers on non Oberon Systems required clarification\nbeyond the specification. The Oakwood Guidelines were an agreement\nbetween some of the important Oberon-2 compiler implementers which\nattempted to fill in that gap while encouraging portability in\nsource code between operating systems. Portability was desirable\nbecause it allowed programmers (e.g. students) to compile\nand run their Oberon programs with minimal modification in any\nenvironment where an Oakwood compliant compiler was available.\n\nCitation for Oakwood can be found in [Oberon-2 Programming with Windows](https://archive.org/details/oberonprogrammin00mhlb/page/n363/mode/2up?q=Oakwood+Guidlines).\n\n> Kirk B.(ed): The Oakwood Guidelines for Oberon-2 Compiler Developers. Available via FTP from ftp.fim.uni-linz.ac.at, /pub/soft/pow-oberon/oakwood\n\nThe FTP machine doesn't exist any more and does not appear to have been included in JKU's preservation plans. Fortunately the POW! website has been preserved.\n\n[POW!](http://www.fim.uni-linz.ac.at/pow/pow.htm) was a\ndifferent approach. It was a compiler and IDE targeting\nother than Oberon Systems (e.g. Windows and later Java). It was\nintended to be used in a hybrid development environment and to\nfacilitate leveraging non-Oberon resources (e.g. Java classes,\nnative Windows API).  POW project proposed \"Opal\" which was a\nsuper set of modules that went beyond Oakwood. Having skimmed\n\"Oberon-2 Programming with Windows\" some may seem reasonable to\nport to Oberon-07, others less so.\n\nWhy Oakwood and POW? These efforts are of interest to Oberon-07\ndevelopers as a well worn path to write code that is easy to\ncompile on POSIX systems and on systems that are based on the\nmore recent [Project Oberon 2013](http://www.projectoberon.com/).\nIt enhances the opportunity to bring forward well written modules\nfrom prior systems like [A2](https://en.wikibooks.org/wiki/Oberon/A2)\nbut implemented for the next generation of Oberon Systems\nlike [Integrated Oberon](https://github.com/io-core/io).\n\n### Oakwood PDF\n\nFinding a PDF of the original Oakwood guidelines is going to become\ntricky in the future. It was created by Robinson Associates and the\ncopy I've read from 1995 includes a page saying not for distribution.\nWhich sorta makes sense in the era of closed source software\ndevelopment. It is problematic for those of us who want to explore\nhow systems evolved.  The term \"Oakwood Guidelines\" is bandied about\nafter 1993 and several of the modules have had influence on the language\nuse via book publications.  I was able to find a PDF of the 1995\nversion of the guidelines at\n[http://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf](http://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf).\n\nHere's a typical explanation of Oakwood from \n[http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines](http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines)\nfor a description of Oakwood.\n\n> __The Oakwood Guidelines for the Oberon-2 Compiler Developers /These guidelines have been produced by a group of Oberon-2 compiler developers, including ETH developers, after a meeting at the Oakwood Hotel in Croydon, UK in June 1993__\n\n[http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines](http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines)  \n(an OS/2 developer website) was helpful for providing details about Oakwood.\n\nIt would have been nice if the Oakwood document had made its way\ninto either ETH's or JKU's research libraries.\n\nLeveraging prior art opens doors to the past and future. Karl has\ndone with this with the modules he provides with his OBNC compiler\nproject.\n\n### Next and Previous\n\n+ Next [Oberon to Markdown](../../10/03/Oberon-to-markdown.html)\n+ Previous [Procedures in records](../..//07/07/Procedures-in-records.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-08-15",
        "keywords": [
          "Oberon",
          "portable",
          "stdin"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 11,
        "series": "Mostly Oberon",
        "title": "Portable Oberon-07"
      },
      "url": "posts/2020/08/15/Portable-Oberon-07.json"
    },
    {
      "content": "\n\nOberon to Markdown\n==================\n\nThis is the twelfth post in the [Mostly Oberon](https://rsdoiel.github.io/blog/2020/04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\nA nice feature of Oberon\n------------------------\n\nOberon source code has a very nice property in that anything\nafter the closing end statement is ignored by the compiler.\nThis makes it a nice place to write documentation, program\nnotes and other ideas.\n\nI've gotten in the habit of writing up program docs and\nnotes there. When I prep to make a web document I used to\ncopy the source file, doing a cut and paste to re-order\nthe module code to the bottom of the document. I'd follow\nthat with adding headers and code fences. Not hard but\ntedious. Of course if I changed the source code I'd also\nhave to do another cut and paste edit. This program,\n`ObnToMd.Mod` automates that process.\n\nProgram Documentation\n---------------------\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n  ObnToMd\n\nFUNCTION\n\n  This is a simple program that reads Oberon modules\n  from standard in and re-renders that to standard output\n  such that it is suitable to process with Pandoc or other\n  text processing system.\n\nEXAMPLE\n\n  Read the source for this program and render a file\n  called \"blog-post.md\". Use Pandoc to render HTML.\n\n    ObnToMd <ObnToMd.Mod > blog-post.md\n    pandoc -s --metadata title=\"Blog Post\" \\\n        blog-post.md >blog-post.html\n\nBUGS\n\n  It uses a naive line analysis to identify the module\n  name and then the end of module statement. Might be\n  tripped up by comments containing the same strings.\n  The temporary file created is called \"o2m.tmp\" and\n  this filename could potentially conflict with another\n  file.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\nSource code for **ObnToMd.Mod**\n-------------------------------\n\n~~~\n\n(* ObnToMd.Mod - an simple filter process for reading\nan Oberon-07 module source file and rendering a markdown\nfriendly output suitable for piping into Pandoc. The\nfilter reads from standard input and writes to standard\noutput and makes use of a temp file name o2m.tmp which\nit removes after successful rendering.\n\n@Author R. S. Doiel, <rsdoiel@gmail.com>\ncopyright (c) 2020, all rights reserved.\nReleased under the BSD 2-clause license\nSee: https://opensource.org/licenses/BSD-2-Clause\n*)\nMODULE ObnToMd;\n  IMPORT In, Out, Files, Strings;\n\nCONST\n  MAXLENGTH = 1024;\n  LF = CHR(10);\n\nVAR\n  endOfLine : ARRAY 2 OF CHAR;\n\n(*\n * Helper methods\n *)\nPROCEDURE GenTempName(prefix, suffix : ARRAY OF CHAR; VAR name : ARRAY OF CHAR);\nBEGIN\n  name := \"\";\n  Strings.Append(prefix, name);\n  Strings.Append(\".\", name);\n  Strings.Append(suffix, name);\nEND GenTempName;\n\nPROCEDURE GenTempFile(name : ARRAY OF CHAR; VAR r : Files.Rider; VAR f : Files.File);\nBEGIN\n  f := Files.New(name);\n  IF f = NIL THEN\n    Out.String(\"ERROR: can't create \");Out.String(name);Out.Ln();\n    ASSERT(FALSE);\n  END;\n  Files.Register(f);\n  Files.Set(r, f, 0);\nEND GenTempFile;\n\n\nPROCEDURE StartsWith(target, source : ARRAY OF CHAR) : BOOLEAN;\n  VAR res : BOOLEAN;\nBEGIN\n  IF Strings.Pos(target, source, 0) > -1 THEN\n    res := TRUE;\n  ELSE\n    res := FALSE;\n  END;\n  RETURN res\nEND StartsWith;\n\nPROCEDURE ClearString(VAR s : ARRAY OF CHAR);\n  VAR i : INTEGER;\nBEGIN\n  FOR i := 0 TO LEN(s) - 1 DO\n    s[i] := 0X;\n  END;\nEND ClearString;\n\n\nPROCEDURE ProcessModuleDef(VAR r : Files.Rider; VAR modName : ARRAY OF CHAR);\n  VAR\n    line, endStmt : ARRAY MAXLENGTH OF CHAR;\n    start, end : INTEGER;\nBEGIN\n  line := \"\";\n  endStmt := \"\";\n  modName := \"\";\n  (* Find the name of the module and calc the \"END {NAME}.\" statement *)\n  REPEAT\n    ClearString(line);\n    In.Line(line);\n    IF In.Done THEN\n      Files.WriteString(r, line); Files.WriteString(r, endOfLine);\n      (* When `MODULE {NAME};` is encountered extract the module name *)\n      IF StartsWith(\"MODULE \", line) THEN\n        start := 7;\n        end := Strings.Pos(\";\", line, 0);\n        IF (end > -1) & (end > start) THEN\n            Strings.Extract(line, start, end - start, modName);\n            endStmt := \"END \";\n            Strings.Append(modName, endStmt);\n            Strings.Append(\".\", endStmt);\n        END;\n      END;\n    END;\n  UNTIL (In.Done # TRUE) OR (endStmt # \"\");\n\n  (* When `END {NAME}.` is encountered  stop writing tmp file *)\n  REPEAT\n    In.Line(line);\n    IF In.Done THEN\n      Files.WriteString(r, line); Files.WriteString(r, endOfLine);\n    END;\n  UNTIL (In.Done # TRUE) OR StartsWith(endStmt, line);\nEND ProcessModuleDef;\n\nPROCEDURE WriteModuleDef(name : ARRAY OF CHAR; VAR r : Files.Rider; VAR f : Files.File);\n  VAR s : ARRAY MAXLENGTH OF CHAR; res : INTEGER;\nBEGIN\n  Files.Set(r, f, 0);\n  REPEAT\n    Files.ReadString(r, s);\n    IF r.eof # TRUE THEN\n      Out.String(s);\n    END;\n  UNTIL r.eof;\n  Files.Close(f);\n  Files.Delete(name, res);\nEND WriteModuleDef;\n\n\nPROCEDURE OberonToMarkdown();\nVAR\n  tmpName, modName, line : ARRAY MAXLENGTH OF CHAR;\n  f : Files.File;\n  r : Files.Rider;\n  i : INTEGER;\nBEGIN\n  tmpName := \"\"; modName := \"\";  line := \"\";\n  (* Open temp file *)\n  GenTempName(\"o2m\", \"tmp\", tmpName);\n  GenTempFile(tmpName, r, f);\n\n  (* Read the Oberon source from standard input echo the lines tmp file *)\n  ProcessModuleDef(r, modName);\n\n  (* Write remainder of file to standard out *)\n  REPEAT\n    In.Line(line);\n    IF In.Done THEN\n      Out.String(line);Out.Ln();\n    END;\n  UNTIL In.Done # TRUE;\n\n  (* Write two new lines *)\n  Out.Ln(); Out.Ln();\n  (* Write heading `Source code for {NAME}` *)\n  ClearString(line);\n  line := \"Source code for **\";\n  Strings.Append(modName, line);\n  Strings.Append(\".Mod**\", line);\n  Out.String(line); Out.Ln();\n  FOR i := 0 TO Strings.Length(line) - 1 DO\n    Out.String(\"-\");\n  END;\n  Out.Ln();\n  (* Write code fence *)\n  Out.Ln();Out.String(\"~~~\");Out.Ln();\n  (* Reset rider to top of tmp file\n     Write temp file to standard out\n     cleanup demp file *)\n  WriteModuleDef(tmpName, r, f);\n  (* Write code fence *)\n  Out.Ln();Out.String(\"~~~\");Out.Ln();\n  (* Write tailing line and exit procedure *)\n  Out.Ln();\nEND OberonToMarkdown;\n\nBEGIN\n  endOfLine[0] := LF;\n  endOfLine[1] := 0X;\n  OberonToMarkdown();\nEND ObnToMd.\n\n~~~\n\n### Next, Previous\n\n+ Next [Assembling Pages](../../10/19/Assemble-pages.html)\n+ Previous [Portable Oberon-07](../../08/15/Portable-Oberon-07.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-10-03",
        "keywords": [
          "Oberon",
          "portable",
          "markdown",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 12,
        "series": "Mostly Oberon",
        "title": "Oberon to Markdown"
      },
      "url": "posts/2020/10/03/Oberon-to-markdown.json"
    },
    {
      "content": "\n\nAssembling pages\n================\n\nThis is the thirteenth post in the [Mostly Oberon](https://rsdoiel.github.io/blog/2020/04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\nPandoc and JSON\n---------------\n\nI use [Pandoc](https://pandoc.org) to process Markdown documents. I like to keep my\nfront matter in JSON rather than Pandoc's YAML. Fortunately Pandoc\ndoes support working with JSON as a metadata file include. Normally I would\nmanually split the JSON front matter and the rest of the markup into two\nseparate files, then process with Pandoc and other tooling like\n[LunrJS](https://lunrjs.com). [AssemblePage](AssemblePage.Mod) automates this\nprocess.\n\nExample shell usage:\n\n~~~\n\n   AssemblePage MyText.txt \\\n      metadata=document.json \\\n      document=document.md\n   pandoc --from markdown --to html \\\n      --metadata-file document.json \\\n      --standalone \\\n      document.md >MyText.html\n\n~~~\n\nSource code for **AssemblePage.Mod**\n------------------------------------\n\n~~~\n\nMODULE AssemblePage;\n  IMPORT Out, Strings, Files, Args := extArgs;\n\nVAR\n  srcName, metaName, docName : ARRAY 1024 OF CHAR;\n\n(* FrontMatter takes a \"read\" Rider, r, and a \"write\" Rider \"w\".\nIf the first character read by r is an opening curly bracket\n(the start of the front matter) it writes it out with w, until\nit finds a matching closing curly bracket or the file ends. *)\nPROCEDURE FrontMatter*(VAR r : Files.Rider; VAR w : Files.Rider);\n  VAR c : BYTE; cCnt : INTEGER;\nBEGIN\n  (* Scan for opening JSON front matter *)\n  cCnt := 0;\n  REPEAT\n    Files.Read(r, c);\n    IF r.eof = FALSE THEN\n      IF c = ORD(\"{\") THEN\n        cCnt := cCnt + 1;\n      ELSIF c = ORD(\"}\") THEN\n        cCnt := cCnt - 1;\n      END;\n      Files.Write(w, c);\n    END;\n  UNTIL (r.eof = TRUE) OR (cCnt = 0);\n  IF cCnt # 0 THEN\n    Out.String(\"ERROR: mis matched '{' and '}' in front matter\");\n    ASSERT(FALSE);\n  END;\nEND FrontMatter;\n\n(* CopyIO copies the characters from a \"read\" Rider to a \"write\" Rider *)\nPROCEDURE CopyIO*(VAR r : Files.Rider; VAR w: Files.Rider);\n  VAR c : BYTE;\nBEGIN\n  REPEAT\n    Files.Read(r, c);\n    IF r.eof = FALSE THEN\n      Files.Write(w, c);\n    END;\n  UNTIL r.eof = TRUE;\nEND CopyIO;\n\nPROCEDURE ProcessParameters(VAR sName, mName, dName : ARRAY OF CHAR);\n  VAR\n    arg : ARRAY 1024 OF CHAR;\n    i, res : INTEGER;\nBEGIN\n  mName := \"document.json\";\n  dName := \"document.txt\";\n  arg := \"\";\n  FOR i := 0 TO (Args.count - 1) DO\n    Args.Get(i, arg, res);\n    IF Strings.Pos(\"metadata=\", arg, 0) = 0 THEN\n      Strings.Extract(arg, 9, Strings.Length(arg), mName);\n    ELSIF Strings.Pos(\"document=\", arg, 0) = 0 THEN\n      Strings.Extract(arg, 9, Strings.Length(arg), dName);\n    ELSE\n      Strings.Extract(arg, 0, Strings.Length(arg), sName);\n    END;\n  END;\nEND ProcessParameters;\n\nPROCEDURE AssemblePage(srcName, metaName, docName : ARRAY OF CHAR);\nVAR\n  src, meta, doc : Files.File;\n  reader, writer : Files.Rider;\nBEGIN\n  src := Files.Old(srcName);\n  IF src # NIL THEN\n    Files.Set(reader, src, 0);\n    IF metaName # \"\" THEN\n      meta := Files.New(metaName);\n      Files.Register(meta);\n      Files.Set(writer, meta, 0);\n      FrontMatter(reader, writer);\n      Files.Close(meta);\n    END;\n    IF docName # \"\" THEN\n      doc := Files.New(docName);\n      Files.Register(doc);\n      Files.Set(writer, doc, 0);\n      CopyIO(reader, writer);\n      Files.Close(doc);\n    END;\n  ELSE\n    Out.String(\"ERROR: Could not read \");Out.String(srcName);Out.Ln();\n    ASSERT(FALSE);\n  END;\n  Files.Close(src);\nEND AssemblePage;\n\nBEGIN\n  ProcessParameters(srcName, metaName, docName);\n  AssemblePage(srcName, metaName, docName);\nEND AssemblePage.\n\n~~~\n\n### Next, Previous\n\n+ Next [Dates & Clock](../../11/27/Dates-and-Clock.html)\n+ Previous [Oberon To Markdown](../../10/03/Oberon-to-markdown.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-10-19",
        "keywords": [
          "Oberon-07",
          "portable",
          "markdown",
          "pandoc",
          "frontmatter"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 13,
        "series": "Mostly Oberon",
        "title": "Assembling Pages"
      },
      "url": "posts/2020/10/19/Assemble-pages.json"
    }
  ]
}