{
  "page": 1,
  "total_pages": 1,
  "has_more": false,
  "next_page": null,
  "values": [
    {
      "content": "\n\nPandoc & Metadata \n=================\n\nPandoc supports three ways of providing metadata to its template\nengine. \n\n1. Front matter\n2. Command line optional metadata\n3. A JSON metadata file.\n\nFront matter\n------------\n\nFront matter is a community term that comes from physical world\nof paper books and articles.  It is the information that comes \nbefore the primary content.  This information might be things \nlike title, author, publisher and publication date. These days \nit'll also include things like identifiers like ISSN, ISBN possibly \nnewer identifiers like DOI or ORCID. In the library and programming\ncommunity we refer to this type of structured information as\nmetadata.  Data about the publication or article.\n\nMany publication systems like TeX/LaTeX support provided means of \nincorporating metadata into the document.  When simple markup formats \nlike Markdown, Textile and Asciidoc became popular the practice was \ncontinued by including the metadata in some sort of structured encoding\nat the beginning of the document. The community adopted the term from\nthe print world, \"front matter\". \n\nPandoc provides for several ways of working with metadata and supports\none format of front matter encoding called [YAML](https://yaml.org/). \nOther markup processors support other encoding of front matter. Two\npopular alternatives of encoding are [TOML](https://toml.io/en/) and \n[JSON](https://json.org).  If you use one of the alternative encoding\nfor your front matter then you'll need to split the front matter\nout of your document before processing with Pandoc[^1].  \n\n[^1]: The [MkPage Project](https://caltechlibrary.github.io/mkpage/) provides a tool called [frontmatter](https://caltechlibrary.github.io/mkpage/docs/frontmatter/) that can be easy or your can easily roll your own in Python or other favorite language.\n\n\nIf you provide YAML formatted front matter Pandoc will pass this\nmetadata on and make it available to it's template engine and the\ntemplates you create to render content with Pandoc. See the Pandoc\nUser Guide section [YAML metadata blocks](https://pandoc.org/MANUAL.html#extension-yaml_metadata_block) for more details. If you've used another\nencoding of front matter then the metadata file approach is probably\nthe ticket.\n\nMetadata passed by command line\n-------------------------------\n\nIf you only have a metadata elements you would like to\nmake available to the template (e.g. title, pub date) you\ncan easily add them using the `--metadata` command line option.\nThis is documented in the Pandoc User Guide under the heading\n[Reader Options](https://pandoc.org/MANUAL.html). Here's a simple\nexample where we have a title, \"U. S. Constitution\" and a\npublication date of \"September 28, 1787\".\n\n~~~{.shell}\n    pandoc --metadata \\\n        title=\"U. S. Constitution\" \\\n        pubdate=\"September 28, 1787\" \\\n        --from markdown --to html --template doc1.tmpl \\\n        constitution.txt\n~~~\n\nThe template now has two additional values available as metadata\nin addition to `body`, namely `pubdate` and `title`. Here's an\nexample template [doc1.tmpl](doc1.tmpl).\n\n~~~\n\n   <!DOCTYPE html>\n   <html>\n   <head>\n       <title>${title}</title>\n   </head>\n   <body>\n      <h1>${title}</h1>\n      <h2>${pubdate}</h2>\n      <p>\n      ${body}\n      <p>\n   </body>\n   </html>\n\n~~~\n\nMore complex metadata is better suited to creating a JSON document\nwith the structure you need to render your template.\n\n\nMetadata file\n-------------\n\nMetadata files can be included with the option `--metadata-file`. This\nlike the `--metadata` option are discussed in the Pandoc User Guide under\nthe [Read Options(https://pandoc.org/MANUAL.html) heading.  The JSON \ndocument should contain an Object where each attribute corresponds to\nthe variable you wish to referenced in template.  Pandoc's template\nengine support both single values but also objects and arrays. In this\nway you can structure the elements you wish to include even elements\nwhich are iterative (e.g. a list of links or topics). Below is a\nJSON data structure that includes the page title as well as links\nfor the navigation.  The nav attribute holds a list of objects \nwith attributes of href and label containing data that will be used\nto render a list of anchor elements in the template.\n\n\n~~~{.json}\n\n    {\n        \"title\": \"U. S. Constitution\",\n        \"pubdate\": \"September 28, 1787\",\n        \"nav\": [\n            {\"label\": \"Pandoc Metadata\", \"href\": \"Pandoc-Metadata.html\" },\n            {\"label\": \"Magnacarta\", \"href\": \"magnacarta.html\" },\n            {\"label\": \"Declaration of Independence\", \"href\": \"independence.html\" },\n            {\"label\": \"U. S. Constitution\", \"href\": \"constitution.html\"}\n        ]\n    }\n\n~~~\n\nHere's a revised template to include the navigation,\nsee [doc2.tmpl](doc2.tmpl).\n\n~~~\n\n   <!DOCTYPE html>\n   <html>\n   <head>\n       <title>${title}</title>\n   </head>\n   <body>\n      <nav>\n      ${for(nav)}<a href=\"${nav.href}\">${nav.label}</a>${sep}, ${endfor}\n      </nav>\n      <h1>${title}</h1>\n      ${if(pubdate)}<h2>${pubdate}</h2>${endif}\n      <p>\n      ${body}\n      <p>\n   </body>\n   </html>\n\n~~~\n\n\nCombining Techniques\n--------------------\n\nIt is worth noting that these approaches can be mixed and matched.\nIn the following example I use the same [metadata.json](metadata.json)\nfile which has title and pubdate attributes but override them\nusing the command line `--metadata` option. In this way I can use that \nfile along with [doc2.tmpl](doc2.tmpl) and render each \nTo render the constitution page from a Markdown version of the \nU. S. Constitution you could use the following Pandoc command:\n\n~~~{.shell}\n\n\tpandoc --from markdown --to html --template doc2.tmpl \\\n        --metadata-file metadata.json \\\n        --metadata title=\"Magna Carta\" \\\n\t\t--metadata pubdate=\"1215\" \\\n\t\t-o magnacarta.html \\\n\t\tmagnacarta.txt\n\n\tpandoc --from markdown --to html --template doc2.tmpl \\\n        --metadata-file metadata.json \\\n        --metadata title=\"The Declaration of Indepenence\" \\\n\t\t--metadata pubdate=\"July 4, 1776\" \\\n        -o independence.html \\\n        independence.txt\n\n\tpandoc --from markdown --to html --template doc2.tmpl \\\n        --metadata-file metadata.json \\\n        --metadata title=\"U. S. Constitution\" \\\n\t\t--metadata pubdate=\"September 28, 1787\" \\\n        -o constitution.html \\\n        constitution.txt\n\n~~~\n\nSee [Magna Carta](magnacarta.html), [The Declaration of Independence](independence.html), [U. S. Constitution](constitution.html)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "keywords": [
          "Pandoc",
          "Metadata",
          "Templates"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 2,
        "series": "Pandoc Techniques",
        "title": "Pandoc & Metadata"
      },
      "url": "posts/2020/11/11/Pandoc-Metadata.json"
    },
    {
      "content": "\n\nPandoc Partial Templates\n========================\n\nMost people know about [Pandoc](https://pandoc.org/) from its\nfantastic ability to convert various markup formats from one to\nanother. A little less obvious is Pandoc can be a template engine\nfor rendering static websites allowing you full control over the\nrendered content.\n\nThe main Pandoc documentation of the template engine can be found\nin the [User Guide](https://pandoc.org/MANUAL.html#templates).\nThe documentation is complete in terms of describing the template\ncapabilities but lacks a tutorial for using as a replacement for more\nambitious rendering systems like [Jekyll](https://jekyllrb.com/) or\n[Hugo](https://gohugo.io/). Pandoc takes a vary direct approach and\ncan be deceptively simple to implement.\n\nUse your own template\n---------------------\n\nFirst thing in this tutorial is to use our own template with Pandoc\nwhen rendering a single webpage. You use the `–-template` option to\nprovide your a template name. I think of this as the page level template.\nThis template, as I will show later, can then call other partial\ntemplates as needed.\n\nExample, render the [Pandoc-Partials.txt](Pandoc-Partials.txt) file using the\ntemplate named [index1.tmpl](index1.tmpl):\n\n~~~{.shell}\n\n    pandoc --from=markdown --to=html \\\n        --template=index1.tmpl Pandoc-Partials.txt > index1.htm\n\n~~~\n\nThis is a simple template page level template.\n\n~~~{.html-code}\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n    </head>\n    <body>\n    ${body}\n    </body>\n    </html>\n\n~~~\n\nWhen we run our Pandoc command the file called\n[Pandoc-Partials.txt](Pandoc-Partials.txt) is passed into the template as\nthe \"body\" element where it says `${body}`. See this Pandoc \n[User Guide](https://pandoc.org/MANUAL.html#templates) for the basics.\n\nExample 1 rendered: [index1.htm](index1.htm)\n\nVariables and metadata\n----------------------\n\nPandoc's documentation is good at describing the\nways of referencing a variable or using the built-in\ntemplate functions. Where do the variables get their values?\nThe easiest way I've found is to set the variables values in\na JSON metadata file.  While Pandoc can also use the metadata\ndescribed in YAML front matter Pandoc doesn't support some of the\nother common front matter formats.  If you're using another format\nlike JSON or TOML for front matter there are tools which can split\nthe front matter from the rest of the markdown document. For\nthis example I have created the metadata as JSON in a file\ncalled [metadata.json](metadata.json).\n\nExample [metadata.json](metadata.json):\n\n~~~{.json}\n\n    {\n        \"title\": \"Pandoc Partial Examples\",\n        \"nav\": [\n            {\"label\": \"Pandoc-Partials\", \"href\": \"Pandoc-Partials.html\" },\n            {\"label\": \"Version 1\", \"href\": \"index1.htm\" },\n            {\"label\": \"Version 2\", \"href\": \"index2.htm\" },\n            {\"label\": \"Version 3\", \"href\": \"index3.htm\" }\n        ]\n    }\n\n~~~\n\nLet's modify our initial template to include our simple navigation\nand title.\n\nExample [index2.tmpl](index2.tmpl):\n\n~~~{.html-code}\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n      ${if(title)}<title>${title}</title>${endif}\n    </head>\n    <body>\n    <nav>\n    ${for(nav)}<a href=\"${it.href}\">${it.label}</a>${sep}, ${endfor}\n    </nav>\n    <section>\n    ${body}\n    </section>\n    </body>\n    </html>\n\n~~~\n\nWe would include our navigation metadata with a Pandoc command like\n\n~~~{.shell}\n\n    pandoc --from=markdown --to=html \\\n           --template=index2.tmpl \\\n           --metadata-file=metadata.json Pandoc-Partials.txt > index2.htm\n\n~~~\n\nWhen we render this we now should be able to view a web page\nwith simple navigation driven by the JSON file as well as the\nbody content contained in the Pandoc-Partials.txt file.\n\nExample 2 rendered: [index2.htm](index2.htm)\n\nPartials\n--------\n\nSometimes you have more complex documents. Putting this all in\none template can become tedious. Web designers use a term called\n\"partials\". This usually means a template for a \"part\" of a page.\nIn our initial example we can split our navigation into it's own\ntemplate.\n\nImplementing partials\n---------------------\n\nPandoc will look in the current directory for partials as well\nas in a sub directory called \"templates\" of the current direct.\nIn this example I am going to include my partial template for\nnavigation in the current directory along side my\n[index3.tmpl](index3.tmpl).  My navigation template is called\n[nav.tmpl](nav.tmpl).\n\nHere's my partial template:\n\n~~~{.html-code}\n\n    <nav>\n    ${for(nav)}<a href=\"${it.href}\">${it.label}</a>${sep}, ${endfor}\n    </nav>\n\n~~~\n\nHere's my third iteration of our index template, [index3.tmpl](index3.tmpl).\n\n~~~{.html-code}\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n    ${if(title)}<title>${title}</title>${endif}\n    </head>\n    <body>\n    ${if(nav)}\n    ${nav.tmpl()}\n    ${endif}\n    <section>\n    ${body}\n    </section>\n    </body>\n    </html>\n\n~~~\n\nPandoc only requires you to reference the partial by using\nits base name. Many people will name their templates with the\nextension \".html\". I find this problematic as if you're trying\nto list the templates in the directory you can not easily list\nthem separately. I use the \".tmpl\" extension to identify my templates.\nSince I have other documents that share the base name \"nav\" I\nexplicit call my navigation partial using the full filename followed\nby the open and closed parenthesis. I have also chosen to wrap\nthe template in an \"if\" condition. That way if I don't want navigation\non a page I skip defining it in my metadata file.\n\nInside the partial template we inherit the parent metadata object.\nYou can use all the built-in Pandoc template functions and variables\nprovided by Pandoc in your partial templates.\n\nPutting it all together:\n\n~~~{.shell}\n\n    pandoc --from=markdown --to=html \\\n           --template=index3.tmpl \\\n           --metadata-file=metadata.json Pandoc-Partials.txt > index3.htm\n\n~~~\n\nExample 3 rendered: [index3.htm](index3.htm)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "keywords": [
          "Pandoc",
          "Templates"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 1,
        "series": "Pandoc Techniques",
        "title": "Pandoc Partials"
      },
      "url": "posts/2020/11/09/Pandoc-Partials.json"
    },
    {
      "content": "\nRevealing the Pandoc AST\n========================\n\nI've used Pandoc for a number of years, probably a decade. It's been wonderful\nwatching it grow in capability. When Pandoc started accepting JSON documents as\na support metadata file things really started to click for me. Pandoc became\nmy go to tool for rendering content in my writing and documentation projects.\n\nRecently I've decided I want a little bit more from Pandoc. I've become curious\nabout prototyping some document conversion via Pandoc's filter mechanism. To do\nthat you need to understand the AST, aka abstract syntax tree. \nHow is the AST structure? \n\nIt turns out I just wasn't thinking simply enough (or maybe just not paying\nenough attention while I skimmed Pandoc's documentation). Pandoc's processing\nmodel looks like\n\n```\n\tINPUT --reader--> AST --filter AST --writer--> OUTPUT\n```\n\nI've \"known\" this forever. The missing piece for me was understanding \nthe AST can be an output format.  Use the `--to` option with the value\n\"native\" you get the Haskell representation of the AST. It's that simple.\n\n```\n\tpandoc --from=markdown --to=native \\\n\t   learning-to-write-a-pandoc-filter.md | \\\n\t   head -n 20\n```\n\nOutput\n\n```\n[ Header\n    1\n    ( \"learning-to-write-a-pandoc-filter\" , [] , [] )\n    [ Str \"Learning\"\n    , Space\n    , Str \"to\"\n    , Space\n    , Str \"write\"\n    , Space\n    , Str \"a\"\n    , Space\n    , Str \"Pandoc\"\n    , Space\n    , Str \"filter\"\n    ]\n, Para\n    [ Str \"I\\8217ve\"\n    , Space\n    , Str \"used\"\n    , Space\n```\n\nIf you prefer JSON over Haskell use `--to=json` for similar effect. Here's\nan example piping through [jq](https://stedolan.github.io/jq/).\n\n```\n\tpandoc --from=markdown --to=json \\\n\t   learning-to-write-a-pandoc-filter.md | jq .\n```\n\nWriting filters makes much sense to me now. I can see the AST and see\nhow the documentation describes writing hooks in Lua to process it.\n\n",
      "data": {
        "copyright": "copyright (c) 2022, R. S. Doiel",
        "keywords": [
          "Pandoc",
          "filter"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 4,
        "series": "Pandoc Techniques",
        "title": "Revealing the Pandoc AST"
      },
      "url": "posts/2022/11/17/revealing-pandoc-ast.json"
    },
    {
      "content": "\n# Pandoc, Pagefind and Make\n\nRecently I've refresh my approach to website generation using three programs.\n\n- [Pandoc](https://pandoc.org)\n- [Pagefind](https://pagefind.app) for providing a full text search of documentation\n- [GNU Make](https://www.gnu.org/software/make/)\n    - [website.mak](website.mak) Makefile\n\nPandoc does the heavy lifting. It renders all the HTML pages, CITATION.cff (from the projects [codemeta.json](codemeta.github.io \"codemeta.json is a metadata documentation schema for documenting software projects\")) and rendering an about.md file (also from the project's codemeta.json). This is done with three Pandoc templates. Pandoc can also be used to rendering man pages following a simple page recipe.\n\nI've recently adopted Pagefind for indexing the HTML for the project's website and providing the full text search UI suitable for a static website. The Pagefind indexes can be combined with your group or organization's static website providing a rich cross project search (exercise left for another post).\n\nFinally I orchestrate the site construction with GNU Make. I do this with a simple dedicated Makefile called [website.mak](#website.mak).\n\n\n## website.mak\n\nThe website.mak file is relatively simple.\n\n```makefile\n#\n# Makefile for running pandoc on all Markdown docs ending in .md\n#\nPROJECT = PROJECT_NAME_GOES_HERE\n\nMD_PAGES = $(shell ls -1 *.md) about.md\n\nHTML_PAGES = $(shell ls -1 *.md | sed -E 's/.md/.html/g') about.md\n\nbuild: $(HTML_PAGES) $(MD_PAGES) pagefind\n\nabout.md: .FORCE\n        cat codemeta.json | sed -E 's/\"@context\"/\"at__context\"/g;s/\"@type\"/\"at__type\"/g;s/\"@id\"/\"at__id\"/g' >_codemeta.json\n        if [ -f $(PANDOC) ]; then echo \"\" | pandoc --metadata title=\"About $(PROJECT)\" --metadata-file=_codemeta.json --template codemeta-md.tmpl >about.md; fi\n        if [ -f _codemeta.json ]; then rm _codemeta.json; fi\n\n$(HTML_PAGES): $(MD_PAGES) .FORCE\n\tpandoc -s --to html5 $(basename $@).md -o $(basename $@).html \\\n\t\t--metadata title=\"$(PROJECT) - $@\" \\\n\t    --lua-filter=links-to-html.lua \\\n\t    --template=page.tmpl\n\tgit add $(basename $@).html\n\npagefind: .FORCE\n\tpagefind --verbose --exclude-selectors=\"nav,header,footer\" --bundle-dir ./pagefind --source .\n\tgit add pagefind\n\nclean:\n\t@if [ -f index.html ]; then rm *.html; fi\n\t@if [ -f README.html ]; then rm *.html; fi\n\n.FORCE:\n```\n\nOnly the \"PROJECT\" value needs to be set. Typically this is just the name of the repository's base directory.\n\n## Pandoc, filters and templates\n\nWhen write my Markdown documents I link to Markdown files instead of the HTML versions. This serves two purposes. First GitHub can use this linking directory and second if you decide to repurposed the website as a Gopher or Gemini resource\nyou don't linking to the Markdown file makes more sense.  To convert the \".md\" names to \".html\" when I render the HTML I use a simple Lua filter called [links-to-html.lua](https://stackoverflow.com/questions/40993488/convert-markdown-links-to-html-with-pandoc#49396058 \"see the stackoverflow answer that shows this technique\").\n\n```lua\n# links-to-html.lua\nfunction Link(el)\n  el.target = string.gsub(el.target, \"%.md\", \".html\")\n  return el\nend\n```\n\nThe \"page.tmpl\" file provides a nice wrapper to the Markdown rendered as HTML by Pandoc. It includes the site navigation and project copyright information in the wrapping HTML. It is based on the default Pandoc page template with some added markup for navigation and copyright info in the footer. I also update the link to the CSS to conform with our general site branding requirements. You can generate a basic template using Pandoc.\n\n```shell\npandoc --print-default-template=html5\n```\n\nI also use Pandoc to generate an \"about.md\" file describing the project and author info.  The content of the about.md is taken directly from the project's codemeta.json file after I've renamed the \"@\" JSON-LD fields (those cause problems for Pandoc). You can see the preparation of a temporary \"_codemeta.json\" using `cat` and `sed` to rename the fields. This is I use a Pandoc template to render the Markdown from.\n\n```pandoc\n---\ntitle: $name$\n---\n\nAbout this software\n===================\n\n$name$ $version$\n----------------\n\n$if(author)$\n### Authors\n\n$for(author)$\n- $it.givenName$ $it.familyName$\n$endfor$\n$endif$\n\n$if(description)$\n$description$\n$endif$\n\n\n$if(license)$- License: $license$$endif$\n0$if(codeRepository)$- GitHub: $codeRepository$$endif$\n$if(issueTracker)$- Issues: $issueTracker$$endif$\n\n\n$if(programmingLanguage)$\n### Programming languages\n\n$for(programmingLanguage)$\n- $programmingLanguage$\n$endfor$\n$endif$\n\n$if(operatingSystem)$\n### Operating Systems\n\n$for(operatingSystem)$\n- $operatingSystem$\n$endfor$\n$endif$\n\n$if(softwareRequirements)$\n### Software Requiremets\n\n$for(softwareRequirements)$\n- $softwareRequirements$\n$endfor$\n$endif$\n\n$if(relatedLink)$\n### Related Links\n\n$for(relatedLink)$\n- [$it$]($it$)\n$endfor$\n$endif$\n```\n\nThis same technique can be repurposed to render a CITATION.cff if needed.\n\n## Pagefind\n\nPagefind provides three levels of functionality. First it will generate indexes for a full text search of your\nproject's HTML pages. It also builds the necessary search UI for your static site. I include the search UI via a\nMarkdown document that embeds the HTML markup described at [Pagefind.app](https://pagefind.app/docs/)'s Getting started\npage.  When I invoke Pagefind I use the `--bundle-dir` option to be \"pagefind\" rather than \"_pagefind\".  The reason is GitHub Pages ignores the \"_pagefind\" (probably ignores all directories with \"_\" prefix).\n\nIf you need a quick static web server while you're writing and developing your documentation website Pagefind can\nprovide that using the `--serve` option. Assuming you're in your project's directory then something like this should do the trick.\n\n```shell\n    pagefind --source . --bundle-dir=pagefind --serve\n```\n",
      "data": {
        "keywords": [
          "Pandoc",
          "Pagefind",
          "make",
          "static site"
        ],
        "pubDate": "2022-11-30",
        "title": "Pandoc, Pagefind and Make"
      },
      "url": "posts/2022/11/28/pandoc-pagefind-and-make.json"
    },
    {
      "content": "\n# Building A to Z lists pages in Pandoc\n\nBy R. S. Doiel, 2023-10-18\n\nPandoc offers a very good template system. It avoids elaborate features in favor of a few simple ways to bring content into the page.  It knows how to use data specified in “front matter” (a YAML header to a Markdown document) as well as how to merge in JSON or YAML from a metadata file.  One use case that is common in libraries and archives that less obvious of how to handle is building A to Z lists or year/date oriented listings where you have a set of navigation links at the top of the page followed by a set of H2 headers with UL lists between them.  In JSON the typical data presentation would look something like\n\n```json\n{\n  \"a_to_z\": [ \"A\", \"B\"],\n  \"content\": {\n    \"A\": [\n      \"After a beautiful day\",\n      \"Afterlife\"\n    ],\n    \"B\": [\n      \"Better day after\",\n      \"Better Life\"\n    ]\n  }\n}\n```\n\nThe trouble is that while YAML’s outer dictionary (key/value map) works fine in Pandoc templates there is no way for the the for loop to handle maps of maps like we have above.  Pandoc templates really want to iterate over arrays of objects . That’s nice thing! It gives us more ways to transform the data to provide more flexibility in our template implementation. Here’s how I would restructure the previous JSON to make it easy to process via Pandoc’s template engine.  Note how I’ve taken our simple array of letters and turned them into an object with an “href” and “label” attribute. Similarly I’ve enhanced the “content” objects.\n\n```json\n{\n  \"a_to_z\": [ {\"href\": \"A\", \"label\": \"A\"}, {\"href\": \"B\", \"label\": \"B\"} ],\n  \"content\": [\n      {\"letter\": \"A\", \"title\": \"After a beautiful day\", \"id\": \"after-a-beautiful-day\"},\n      {\"title\": \"Afterlife\", \"id\": \"afterlife\"},\n      {\"letter\": \"B\", \"title\": \"Better day after\", \"id\": \"better-day-after\"},\n      {\"title\": \"Better Life\", \"id\": \"better-life\"}\n  ]\n}\n```\n\nThen the template can be structure something like\n\n```\n<menu>\n${for(a_to_z)}\n${if(it.href)}<li><a href=\"${it.href}\">${it.label}</a></li>${endif}\n${endfor}\n</menu>\n\n${for(content)}\n${if(it.letter)}\n\n## <a id=\"${it.letter}\" name=\"${it.letter}\">${it.letter}</a>\n\n${endif}\n- [${it.name}](${it.id})\n${endfor}\n\n```\n\nThere is one gotcha in A to Z list generation. A YAML parser may convert a bare “N” to “false” (and presumable “Y” will become “true”). This is really annoying. The way to avoid this is to add a space to the letter in your JSON output. This will insure that the “N” or “Y” aren’t converted to the boolean values “true” and “false”. Pandoc’s template engine is smart enough to trim leading and trailing spaces.\n\nFinally this technique can be used to produce lists and navigation that are based around years, months, or other iterative types but that is left as an exercise to the reader.\n\n\n\n",
      "data": {
        "keywords": [
          "Pandoc",
          "templates"
        ],
        "pubDate": "2023-10-18",
        "title": "Building A to Z list pages in Pandoc"
      },
      "url": "posts/2023/10/18/A-to-Z-lists.json"
    },
    {
      "content": "\n# Quick recipe, compile Pandoc (M1)\n\nThese are my quick notes for compiling Pandoc on a M1 Mac Mini. I use a similar recipe for building Pandoc on Linux (NOTE: the challenges with libiconv and Mac Ports' libiconv below if you get a build error).\n\n1. Install [GHCup](https://www.haskell.org/ghcup/) to get a good Haskell setup (I accept all the default choices)\n    a. Use the curl example command to install it\n    b. Make sure the environment is active (e.g. source `$HOME/.ghcup/env`)\n2. Make sure GHCup is pointing at the \"recommended\" versions of GHC, Cabal, etc. (others may work but I prefer the stable releases)\n3. Clone <https://github.com/jgm/pandoc> to your local machine\n4. Check out the version you want to build (e.g. 3.1.4)\n5. Run the \"usual\" Haskell build sequence with cabal per Pandoc's installation documentation for building from source\n    a. `cabal clean`\n    b. `cabal update`\n    c. `cabal install pandoc-cli`\n\nHere's an example of the shell commands I run (I'm assuming you're installing GHCup for the first time).\n\n~~~\ncurl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh\nsource $HOME/.gchup/env\nghcup tui\nmkdir -p src/github.com/jgm/pandoc\ncd src/github.com/jgm/pandoc\ngit clone git@github.com:jgm/pandoc\ncd pandoc\ngit checkout 3.1.4\ncabal clean\ncabal update\ncabal install pandoc-cli\n~~~\n\nThis will install Pandoc in your `$HOME/.cabal/bin` directory. Make sure\nit is in your path (it should be if you've sourced the GHCup environment after you installed GHCup).\n\n## libiconv compile issues\n\nIf you use Mac Ports it can confuse Cabal/Haskell which one to link to. You'll get an error talking about undefined symbols and iconv.  To get a clean compile I've typically worked around this issue by removing the Mac Ports installed libiconv temporarily (e.g. `sudo port uninstall libiconv`, an using the \"all\" option when prompted).  After I've got a clean install of Pandoc then I re-install libiconv for those Ports based applications that need it. Putting libiconv back is important, as Mac Ports version of Git expects it.\n\n",
      "data": {
        "author": "R. S. Doiel",
        "keywords": [
          "Pandoc",
          "GHCup",
          "M1"
        ],
        "pubDate": "2023-07-05",
        "title": "Quick recipe, compiling Pandoc (M1)"
      },
      "url": "posts/2023/07/05/quick-recipe-compiling-Pandoc-M1.json"
    }
  ]
}