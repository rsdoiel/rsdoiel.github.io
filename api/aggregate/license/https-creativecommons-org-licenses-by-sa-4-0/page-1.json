{
  "page": 1,
  "total_pages": 1,
  "has_more": false,
  "next_page": null,
  "values": [
    {
      "content": "\n\nPandoc & Metadata \n=================\n\nPandoc supports three ways of providing metadata to its template\nengine. \n\n1. Front matter\n2. Command line optional metadata\n3. A JSON metadata file.\n\nFront matter\n------------\n\nFront matter is a community term that comes from physical world\nof paper books and articles.  It is the information that comes \nbefore the primary content.  This information might be things \nlike title, author, publisher and publication date. These days \nit'll also include things like identifiers like ISSN, ISBN possibly \nnewer identifiers like DOI or ORCID. In the library and programming\ncommunity we refer to this type of structured information as\nmetadata.  Data about the publication or article.\n\nMany publication systems like TeX/LaTeX support provided means of \nincorporating metadata into the document.  When simple markup formats \nlike Markdown, Textile and Asciidoc became popular the practice was \ncontinued by including the metadata in some sort of structured encoding\nat the beginning of the document. The community adopted the term from\nthe print world, \"front matter\". \n\nPandoc provides for several ways of working with metadata and supports\none format of front matter encoding called [YAML](https://yaml.org/). \nOther markup processors support other encoding of front matter. Two\npopular alternatives of encoding are [TOML](https://toml.io/en/) and \n[JSON](https://json.org).  If you use one of the alternative encoding\nfor your front matter then you'll need to split the front matter\nout of your document before processing with Pandoc[^1].  \n\n[^1]: The [MkPage Project](https://caltechlibrary.github.io/mkpage/) provides a tool called [frontmatter](https://caltechlibrary.github.io/mkpage/docs/frontmatter/) that can be easy or your can easily roll your own in Python or other favorite language.\n\n\nIf you provide YAML formatted front matter Pandoc will pass this\nmetadata on and make it available to it's template engine and the\ntemplates you create to render content with Pandoc. See the Pandoc\nUser Guide section [YAML metadata blocks](https://pandoc.org/MANUAL.html#extension-yaml_metadata_block) for more details. If you've used another\nencoding of front matter then the metadata file approach is probably\nthe ticket.\n\nMetadata passed by command line\n-------------------------------\n\nIf you only have a metadata elements you would like to\nmake available to the template (e.g. title, pub date) you\ncan easily add them using the `--metadata` command line option.\nThis is documented in the Pandoc User Guide under the heading\n[Reader Options](https://pandoc.org/MANUAL.html). Here's a simple\nexample where we have a title, \"U. S. Constitution\" and a\npublication date of \"September 28, 1787\".\n\n~~~{.shell}\n    pandoc --metadata \\\n        title=\"U. S. Constitution\" \\\n        pubdate=\"September 28, 1787\" \\\n        --from markdown --to html --template doc1.tmpl \\\n        constitution.txt\n~~~\n\nThe template now has two additional values available as metadata\nin addition to `body`, namely `pubdate` and `title`. Here's an\nexample template [doc1.tmpl](doc1.tmpl).\n\n~~~\n\n   <!DOCTYPE html>\n   <html>\n   <head>\n       <title>${title}</title>\n   </head>\n   <body>\n      <h1>${title}</h1>\n      <h2>${pubdate}</h2>\n      <p>\n      ${body}\n      <p>\n   </body>\n   </html>\n\n~~~\n\nMore complex metadata is better suited to creating a JSON document\nwith the structure you need to render your template.\n\n\nMetadata file\n-------------\n\nMetadata files can be included with the option `--metadata-file`. This\nlike the `--metadata` option are discussed in the Pandoc User Guide under\nthe [Read Options(https://pandoc.org/MANUAL.html) heading.  The JSON \ndocument should contain an Object where each attribute corresponds to\nthe variable you wish to referenced in template.  Pandoc's template\nengine support both single values but also objects and arrays. In this\nway you can structure the elements you wish to include even elements\nwhich are iterative (e.g. a list of links or topics). Below is a\nJSON data structure that includes the page title as well as links\nfor the navigation.  The nav attribute holds a list of objects \nwith attributes of href and label containing data that will be used\nto render a list of anchor elements in the template.\n\n\n~~~{.json}\n\n    {\n        \"title\": \"U. S. Constitution\",\n        \"pubdate\": \"September 28, 1787\",\n        \"nav\": [\n            {\"label\": \"Pandoc Metadata\", \"href\": \"Pandoc-Metadata.html\" },\n            {\"label\": \"Magnacarta\", \"href\": \"magnacarta.html\" },\n            {\"label\": \"Declaration of Independence\", \"href\": \"independence.html\" },\n            {\"label\": \"U. S. Constitution\", \"href\": \"constitution.html\"}\n        ]\n    }\n\n~~~\n\nHere's a revised template to include the navigation,\nsee [doc2.tmpl](doc2.tmpl).\n\n~~~\n\n   <!DOCTYPE html>\n   <html>\n   <head>\n       <title>${title}</title>\n   </head>\n   <body>\n      <nav>\n      ${for(nav)}<a href=\"${nav.href}\">${nav.label}</a>${sep}, ${endfor}\n      </nav>\n      <h1>${title}</h1>\n      ${if(pubdate)}<h2>${pubdate}</h2>${endif}\n      <p>\n      ${body}\n      <p>\n   </body>\n   </html>\n\n~~~\n\n\nCombining Techniques\n--------------------\n\nIt is worth noting that these approaches can be mixed and matched.\nIn the following example I use the same [metadata.json](metadata.json)\nfile which has title and pubdate attributes but override them\nusing the command line `--metadata` option. In this way I can use that \nfile along with [doc2.tmpl](doc2.tmpl) and render each \nTo render the constitution page from a Markdown version of the \nU. S. Constitution you could use the following Pandoc command:\n\n~~~{.shell}\n\n\tpandoc --from markdown --to html --template doc2.tmpl \\\n        --metadata-file metadata.json \\\n        --metadata title=\"Magna Carta\" \\\n\t\t--metadata pubdate=\"1215\" \\\n\t\t-o magnacarta.html \\\n\t\tmagnacarta.txt\n\n\tpandoc --from markdown --to html --template doc2.tmpl \\\n        --metadata-file metadata.json \\\n        --metadata title=\"The Declaration of Indepenence\" \\\n\t\t--metadata pubdate=\"July 4, 1776\" \\\n        -o independence.html \\\n        independence.txt\n\n\tpandoc --from markdown --to html --template doc2.tmpl \\\n        --metadata-file metadata.json \\\n        --metadata title=\"U. S. Constitution\" \\\n\t\t--metadata pubdate=\"September 28, 1787\" \\\n        -o constitution.html \\\n        constitution.txt\n\n~~~\n\nSee [Magna Carta](magnacarta.html), [The Declaration of Independence](independence.html), [U. S. Constitution](constitution.html)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "keywords": [
          "Pandoc",
          "Metadata",
          "Templates"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 2,
        "series": "Pandoc Techniques",
        "title": "Pandoc & Metadata"
      },
      "url": "posts/2020/11/11/Pandoc-Metadata.json"
    },
    {
      "content": "\n\nPandoc Partial Templates\n========================\n\nMost people know about [Pandoc](https://pandoc.org/) from its\nfantastic ability to convert various markup formats from one to\nanother. A little less obvious is Pandoc can be a template engine\nfor rendering static websites allowing you full control over the\nrendered content.\n\nThe main Pandoc documentation of the template engine can be found\nin the [User Guide](https://pandoc.org/MANUAL.html#templates).\nThe documentation is complete in terms of describing the template\ncapabilities but lacks a tutorial for using as a replacement for more\nambitious rendering systems like [Jekyll](https://jekyllrb.com/) or\n[Hugo](https://gohugo.io/). Pandoc takes a vary direct approach and\ncan be deceptively simple to implement.\n\nUse your own template\n---------------------\n\nFirst thing in this tutorial is to use our own template with Pandoc\nwhen rendering a single webpage. You use the `–-template` option to\nprovide your a template name. I think of this as the page level template.\nThis template, as I will show later, can then call other partial\ntemplates as needed.\n\nExample, render the [Pandoc-Partials.txt](Pandoc-Partials.txt) file using the\ntemplate named [index1.tmpl](index1.tmpl):\n\n~~~{.shell}\n\n    pandoc --from=markdown --to=html \\\n        --template=index1.tmpl Pandoc-Partials.txt > index1.htm\n\n~~~\n\nThis is a simple template page level template.\n\n~~~{.html-code}\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n    </head>\n    <body>\n    ${body}\n    </body>\n    </html>\n\n~~~\n\nWhen we run our Pandoc command the file called\n[Pandoc-Partials.txt](Pandoc-Partials.txt) is passed into the template as\nthe \"body\" element where it says `${body}`. See this Pandoc \n[User Guide](https://pandoc.org/MANUAL.html#templates) for the basics.\n\nExample 1 rendered: [index1.htm](index1.htm)\n\nVariables and metadata\n----------------------\n\nPandoc's documentation is good at describing the\nways of referencing a variable or using the built-in\ntemplate functions. Where do the variables get their values?\nThe easiest way I've found is to set the variables values in\na JSON metadata file.  While Pandoc can also use the metadata\ndescribed in YAML front matter Pandoc doesn't support some of the\nother common front matter formats.  If you're using another format\nlike JSON or TOML for front matter there are tools which can split\nthe front matter from the rest of the markdown document. For\nthis example I have created the metadata as JSON in a file\ncalled [metadata.json](metadata.json).\n\nExample [metadata.json](metadata.json):\n\n~~~{.json}\n\n    {\n        \"title\": \"Pandoc Partial Examples\",\n        \"nav\": [\n            {\"label\": \"Pandoc-Partials\", \"href\": \"Pandoc-Partials.html\" },\n            {\"label\": \"Version 1\", \"href\": \"index1.htm\" },\n            {\"label\": \"Version 2\", \"href\": \"index2.htm\" },\n            {\"label\": \"Version 3\", \"href\": \"index3.htm\" }\n        ]\n    }\n\n~~~\n\nLet's modify our initial template to include our simple navigation\nand title.\n\nExample [index2.tmpl](index2.tmpl):\n\n~~~{.html-code}\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n      ${if(title)}<title>${title}</title>${endif}\n    </head>\n    <body>\n    <nav>\n    ${for(nav)}<a href=\"${it.href}\">${it.label}</a>${sep}, ${endfor}\n    </nav>\n    <section>\n    ${body}\n    </section>\n    </body>\n    </html>\n\n~~~\n\nWe would include our navigation metadata with a Pandoc command like\n\n~~~{.shell}\n\n    pandoc --from=markdown --to=html \\\n           --template=index2.tmpl \\\n           --metadata-file=metadata.json Pandoc-Partials.txt > index2.htm\n\n~~~\n\nWhen we render this we now should be able to view a web page\nwith simple navigation driven by the JSON file as well as the\nbody content contained in the Pandoc-Partials.txt file.\n\nExample 2 rendered: [index2.htm](index2.htm)\n\nPartials\n--------\n\nSometimes you have more complex documents. Putting this all in\none template can become tedious. Web designers use a term called\n\"partials\". This usually means a template for a \"part\" of a page.\nIn our initial example we can split our navigation into it's own\ntemplate.\n\nImplementing partials\n---------------------\n\nPandoc will look in the current directory for partials as well\nas in a sub directory called \"templates\" of the current direct.\nIn this example I am going to include my partial template for\nnavigation in the current directory along side my\n[index3.tmpl](index3.tmpl).  My navigation template is called\n[nav.tmpl](nav.tmpl).\n\nHere's my partial template:\n\n~~~{.html-code}\n\n    <nav>\n    ${for(nav)}<a href=\"${it.href}\">${it.label}</a>${sep}, ${endfor}\n    </nav>\n\n~~~\n\nHere's my third iteration of our index template, [index3.tmpl](index3.tmpl).\n\n~~~{.html-code}\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n    ${if(title)}<title>${title}</title>${endif}\n    </head>\n    <body>\n    ${if(nav)}\n    ${nav.tmpl()}\n    ${endif}\n    <section>\n    ${body}\n    </section>\n    </body>\n    </html>\n\n~~~\n\nPandoc only requires you to reference the partial by using\nits base name. Many people will name their templates with the\nextension \".html\". I find this problematic as if you're trying\nto list the templates in the directory you can not easily list\nthem separately. I use the \".tmpl\" extension to identify my templates.\nSince I have other documents that share the base name \"nav\" I\nexplicit call my navigation partial using the full filename followed\nby the open and closed parenthesis. I have also chosen to wrap\nthe template in an \"if\" condition. That way if I don't want navigation\non a page I skip defining it in my metadata file.\n\nInside the partial template we inherit the parent metadata object.\nYou can use all the built-in Pandoc template functions and variables\nprovided by Pandoc in your partial templates.\n\nPutting it all together:\n\n~~~{.shell}\n\n    pandoc --from=markdown --to=html \\\n           --template=index3.tmpl \\\n           --metadata-file=metadata.json Pandoc-Partials.txt > index3.htm\n\n~~~\n\nExample 3 rendered: [index3.htm](index3.htm)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "keywords": [
          "Pandoc",
          "Templates"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 1,
        "series": "Pandoc Techniques",
        "title": "Pandoc Partials"
      },
      "url": "posts/2020/11/09/Pandoc-Partials.json"
    },
    {
      "content": "\n\nSoftware Tools, Filters\n=======================\n\nOverview\n--------\n\nThis post is the second in a series revisiting the programs\ndescribed in the 1981 book by Brian W. Kernighan and P. J.\nPlauger's called [Software Tools in Pascal](https://archive.org/details/softwaretoolsinp00kern). The book is available from the\n[Open Library](https://openlibrary.org/) and physical copies\nare still (2020) commonly available from used book sellers.\nThe book was an late 20th century text on creating portable\ncommand line programs using ISO standard Pascal of the era.\n\nIn this chapter K & P focuses on developing the idea of filters.\nFilters are programs which typically process standard input, do\nsome sort of transformation or calculation and write to standard\noutput.  They are intended to work either standalone or in a pipeline\nto solve more complex problems. I like to think of filters as\nsoftware [LEGO](https://en.wikipedia.org/wiki/Lego).\nFilter programs can be \"snapped\" together creating simple shapes\ndata shapes or combined to for complex compositions.\n\nThe programs from this chapter include:\n\n+ **entab**, respecting tabstops, convert strings of spaces to tabs\n+ **overstrike**, this is probably not useful anymore, it would allow \"overstriking\" characters on devices that supported it. From [wikipedia](https://en.wikipedia.org/wiki/Overstrike), \"In typography, overstrike is a method of printing characters that are missing from the printer's character set. The character was created by placing one character on another one — for example, overstriking \"L\" with \"-\" resulted in printing a \"Ł\" (L with stroke) character.\"\n+ **compress**, an early UNIX style compress for plain text files\n+ **expand**, an early UNIX style expand for plain text files, previously run through with **compress**\n+ **echo**, write echo's command line parameters to standard output, introduces working with command line parameters\n+ **translit**, transliterate characters using a simple from/to substitution with a simple notation to describe character sequences and negation. My implementation diverges from K & P\n\nImplementing in Oberon-07\n------------------------\n\nWith the exception of **echo** (used to introduce command line parameter processing) each program increases in complexity.  The last program **translit**is the most complex in this chapter.  It introducing what we a \"domain specific language\" or \"DSL\".  A DSL is a notation allowing us to describe something implicitly rather than explicitly. All the programs except **translit** follow closely the original Pascal translated to Oberon-07.  **translit** book implementation is very much a result of the constraints of Pascal of the early 1980s as well as the minimalist assumption that could be made about the host operating system. I will focus on revising that program in particular bring the code up to current practice as well as offering insights I've learned.\n\n\nThe program **translit** introduces what is called a \"Domain Specific Language\".Domain specific languages or DSL for short are often simple notations to describe how to solve vary narrow problems.  If you've used any of the popular spreadsheet programs where you've entered a formula to compute something you've used a domain specific language.  If you've ever search for text in a document using a regular expression you've used a domain specific language.  By focusing a notation on a small problem space you can often come up with simple ways of expressing or composing programmatic solutions to get a job done.\n\nIn **translit** the notation let's us describe what we want to translate. At the simplest level the **translit** program takes a character and replaces it with another character. What make increases **translit** utility is that it can take a set of characters and replace it with another.  If you want to change all lower cases letters and replace them with uppercase letters. This \"from set\" and \"to set\" are easy to describe as two ranges, \"a\" to \"z\" and \"A\" to \"Z\".  Our domain notation allows us to express this as \"a-z\" and \"A-Z\".  K & P include several of features in there notation including characters to exclude from a translation as well as an \"escape notation\" for describing characters like new lines, tabs, or the characters that describe a range and exclusion (i.e. dash and caret).\n\n\n\n2.1 Putting Tabs Back\n=====================\n\n[Page 31](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/31/mode/1up)\n\nImplementing **entab** in Oberon-07 is straight forward.\nLike my [Detab](Detab.Mod) implementation I am using\na second modules called [Tabs](Tabs.Mod). This removes\nthe need for the `#include` macros used in the K & P version.\nI have used the same loop structure as K & P this time.\nThere is a difference in my `WHILE` loop. I separate the\ncharacter read from the `WHILE` conditional test.  Combining the\ntwo is common in \"C\" and is consistent with the programming style\nother books by Kernighan.  In Oberon-07 doesn't make sense at all.\nOberon's `In.Char()` is not a function returning as in the Pascal\nprimitives implemented for the K & P book or indeed like in the \"C\"\nlanguage. In Oberon's \"In\" module the status of a read operation is\nexposed by `In.Done`. I've chosen to put the next call to\n`In.Char()` at the bottom of my `WHILE` loop because it is clear\nthat it is the last think done before ether iterating again or\nexiting the loop. Other than that the Oberon version looks much\nlike K & P's Pascal.\n\n\nProgram Documentation\n---------------------\n\n[Page 32](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/32/mode/1up)\n\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n  entab\tconvert runs of blanks into tabs\n\nUSAGE\n\n  entab\n\nFUNCTION\n\n  entab copies its input to its output, replacing strings of\n  blanks by tabs so the output is visually the same as the\n  input, but contains fewer characters. Tab stops are assumed\n  to be set every four columns (i.e. 1, 5, 9, ...), so that\n  each sequence of one to four blanks ending on a tab stop\n  is replaced by a tab character\n\nEXAMPLE\n\n  Using -> as visible tab:\n\n    entab\n      col  1   2   34  rest\n    ->col->1->2->34->rest\n\nBUGS\n\n  entab is naive about backspaces, virtical motions, and\n  non-printing characters. entab will convert  a single blank\n  to a tab if it occurs at a tab stop. The entab is not an\n  exact inverse of detab.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSource code for **Entab.Mod**\n-----------------------------\n\n~~~\n\nMODULE Entab;\n  IMPORT In, Out, Tabs;\n\nCONST\n  NEWLINE = 10;\n  TAB = 9;\n  BLANK = 32;\n\nPROCEDURE Entab();\nVAR\n  c : CHAR;\n  col, newcol : INTEGER;\n  tabstops : Tabs.TabType;\nBEGIN\n  Tabs.SetTabs(tabstops);\n  col := 1;\n  REPEAT\n    newcol := col;\n    In.Char(c);\n    IF In.Done THEN (* NOTE: We check that the read was successful! *)\n      WHILE (ORD(c) = BLANK) DO\n        newcol := newcol + 1;\n        IF (Tabs.TabPos(newcol, tabstops)) THEN\n          Out.Char(CHR(TAB));\n          col := newcol;\n        END;\n        (* NOTE: Get the next char, check the loop condition\n           and either iterate or exit the loop *)\n        In.Char(c);\n      END;\n      WHILE (col < newcol) DO\n        Out.Char(CHR(BLANK)); (* output left over blanks *)\n        col := col + 1;\n      END;\n      (* NOTE: Since we may have gotten a new char in the first WHILE\n         we need to check again if the read was successful *)\n      IF In.Done THEN\n        Out.Char(c);\n        IF (ORD(c) = NEWLINE) THEN\n          col := 1;\n        ELSE\n          col := col + 1;\n        END;\n      END;\n    END;\n  UNTIL In.Done # TRUE;\nEND Entab;\n\nBEGIN\n  Entab();\nEND Entab.\n\n~~~\n\n\n\n2.2 Overstrikes\n===============\n\n\n[Page 34](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/34/mode/1up)\n\n\nOverstrike isn't a tool that is useful today but I've included it\nsimply to be follow along the flow of the K & P book. It very much\nreflects an error where teletype like devices where still common and\nprinters printed much like typewriters did. On a 20th century\nmanual type writer you could underline a word or letter by backing\nup the carriage then typing the underscore character. Striking out\na word was accomplished by a similar technique. The mid to late\n20th century computers device retained this mechanism though by\n1980's it was beginning to disappear along with manual typewriters.\nThis program relies on the the nature of ASCII character set and\nreflects some of the non-print character's functionality. I\nfound it did not work on today's terminal emulators reliably. Your\nmileage may very nor do I have a vintage printer to test it on.\n\nOur module follows K & P design almost verbatim. The differences\nare those suggested by differences between Pascal and Oberon-07.\nLike in previous examples we don't need to use an ENDFILE constant\nas we can simply check the value of `In.Done` to determine\nif the last read was successful. This simplifies some of\nthe `IF/ELSE` logic and the termination of the `REPEAT/UNTIL`\nloop.  It makes the `WHILE/DO` loop a little more verbose.\n\nOne thing I would like to point out in the original Pascal of the\nbook is a problem often referred to as the \"dangling else\" problem.\nWhile this is usually discussed in the context of compiler\nimplementation I feel like it is a bigger issue for the person\nreading the source code. It is particularly problematic when you\nhave complex \"IF/ELSE\" sequences that are nested.  This is not\nlimited to the 1980's era Pascal. You see it in other languages\nlike C.  It is a convenience for the person typing the source code\nbut a problem for those who maintain it. We see this ambiguity in\nthe Pascal procedure **overstrike** inside the repeat loop\non [page 35](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/35/mode/1up).\nIt is made worse by the fact that K & P have taken advantage of\nomitting the semi-colons where optional. If you type in this\nprocedure and remove the indication if quickly becomes ambiguous\nabout where on \"IF/ELSE\" begins and the next ends. In Oberon-07 it\nis clear when you have a dangling \"IF\" statement. This vintage\nPascal, not so much.\n\nK & P do mention the dangling \"ELSE\" problem later in the text.\nTheir recommend practice was include the explicit final \"ELSE\"\nat a comment to avoid confusion. But you can see how easy an\nomitting the comment is in the **overstrike** program.\n\nLimitations\n-----------\n\nThis is documented \"BUG\" section describes the limitations\nwell, \"**overstrike** is naive about vertical motions and non-\nprinting characters. It produces one over struck line for each\nsequence of backspaces\". But in addition to that most printing\ndevices these days either have their own drivers or expect to work\nwith a standard like Postscript. This limited the usefulness of\nthis program today though controlling character movement in a\n\"vt100\" emulation using old fashion ASCII control codes is\nstill interesting if only for historical reasons.\n\n\nProgram Documentation\n---------------------\n\n[Page 36](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/36/mode/1up)\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n  overstrike    replace overstrikes by multiple-lines\n\nUSAGE\n\n  overstrike\n\nFUNCTION\n\n  overstrike copies in input to its output, replacing lines\n  containing backspaces by multiple lines that overstrike\n  to print the same as input, but containing no backspaces.\n  It is assumed that the output is to be printed on a device\n  that takes the first character of each line as a carriage\n  control; a blank carriage control causes normal space before\n  print, while a plus sign '+' suppresses space before print\n  and hence causes the remainder of the line to overstrike\n  the previous line.\n\nEXAMPLE\n\n  Using <- as a visible backspace:\n\n    overstrike\n    abc<-<-<-___\n     abc\n    +___\n\nBUGS\n\n  overstrike is naive about vertical motions and non-printing\n  characters. It produces one over struck line for each sequence\n  of backspaces.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nSource code for **Overstrike.Mod**\n----------------------------------\n\n~~~\n\nMODULE Overstrike;\nIMPORT In, Out;\n\nCONST\n  NEWLINE = 10;\n  BLANK = 32;\n  PLUS = 43;\n  BACKSPACE = 8;\n\nPROCEDURE Max(x, y : INTEGER) : INTEGER;\nVAR max : INTEGER;\nBEGIN\n  IF (x > y) THEN\n    max := x\n  ELSE\n    max := y\n  END;\n  RETURN max\nEND Max;\n\nPROCEDURE Overstrike;\nCONST\n  SKIP = BLANK;\n  NOSKIP = PLUS;\nVAR\n  c : CHAR;\n  col, newcol, i : INTEGER;\nBEGIN\n  col := 1;\n  REPEAT\n    newcol := col;\n    In.Char(c);\n    (* NOTE We check In.Done on each loop evalution *)\n    WHILE (In.Done = TRUE) & (ORD(c) = BACKSPACE) DO (* eat the backspaces *)\n      newcol := Max(newcol, 1);\n      In.Char(c);\n    END;\n    (* NOTE: We check In.Done again, since we may have\n       additional reads when eating the backspaces. If\n       the previous while loop has taken us to the end of file.\n       this will be also mean In.Done = FALSE. *)\n    IF In.Done THEN\n      IF (newcol < col) THEN\n        Out.Char(CHR(NEWLINE)); (* start overstrike line *)\n        Out.Char(CHR(NOSKIP));\n        FOR i := 0 TO newcol DO\n          Out.Char(CHR(BLANK));\n        END;\n        col := newcol;\n      ELSIF (col = 1) THEN (* NOTE: In.Done already check for end of file *)\n        Out.Char(CHR(SKIP)); (* normal line *)\n      END;\n      (* NOTE: In.Done already was checked so we are in mid line *)\n      Out.Char(c);    (* normal character *)\n      IF (ORD(c) = NEWLINE) THEN\n        col := 1\n      ELSE\n        col := col + 1\n      END;\n    END;\n  UNTIL In.Done # TRUE;\nEND Overstrike;\n\nBEGIN\n  Overstrike();\nEND Overstrike.\n\n~~~\n\n\n2.3 Text Compression\n====================\n\n[Page 37](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/37/mode/1up)\n\nIn 20th century computing everything is expensive, memory,\npersistent storage computational ability in CPU.  If you were\nprimarily working with text you still worried about running out of\nspace in your storage medium. You see it in the units\nof measurement used in that era such as bytes, kilobytes, hertz and\nkilohertz. To day we talk about megabytes, gigabytes, terabytes and\npetabytes. Plain text files are a tiny size compared to must\ndigital objects today but in the late 20th century\ntheir size in storage was still a concern.  One way to solve this\nproblem was to encode your plain text to use less storage space.\nEarly attempts at file compression took advantage of repetition to\nsave space. Many text documents have repeated characters\nwhether spaces or punctuation or other formatting. This is what\ninspired the K & P implementation of **compress** and **expand**.\nToday we'd use other approaches to save space whether we were\nstoring text or a digital photograph.\n\n\nProgram Documentation\n---------------------\n\n[Page ](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/40/mode/1up)\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n    compress    compress input by encoding repeated characters\n\nUSAGE\n\n    compress\n\nFUNCTION\n\n    compress copies its input to its output, replacing strings\n    of four or more identical characters by a code sequence so\n    that the output generally contains fewer characters than the\n    input. A run of x's is encoded as -nx, where the count n is\n    a character: 'A' calls for a repetition of one x, 'B' a\n    repetition of two x's, and so on. Runs longer than 26 are\n    broken into several shorter ones. Runs of -'s of any length\n    are encoded.\n\nEXAMPLE\n\n    compress\n    Item     Name           Value\n    Item-D Name-I Value\n    1       car             -$7,000.00\n    1-G car-J -A-$7,000.00\n    <ENDFILE>\n\nBUGS\n\n    The implementation assumes 26 legal characters beginning with A.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nSource code for **Compress.Mod**\n--------------------------------\n\n~~~\n\nMODULE Compress;\nIMPORT In, Out;\n\nCONST\n    TILDE = \"~\";\n    WARNING = TILDE;    (* ~ *)\n\n(* Min -- compute minimum of two integers *)\nPROCEDURE Min(x, y : INTEGER) : INTEGER;\nVAR min : INTEGER;\nBEGIN\n    IF (x < y) THEN\n        min := x\n    ELSE\n        min := y\n    END;\n    RETURN min\nEND Min;\n\n(* PutRep -- put out representation of run of n 'c's *)\nPROCEDURE PutRep (n : INTEGER; c : CHAR);\nCONST\n    MAXREP = 26;    (* assuming 'A' .. 'Z' *)\n    THRESH = 4;\nVAR i : INTEGER;\nBEGIN\n    WHILE (n >= THRESH) OR ((c = WARNING) & (n > 0)) DO\n        Out.Char(WARNING);\n        Out.Char(CHR((Min(n, MAXREP) - 1) + ORD(\"A\")));\n        Out.Char(c);\n        n := n - MAXREP;\n    END;\n    FOR i := n TO 1 BY (-1) DO\n        Out.Char(c);\n    END;\nEND PutRep;\n\n(* Compress -- compress standard input *)\nPROCEDURE Compress();\nVAR\n    c, lastc : CHAR;\n    n : INTEGER;\nBEGIN\n    n := 1;\n    In.Char(lastc);\n    WHILE (In.Done = TRUE) DO\n        In.Char(c);\n        IF (In.Done = FALSE) THEN\n            IF (n > 1) OR (lastc = WARNING) THEN\n                PutRep(n, lastc)\n            ELSE\n                Out.Char(lastc);\n            END;\n        ELSIF (c = lastc) THEN\n            n := n + 1\n        ELSIF (n > 1) OR (lastc = WARNING) THEN\n            PutRep(n, lastc);\n            n := 1\n        ELSE\n            Out.Char(lastc);\n        END;\n        lastc := c;\n    END;\nEND Compress;\n\n\nBEGIN\n    Compress();\nEND Compress.\n\n~~~\n\n\n\n2.4 Text Expansion\n==================\n\n[Page 41](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/41/mode/1up)\n\nOur procedures map closely to the original Pascal with a few\nsignificant differences.  As previously I've chosen a\n`REPEAT ... UNTIL` loop structure because we are always attempting\nto read at least once. The `IF THEN ELSIF ELSE` logic is a little\ndifferent. In the K & P version they combine retrieving\na character and testing its value.  This is a style common in\nlanguages like C. As previous mentioned I split the read of the\ncharacter from the test.  Aside from the choices imposed by the\n\"In\" module I also feel that retrieving the value, then testing is\na simpler statement to read. There is little need to worry about a\nside effect when you separate the action from the test. It does\nchange the structure of the inner and outer `IF` statements.\n\n\n\nProgram Documentation\n---------------------\n\n[Page 43](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/43/mode/1up)\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n    expand  expand compressed input\n\nUSAGE\n\n    expand\n\nFUNCTION\n\n    expand copies its input, which has presumably been encoded by\n    compress, to its output, replacing code sequences -nc by the\n    repeated characters they stand for so that the text output\n    exactly matches that which was originally encoded. The\n    occurrence of the warning character - in the input means that\n    which was originally encoded. The occurrence of the warning\n    character - in the input means that the next character is a\n    repetition count; 'A' calls for one instance of the following\n    character, 'B' calls for two, and so on up to 'Z'.\n\nEXAMPLE\n\n    expand\n    Item~D Name~I Value\n    Item    Name        Value\n    1~G car~J ~A~$7,000.00\n    1       car         -$7,000.00\n    <ENDFILE>\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nSource code for **Expand.Mod**\n------------------------------\n\n~~~\nMODULE Expand;\nIMPORT In, Out;\n\nCONST\n    TILDE = \"~\";\n    WARNING = TILDE;    (* ~ *)\n    LetterA = ORD(\"A\");\n    LetterZ = ORD(\"Z\");\n\n(* IsUpper -- true if c is upper case letter *)\nPROCEDURE IsUpper (c : CHAR) : BOOLEAN;\nVAR res : BOOLEAN;\nBEGIN\n    IF (ORD(c) >= LetterA) & (ORD(c) <= LetterZ) THEN\n        res := TRUE;\n    ELSE\n        res := FALSE;\n    END\n    RETURN res\nEND IsUpper;\n\n(* Expand -- uncompress standard input *)\nPROCEDURE Expand();\nVAR\n    c : CHAR;\n    n, i : INTEGER;\nBEGIN\n    REPEAT\n        In.Char(c);\n        IF (c # WARNING) THEN\n            Out.Char(c);\n        ELSE\n            In.Char(c);\n            IF IsUpper(c) THEN\n                n := (ORD(c) - ORD(\"A\")) + 1;\n                In.Char(c);\n                IF (In.Done) THEN\n                    FOR i := n TO 1 BY -1 DO\n                        Out.Char(c);\n                    END;\n                ELSE\n                    Out.Char(WARNING);\n                    Out.Char(CHR((n - 1) + ORD(\"A\")));\n                END;\n            ELSE\n                Out.Char(WARNING);\n                IF In.Done THEN\n                    Out.Char(c);\n                END;\n            END;\n        END;\n    UNTIL In.Done # TRUE;\nEND Expand;\n\nBEGIN\n    Expand();\nEND Expand.\n\n~~~\n\n\n2.5 Command Arguments\n=====================\n\n[Page 44](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/44/mode/1up)\n\n\nProgram Documentation\n---------------------\n\n[Page 45](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/45/mode/1up)\n\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n    echo    echo arguments to standard output\n\nUSAGE\n\n    echo [ argument ... ]\n\nFUNCTION\n\n    echo copies its command line arguments to its output as a line\n    of text with one space\n    between each argument. IF there are no arguments, no output is\n    produced.\n\nEXAMPLE\n\n    To see if your system is alive:\n\n        echo hello world!\n        hello world!\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nSource code for **Echo.Mod**\n----------------------------\n\n~~~\n\nMODULE Echo;\nIMPORT Out, Args := extArgs;\n\nCONST\n    MAXSTR = 1024; (* or whatever *)\n    BLANK = \" \";\n\n(* Echo -- echo command line arguments to output *)\nPROCEDURE Echo();\nVAR\n    i, res : INTEGER;\n    argstr : ARRAY MAXSTR OF CHAR;\nBEGIN\n    i := 0;\n    FOR i := 0 TO (Args.count - 1) DO\n        Args.Get(i, argstr, res);\n        IF (i > 0) THEN\n            Out.Char(BLANK);\n        END;\n        Out.String(argstr);\n    END;\n    IF Args.count > 0 THEN\n        Out.Ln();\n    END;\nEND Echo;\n\nBEGIN\n    Echo();\nEND Echo.\n\n~~~\n\n\n2.6 Character Transliteration\n=============================\n\n[Page 47](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/47/mode/1up)\n\n\n**translit** is the most complicated program so far in the book.\nMost of the translation process from Pascal to Oberon-07 has\nremained similar to the previous examples.\n\nMy implementation of **translit** diverges from the K & P\nimplementation at several points. Much of this is a result of\nOberon evolution beyond Pascal. First Oberon counts arrays from\nzero instead of one so I have opted to use -1 as a value to\nindicate the index of a character in a string was not found.\nEqually I have simplified the logic in `xindex()` to make it clear\nhow I am handling the index lookup described in `index()` of the\nPascal implementation. K & P implemented `makeset()` and `dodash()`.\n`dodash()` particularly looked troublesome. If you came across the\nfunction name `dodash()` without seeing the code comments\n\"doing a dash\" seems a little obscure.  I have chosen to name\nthat process \"Expand Sequence\" for clarity. I have simplified the\ntask of making sets of characters for translation into three cases\nby splitting the test conditions from the actions. First check to\nsee if we have an escape sequence and if so handle it. Second check\nto see if we have an expansion sequence and if so handle it else\nappend the char found to the end of the set being assembled. This\nresulted in `dodash()` being replaced by `IsSequence()` and\n`ExpandSequence()`.  Likewise `esc()` was replaced with `IsEscape()`\nand `ExpandEscape()`. I renamed `addchar()` to `AppendChar()`\nin the \"Chars\" module as that seemed more specific and clearer.\n\nI choose to advance the value used when expanding a set description\nin the loop inside of my `MakeSet()`. I minimized the side effects\nof the expand functions to the target destination.  It is clearer\nwhile in the `MakeSet()` loop to see the relationship of the test\nand transformation and how to advance through the string. This also\nallowed me to use fewer parameters to procedures which tends to\nmake things more readable as well as simpler.\n\nI have included an additional procedure not included in the K & P\nPascal of this program. `Error()` displays a string and halts.\nK & P provide this as part of their Pascal environment. I have\nchosen to embed it here because it is short and trivial.\n\nTranslit suggested the \"Chars\" module because of the repetition in\nprevious programs. In K & P the approach to code reuse is to create\na separate source file and to included via a pre-processor. In\nOberon we have the module concept.\n\nMy [Chars](Chars.Mod) module provides a useful set of test\nprocedures like `IsAlpha(c)`, `IsUpper(c)`, `IsLower()` in addition\nto the `CharInRange()` and `IsAlphaNum()`.  It also includes\n`AppendChar()` which can be used to append a single character value\nto an end of an array of char.\n\n\nProgram Documentation\n---------------------\n\n[Page 56](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/56/mode/1up)\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n    translit    transliterate characters\n\nUSAGE\n\n    translit    [^]src [dest]\n\nFUNCTION\n\n    translit maps its input, on a character by character basis, and\n    writes the translated version to its output.In the simplest case,\n    each character is the argument src is translated to the\n    corresponding character is the argument dest; all other characters\n    are copies as is. Both the src and dest may contain substrings of\n    the form c1 - c2 as shorthand for all the characters in the range\n    c1..c2 and c2 must both be digits, or both be letter of the same\n    case. If dest is absent, all characters represented by src are\n    deleted. Otherwise, if dest is shorter than src, all characters\n    is src that would map to or beyond the last character in\n    dest are mapped to the last character in dest; moreover adjacent\n    instances of such characters in the input are represented in the\n    output by a single instance of the last character in dest. The\n\n        translit 0-9 9\n\n    converts each string of digits to the single digit 9.\n    Finally, if src is precedded by ^, then all but the characters\n    represented by src are taken as the source string; i.e., they are\n    all deleted if dest is absent, or they are all collapsed if the\n    last character in dest is present.\n\nEXAMPLE\n\n    To convert upper case to lower:\n\n        translit A-Z a-z\n\n    To discard punctualtion and isolate words by spaces on each line:\n\n        translit ^a-zA-Z@n \" \"\n        This is a simple-minded test, i.e., a test of translit.\n        This is a simple minded test i e a test of translit\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPascal Source\n-------------\n\n[translit.p, Page 48](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/48/mode/1up)\n\n[makeset.p, Page 52](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/52/mode/2up)\n\n\n[addstr.p, Page 53](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/53/mode/1up)\n\n[dodash.p, Page 53](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/53/mode/1up)\n\n[isalphanum.p, Page 54](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/54/mode/1up)\n\n[esc.p, Page 55](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/55/mode/1up)\n\n\n[length.p, Page 46](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/46/mode/1up)\n\n\nThe impacts of having a richer language than 1980s ISO Pascal and\nevolution in practice suggest a revision in the K & P approach. I\nhave attempted to keep the spirit of their example program while\nreflecting changes in practice that have occurred in the last four\ndecades.\n\n\nSource code for **Translit.Mod**\n--------------------------------\n\n~~~\nMODULE Translit;\nIMPORT In, Out, Args := extArgs, Strings, Chars;\n\nCONST\n    MAXSTR = 1024; (* or whatever *)\n    DASH = Chars.DASH;\n    ENDSTR = Chars.ENDSTR;\n    ESCAPE = \"@\";\n    TAB* = Chars.TAB;\n\n(* Error -- write an error string to standard out and\n   halt program *)\nPROCEDURE Error(s : ARRAY OF CHAR);\nBEGIN\n    Out.String(s);Out.Ln();\n    ASSERT(FALSE);\nEND Error;\n\n(* IsEscape - this procedure looks to see if we have an\nescape sequence at position in variable i *)\nPROCEDURE IsEscape*(src : ARRAY OF CHAR; i : INTEGER) : BOOLEAN;\nVAR res : BOOLEAN; last : INTEGER;\nBEGIN\n  res := FALSE;\n  last := Strings.Length(src) - 1;\n  IF (i < last) & (src[i] = ESCAPE) THEN\n    res := TRUE;\n  END;\n  RETURN res\nEND IsEscape;\n\n(* ExpandEscape - this procedure takes a source array, a\n   position and appends the escaped value to the destintation\n   array.  It returns TRUE on successuss, FALSE otherwise. *)\nPROCEDURE ExpandEscape*(src : ARRAY OF CHAR; i : INTEGER; VAR dest : ARRAY OF CHAR) : BOOLEAN;\nVAR res : BOOLEAN; j : INTEGER;\nBEGIN\n res := FALSE;\n j := i + 1;\n IF j < Strings.Length(src)  THEN\n    res := Chars.AppendChar(src[j], dest)\n END\n RETURN res\nEND ExpandEscape;\n\n(* IsSequence - this procedure looks at position i and checks\n   to see if we have a sequence to expand *)\nPROCEDURE IsSequence*(src : ARRAY OF CHAR; i : INTEGER) : BOOLEAN;\nVAR res : BOOLEAN;\nBEGIN\n  res := Strings.Length(src) - i >= 3;\n  (* Do we have a sequence of alphumeric character\n     DASH alpanumeric character? *)\n  IF res & Chars.IsAlphaNum(src[i]) & (src[i+1] = DASH) &\n            Chars.IsAlphaNum(src[i+2]) THEN\n      res := TRUE;\n  END;\n  RETURN res\nEND IsSequence;\n\n(* ExpandSequence - this procedure expands a sequence x\n   starting at i and append the sequence into the destination\n   string. It returns TRUE on success, FALSE otherwise *)\nPROCEDURE ExpandSequence*(src : ARRAY OF CHAR; i : INTEGER; VAR dest : ARRAY OF CHAR) : BOOLEAN;\nVAR res : BOOLEAN; cur, start, end : INTEGER;\nBEGIN\n  (* Make sure sequence is assending *)\n  res := TRUE;\n  start := ORD(src[i]);\n  end := ORD(src[i+2]);\n  IF start < end THEN\n    FOR cur := start TO end DO\n      IF res THEN\n        res := Chars.AppendChar(CHR(cur), dest);\n      END;\n    END;\n  ELSE\n    res := FALSE;\n  END;\n  RETURN res\nEND ExpandSequence;\n\n\n(* makeset -- make sets based on src expanded into destination *)\nPROCEDURE MakeSet* (src : ARRAY OF CHAR; start : INTEGER; VAR dest : ARRAY OF CHAR) : BOOLEAN;\nVAR i : INTEGER; makeset : BOOLEAN;\nBEGIN\n    i := start;\n    makeset := TRUE;\n    WHILE (makeset = TRUE) & (i < Strings.Length(src)) DO\n        IF IsEscape(src, i) THEN\n            makeset := ExpandEscape(src, i, dest);\n            i := i + 2;\n        ELSIF IsSequence(src, i) THEN\n            makeset := ExpandSequence(src, i, dest);\n            i := i + 3;\n        ELSE\n            makeset := Chars.AppendChar(src[i], dest);\n            i := i + 1;\n        END;\n    END;\n    RETURN makeset\nEND MakeSet;\n\n\n(* Index -- find position of character c in string s *)\nPROCEDURE Index* (VAR s : ARRAY OF CHAR; c : CHAR) : INTEGER;\nVAR\n    i, index : INTEGER;\nBEGIN\n    i := 0;\n    WHILE (s[i] # c) & (s[i] # ENDSTR) DO\n        i := i + 1;\n    END;\n    IF (s[i] = ENDSTR) THEN\n        index := -1; (* Value not found *)\n    ELSE\n        index := i; (* Value found *)\n    END;\n    RETURN index\nEND Index;\n\n(* XIndex -- conditionally invert value found in index *)\nPROCEDURE XIndex* (VAR inset : ARRAY OF CHAR; c : CHAR;\n    allbut : BOOLEAN; lastto : INTEGER) : INTEGER;\nVAR\n    xindex : INTEGER;\nBEGIN\n    (* Uninverted index value *)\n    xindex := Index(inset, c);\n    (* Handle inverted index value *)\n    IF (allbut = TRUE) THEN\n        IF (xindex = -1)  THEN\n            (* Translate as an inverted the response *)\n            xindex := 0; (* lastto - 1; *)\n        ELSE\n            (* Indicate no translate *)\n            xindex := -1;\n        END;\n    END;\n    RETURN xindex\nEND XIndex;\n\n(* Translit -- map characters *)\nPROCEDURE Translit* ();\nCONST\n    NEGATE = Chars.CARET; (* ^ *)\nVAR\n    arg, fromset, toset : ARRAY MAXSTR OF CHAR;\n    c : CHAR;\n    i, lastto : INTEGER;\n    allbut, squash : BOOLEAN;\n    res : INTEGER;\nBEGIN\n    i := 0;\n    lastto := MAXSTR - 1;\n    (* NOTE: We are doing low level of string manimulation. Oberon\n       strings are terminated by 0X, but Oberon compilers do not\n       automatically initialize memory to a specific state. In the\n       OBNC implementation of Oberon-07 assign \"\" to an assignment\n       like `s := \"\";` only writes a 0X to position zero of the\n       array of char. Since we are doing position based character\n       assignment and can easily overwrite a single 0X.  To be safe\n       we want to assign all the positions in the array to 0X so the\n       memory is in a known state.  *)\n    Chars.Clear(arg);\n    Chars.Clear(fromset);\n    Chars.Clear(toset);\n    IF (Args.count = 0) THEN\n        Error(\"usage: translit from to\");\n    END;\n    (* NOTE: I have not used an IF ELSE here because we have\n       additional conditions that lead to complex logic.  The\n       procedure Error() calls ASSERT(FALSE); which in Oberon-07\n       halts the program from further execution *)\n    IF (Args.count > 0) THEN\n        Args.Get(0, arg, res);\n        allbut := (arg[0] = NEGATE);\n        IF (allbut) THEN\n            i := 1;\n        ELSE\n            i := 0;\n        END;\n        IF MakeSet(arg, i, fromset) = FALSE THEN\n            Error(\"from set too long\");\n        END;\n    END;\n    (* NOTE: We have initialized our array of char earlier so we only\n       need to know if we need to update toset to a new value *)\n    Chars.Clear(arg);\n    IF (Args.count = 2) THEN\n        Args.Get(1, arg, res);\n        IF MakeSet(arg, 0, toset) = FALSE THEN\n            Error(\"to set too long\");\n        END;\n    END;\n\n    lastto := Strings.Length(toset);\n    squash := (Strings.Length(fromset) > lastto) OR (allbut);\n    REPEAT\n        In.Char(c);\n        IF In.Done THEN\n            i := XIndex(fromset, c, allbut, lastto);\n            IF (squash) & (i>=lastto) & (lastto>0) THEN (* translate *)\n                Out.Char(toset[lastto]);\n            ELSIF (i >= 0) & (lastto > 0) THEN    (* translate *)\n                Out.Char(toset[i]);\n            ELSIF i = -1 THEN                        (* copy *)\n              (* Do not translate the character *)\n              Out.Char(c);\n              (* NOTE: No else clause needed as not writing out\n\t\t\t     a cut value is deleting *)\n            END;\n        END;\n    UNTIL (In.Done # TRUE);\nEND Translit;\n\nBEGIN\n    Translit();\nEND Translit.\n\n~~~\n\n\n\nIn closing\n==========\n\nIn this chapter we interact with some of the most common features\nof command line programs available on POSIX systems. K & P have given\nus a solid foundation on which to build more complex and ambitious\nprograms. In the following chapters the read will find an\naccelerated level of complexity bit also programs that are\nsignificantly more powerful.\n\nOberon language evolved with the Oberon System which had a very\ndifferent rich text user interface when compared with POSIX.\nFortunately Karl's OBNC comes with a set of modules that make\nOberon-07 friendly for building programs for POSIX operating systems.\nI've taken advantage of his `extArgs` module much in the way\nthat K & P relied on a set of primitive tools to provide a common\nprogramming environment. K & P's version of\n[implementation of primitives](https://archive.org/details/softwaretoolsinp00kern/page/315/mode/1up)\nlisted in their appendix. Karl's OBNC extensions modules are\ndescribed on [website](https://miasap.se/obnc/obncdoc/ext/).\nOther Oberon compilers provide similar modules though implementation\nspecific. A good example is Spivey's [Oxford Oberon-2 Compiler](https://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler).\nK & P chose to target multiple Pascal implementations, I have the\nluxury of targeting one Oberon-07 implementation. That said if you\nadded a pre-processor like K & P did you could also take their approach\nto allow you Oberon-07 code to work across many Oberon compiler\nimplementations. I leave that as an exercise for the reader.\n\nI've chosen to revise some of the code presented in K & P's book. I\nbelieve the K & P implementations still contains wisdom in their\nimplementations. They had different constraints and thus made\ndifferent choices in implementation. Understand the trade offs and\nchallenges to writing portable code capable of running in very\ndivergent set of early 1980's operating systems remains useful today.\n\nCompiling with OBNC:\n\n~~~\n\n    obnc -o entab Entab.Mod\n    obnc -o overstrike Overstrike.Mod\n    obnc -o compress Compress.Mod\n    obnc -o expand Expand.Mod\n    obnc -o echo Echo.Mod\n    obnc -o translit Translit.Mod\n\n~~~\n\n+ [Entab](Entab.Mod)\n    + [Tabs](Tabs.Mod), this one visited this one in last installment.\n+ [Overstrike](Overstrike.Mod)\n+ [Compress](Compress.Mod)\n+ [Expand](Expand.Mod)\n+ [Echo](Echo.Mod)\n+ [Translit](Translit.Mod)\n\t+ [Chars](Chars.Mod)\n\n<!--\nNext and Previous\n-----------------\n\n+ Next: [Files]()\n-->\n\nPrevious\n--------\n\n+ Previous: [Getting Started](../../09/29/Software-Tools-1.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "keywords": [
          "Oberon",
          "Pascal",
          "Programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 2,
        "series": "Software Tools",
        "title": "Software Tools, Filters"
      },
      "url": "posts/2020/10/31/Filters.json"
    },
    {
      "content": "\nRevealing the Pandoc AST\n========================\n\nI've used Pandoc for a number of years, probably a decade. It's been wonderful\nwatching it grow in capability. When Pandoc started accepting JSON documents as\na support metadata file things really started to click for me. Pandoc became\nmy go to tool for rendering content in my writing and documentation projects.\n\nRecently I've decided I want a little bit more from Pandoc. I've become curious\nabout prototyping some document conversion via Pandoc's filter mechanism. To do\nthat you need to understand the AST, aka abstract syntax tree. \nHow is the AST structure? \n\nIt turns out I just wasn't thinking simply enough (or maybe just not paying\nenough attention while I skimmed Pandoc's documentation). Pandoc's processing\nmodel looks like\n\n```\n\tINPUT --reader--> AST --filter AST --writer--> OUTPUT\n```\n\nI've \"known\" this forever. The missing piece for me was understanding \nthe AST can be an output format.  Use the `--to` option with the value\n\"native\" you get the Haskell representation of the AST. It's that simple.\n\n```\n\tpandoc --from=markdown --to=native \\\n\t   learning-to-write-a-pandoc-filter.md | \\\n\t   head -n 20\n```\n\nOutput\n\n```\n[ Header\n    1\n    ( \"learning-to-write-a-pandoc-filter\" , [] , [] )\n    [ Str \"Learning\"\n    , Space\n    , Str \"to\"\n    , Space\n    , Str \"write\"\n    , Space\n    , Str \"a\"\n    , Space\n    , Str \"Pandoc\"\n    , Space\n    , Str \"filter\"\n    ]\n, Para\n    [ Str \"I\\8217ve\"\n    , Space\n    , Str \"used\"\n    , Space\n```\n\nIf you prefer JSON over Haskell use `--to=json` for similar effect. Here's\nan example piping through [jq](https://stedolan.github.io/jq/).\n\n```\n\tpandoc --from=markdown --to=json \\\n\t   learning-to-write-a-pandoc-filter.md | jq .\n```\n\nWriting filters makes much sense to me now. I can see the AST and see\nhow the documentation describes writing hooks in Lua to process it.\n\n",
      "data": {
        "copyright": "copyright (c) 2022, R. S. Doiel",
        "keywords": [
          "Pandoc",
          "filter"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 4,
        "series": "Pandoc Techniques",
        "title": "Revealing the Pandoc AST"
      },
      "url": "posts/2022/11/17/revealing-pandoc-ast.json"
    },
    {
      "content": "\n\nOPML to Markdown and back\n=========================\n\nBy R. S. Doiel 2016-05-28\n\n## Overview\n\nI wrote a Go language package to sort [OPML](http://dev.opml.org/spec2.html) outlines. \nI wrote this because my preferred [feed reader ](http://goread.io) supports manual \nsorting but not automatic alpha sorting by the _outline_ element's _text_ attribute. \n\n## Observations\n\nOut of the box the OPML 2 Spec provides attributes indicating inclusion of other OPML files,\nscripts, basic metadata (create, modified, authorship), and even directory structures.\n\n[Fargo](http://fargo.io) allows user defined attributes to be applied to the _outline_ \nelement in OPML. This could be used in support some of the \n[Scrivener](https://www.literatureandlatte.com/scrivener.php)\nfeatures I miss such as describing how to render a project to various formats such as\nrtf, pdf, ePub, web pages or even [Final Draft fdx](https://www.finaldraft.com/) files.\n\nI write allot of Markdown formatted text.  Markdown is simple to index, \nsearch and convert into useful formats. Markdown is not good at expressing more\ncomplex structures such as metadata. Website generators that use markdown often\nrequire a preamble or _front matter_ in the markdown to provide any metadata. This\nleaves your document head cluttered and less human readable.\n\nAnother approach is to include a parallel document with the metadata.  It occurred to me \nthat an OPML file could easily hold that metadata. It can even hold Markdown content.\nThe trouble with OPML is that it is not quick to edit by hand.\n\n    Is there a round trip semantic mapping between OPML and Markdown?\n\n\n## Germination of an idea\n\nEntering a web link in Fargo the link is URL encoded and saved in the _text_ attribute of the \n_outline_ element.\n\nThe source view of a web links in Fargo's _outline_ element looks like\n\n```OPML\n    <outline text=\"&gt; href=&quot;http://example.org&quot;&lt;My example.org&gt;/a&lt;\" />\n```\n\nThat _outline_ element might render in Markdown as\n\n```\n    + [My element.org](http://example.org)\n```\n\nThe steps to create the Markdown view are simple\n\n1. URL decode the _text_ attribute\n2. Convert HTML to Markdown\n\nMaking a round trip could be done by\n\n3. Convert Markdown into HTML\n4. For each _li_ element covert to an _outline_ element URL encoding the inner HTML of the _li_\n\nSo far so good. What about something more complex?\n\n\nHere's an _outline_ element example from http://hosting.opml.org/dave/spec/directory.opml \n\n```OPML\n    <outline text=\"Scripting News sites\" created=\"Sun, 16 Oct 2005 05:56:10 GMT\" type=\"link\" url=\"http://hosting.opml.org/dave/mySites.opml\"/>\n```\n\nTo me that should look like \n\n```\n    + [Scripting News Sites](http://hosting.opml.org/dave/mySites.opml)\n```\n\nWhat about the _created_ attribute? Could we render this case as an additional set of anchors using data uri?\n\nThis suggest a rule like\n\n+ if the _text_ attribute contains HTML markup\n    + URL decode into HTML\n    + Convert HTML to Markdown\n+ else render attributes as additional anchors using data URI\n\nThis might work as follows. \n\n```OPML\n    <outline text=\"Scripting News sites\" \n        created=\"Sun, 16 Oct 2005 05:56:10 GMT\" \n        type=\"link\" \n        url=\"http://hosting.opml.org/dave/mySites.opml\"/>\n```\n\nWould become \n\n```Markdown\n    + [Scripting News Sites](http://hosting.opml.org/dave/mySites.opml) [type](data:text/plain;link) [created](data:text/date;Sun, 16 Oct 2005 05:56:10 GMT)\n```\n\nIn HTML this would look like\n\n```HTML\n    <li><a href=\"http://histing.opml.org/dave/mySites.opml\">Scripting News Sites</a>\n        <a href=\"data:text/plain;link\">type</a>\n        <a href=\"data:text/date;Sun, 16 Oct 2005 05:56:10 GMT\">created</a></li>\n```\n\n### Markdown to OPML\n\nComing back to OPML from Markdown then becomes\n\n+ Convert Markdown to HTML\n+ For each _li_ element inspect anchors, \n    + if anchors contain data URI then map _outline_ element\n    + else URL encode and embed in _outline_ _text_ attribute\n\nIs this viable? Does it have any advantages?\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2016, R. S. Doiel",
        "date": "2016-05-28",
        "keywords": [
          "golang",
          "opml",
          "markdown"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "OPML to Markdown and back"
      },
      "url": "posts/2016/05/28/OPML-to-Markdown-and-back.json"
    },
    {
      "content": "\n\n# Instant Articles, Accelerated Mobile Pages, Twitter Cards and Open Graph\n\nBy R. S. Doiel 2016-05-30\n\n## The problem\n\nThe web has gotten slow. In [2016](http://httparchive.org/trends.php) the \naverage page weight is in multi-megabytes and the average number of network \nrequests needed to deliver the content is counted in \nthe hundreds. In the mix are saturated networks and a continued public \nexpectation of responsiveness (web wisdom suggests you have about 3 seconds \nbefore people give up).  The odd thing is we've known how to build fast \nwebsites for a [decade](https://www.stevesouders.com/) or so.  \nCollectively we don't build them [fast](https://www.sitepoint.com/average-page-weight-increased-another-16-2015/). \n\n\n## Meet the new abstractions\n\nCorporations believe they have the answer and they are providing us \nwith another set of abstractions. In a few years maybe these will \nget distilled down to a shared common view but in the mean time disc \ncosts remain reasonably priced and generating these new forms of \npages or feeds is a template or so away.\n\n+ [Twitter Cards](https://dev.twitter.com/cards/overview) and [Open Graph](http://ogp.me/)\n  + Exposing your content via social media, search results or embedded in pages via an aside element\n+ [Accelerated Mobile Pages](https://www.ampproject.org/) (also called AMP)\n  + A simplification in content delivery to improve web reading experience\n  + Its usefulness is it proscribes an approach to leverage what we have\n  + AMP works well with Twitter Cards, Open Graph and can leverage Web Components\n+ [Instant Articles](https://instantarticles.fb.com/)\n  + a format play to feed the walled garden of Facebook for iOS and Android devices\n\n\n## The players \n\n### Twitter Cards and Open Graph\n\nTwitter's Titter Cards and Facebook's Open Graph offer approaches to \nbuild off of our existing meta elements in an HTML page's document \nhead.  They are named space to avoid collisions but supporting both \nwill still result in some content duplication. The k-weight \ndifference in the resulting HTML pages isn't too bad. \n\nAdopting either or both is a matter of adjusting how your render your \nweb page's head block.  It is easy enough to do manually but easier \nstill using some sort of template system that renders the appropriate \nmeta elements based on the content type and contents in the page \nbeing rendered.  \n\nGoogle and other search engines can leverage this richer meta \ndata and integrate it into their results. Google's Now application can \nrender content cards based on either semantic. It also appears that \ncontent cards are being leverage selectively for an aside and related \ncontent on Google search results pages. You could even built this into \nyour own indexing process for use with the Solr or Elasticsearch.\n\nContent Cards offer intriguing opportunity for web crawlers and search \nengines.  This is particularly true when combined with mature feed \nformats like RSS, OPML, Atom and the maturing efforts in the linked \ndata community around JSON-LD.\n\n\n### AMP - Accelerated Mobile Pages\n\nThe backers of AMP (not to be confused with Apache+MySQL+PHP) are largely\npublishers including major news outlets and web media\ncompanies in the US and Europe. This is an abridged list from 2015--\n\n+ BBC\n+ Atlantic Media\n+ Vox Media\n+ Conde Nast\n+ New York Times\n+ Wall Street Journal\n+ The Daily Mail\n+ Huffington Post\n+ Gannet\n+ The Guardian\n+ The Economist\n+ The Financial Times\n\nIn additional to the publishers there is participation by tech companies\nsuch as Google, Pinterest, Twitter, LinkedIn and Wordpress.com.  Accelerated\nMobile Pages offer benefits for web crawlers and search engines supporting\nsurfacing content is clearly and enabling easier distinction from \nadvertisements. \n\n\n### Instant Articles\n\nIn additional to Open Graph Facebook has put forward [Instant Articles](https://developers.facebook.com/docs/instant-articles).\nLike AMP it is targeting content delivery for mobile. Unlike AMP Instant Articles is an\nexplicit binding into Facebook's walled garden only exposing the content on supported\nversions of iOS and Android. You don't see Instant Articles in your Facebook timeline or when  \nyou browse from a desktop web browser.  Unlike the previous\nexamples you actually need to sign up to participate in the Instant Article publishing\nprocess.  Sign up cost is having a Facebook account, being approved by Facebook and compliance\nwith their terms of service. Facebook does provide some publishing tools, publishing controls\nas well as some analytics. They do allow 3rd party ads as well as encourage access to\ntheir advertising network.  Once approved the burden on your content manage process \nappears manageable.  \n\nYou can submit Instant Articles via a modified RSS feed or directly through their API. \nIn this sense the overhead is about the same as that for implementing support for Twitter Cards\nOpen Graph, and AMP. Facebook does a good job of quickly propagating changes to your\nInstant Articles across their platform. That's nice.\n\nWhy go through the trouble? If you're a content producer and your audience lives on Facebook\nFacebook commands the attention of a lot of eye balls.  Instant Articles provides \nanother avenue to reach them.  For some Facebook effectively controls the public view of the \nweb much as America Online and Prodigy did decades ago. [Dave Winer](https://twitter.com/davewiner) \nhas written extensively on how he implemented Instant Article support along with \nsome very reasoned pros and cons for doing so. The landscape is evolving and \n[Dave's river of news](http://scripting.com) is worth following.\n\n\n## Impact on building content\n\nThese approaches require changes in your production of your HTML and RSS sent to the browser.\nTwitter Cards and Open Graph change what you put in the HEAD element of the HTML\npages.  AMP proscribes what you should put in the BODY element of the webpage.\nInstant Articles tweaks your RSS output.  Not surprisingly the major content management \nsystems Wordpress and Drupal have plugins for this.  All can be implemented via your template \nsystem or page generation process.\n\n\n## Whither adopt?\n\nBecause these approaches boil down to content assembly the adoption risk \nis low.  If your audience views Twitter, Facebook or Google search results \nthen it is probably worth doing.  All allow you to continue to publish your \nown content and own your URLs as opposed to being a tenant on one or another \nplatform. That benefits the open web.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2016, R. S. Doiel",
        "date": "2016-05-30",
        "keywords": [
          "structured data",
          "amp",
          "opengraph",
          "twitter",
          "google",
          "facebook",
          "instant pages"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Instant Articles, Accelerated Mobile Pages, Twitter Cards and Open Graph"
      },
      "url": "posts/2016/05/30/amp-cards-and-open-graph.json"
    },
    {
      "content": "\n\n# Cross compiling Go 1.8.3 for Pine64 Pinebook\n\nBy R. S. Doiel 2017-06-16\n\nPine64's Pinebook has a 64-bit Quad-Core ARM Cortex A53 which is \nnot the same ARM processor found on a Raspberry Pi 3. As a \nresult it needs its own compiled version of Go. Fortunately cross \ncompiling Go is very straight forward. I found two helpful Gists\non GitHub discussing compiling Go for a 64-Bit ARM processor. \n\n+ [conoro's gist](https://gist.github.com/conoro/4fca191fad018b6e47922a21fab499ca)\n+ [truedat101's gist](https://gist.github.com/truedat101/5898604b1f7a1ec42d65a75fa6a0b802)\n\nI am using a Raspberry Pi 3, raspberrypi.local, as my cross compile \nhost. Go 1.8.3 is already compiled and available.  Inspired by the \ngists I worked up with this recipe to bring a Go 1.8.3 to my Pinebook.\n\n```shell\n    cd\n    mkdir -p gobuild\n    cd gobuild\n    git clone https://github.com/golang/go.git go1.8.3\n    cd go1.8.3\n    git checkout go1.8.3\n    export GOHOSTARCH=arm\n    export GOARCH=arm64\n    export GOOS=linux\n    cd src\n    ./bootstrap.bash\n```\n\nAfter the bootstrap compile is finished I switch to my Pinebook,\ncopy the bootstrap compiler to my Pinebook and use it to compile\na new go1.8.3 for Pine64.\n\n```shell\n    cd\n    scp -r raspberrypi.local:gobuild/*.tbz ./\n    tar jxvf go-linux-arm64-bootstrap.tbz\n    export GOROOT=go-linux-arm64-bootstrap\n    go-linux-arm64-bootstrap/bin/go version\n    unset GOROOT\n    git clone https://github.com/golang/go\n    cd go\n    git checkout go1.8.3\n    export GOROOT_BOOTSTRAP=$HOME/go-linux-arm64-bootstrap\n    cd src\n    ./all.bash\n```\n\n_all.bash_ will successfully compile _go_ and _gofmt_ but fail on \nthe tests. It's not perfect but appears to work as I explore\nbuilding Go applications on my Pinebook. Upcoming Go releases should\nprovide better support for 64 bit ARM.\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2016, R. S. Doiel",
        "date": "2016-06-16",
        "keywords": [
          "Golang",
          "Pine64",
          "ARM"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Cross compiling Go 1.8.3 for Pine64 Pinebook"
      },
      "url": "posts/2017/06/16/cross-compiling-go.json"
    },
    {
      "content": "\n\nHow to make a Pi-Top more Raspbian\n==================================\n\nBy R. S. Doiel, 2016-07-04\n\nI have a first generation Pi-Top.  I like the idea but found I didn't use it much due to a preference for\nbasic Raspbian. With the recent Pi-TopOS upgrades I realized getting back to basic Raspbian was relatively\nstraight forward.\n\n## The recipe\n\n1. Make sure you're running the latest Pi-TopOS based on Jessie\n2. Login into your Pi-Top normally\n3. From the Pi-Top dashboard select the \"Desktop\" icon\n4. When you see the familiar Raspbian desktop click on the following things\n\t+ Click on the Raspberry Menu (upper left corner)\n\t+ Click on Preferences\n\t+ Click on Raspberry Pi Configuration\n5. I made the following changes to my System configuration\n\t+ Under *Boot* I selected \"To CLI\"\n\t+ I unchecked *login as user \"pi\"*\n6. Restart your Pi Top\n\t+ Click on Raspberry Menu in the upper left of the desktop\n\t+ Click on shutdown\n\t+ Select *reboot*\n7. When you restart you'll see an old school console login, login as the pi user using your Pi-Top password\n8. Remove the following program use the *apt* command\n\t+ ceed-universe\n\t+ pt-dashboard\n\t+ pt-splashscreen\n\n```\n    sudo apt purge ceed-universe pt-dashboard pt-splashscreen\n```\n\nNote: pi-battery, pt-hub-controller, pt-ipc, pt-speaker are hardware drivers specific to your Pi-Top so you probably\nwant to keep them.\n\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2016, R. S. Doiel",
        "date": "2016-07-04",
        "keywords": [
          "Raspberry Pi",
          "Pi-Top",
          "Rasbian",
          "Raspberry Pi OS",
          ":operating systems"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "How to make a Pi-Top more Raspbian"
      },
      "url": "posts/2016/07/04/How-To-Make-A-PiTop-More-Raspbian.json"
    },
    {
      "content": "\n\n# Exploring Bash for Windows 10 Pro\n\nBy R. S. Doiel 2016-08-15\n\n    UPDATE (2016-10-27, RSD): Today trying to compile Go 1.7.3 under \n    Windows 10 Pro I've am getting compile errors when the \n    assembler is being built.  I can compile go1.4.3 but see errors \n    in some of the tests results.\n\n## Initial Setup and configuration\n\nI am running Windows 10 Pro (64bit) Anniversary edition under Virtual Box. The VM was upgraded from an earlier version of Windows 10 Pro (64bit). The VM was allocated 4G or ram, 200G disc and simulating 2 cores.  After the upgrade I took the following steps\n\n+ Search with Bing for \"Bash for Windows\" \n    + Bing returns http://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/\n+ Switch on developer mode for Windows\n+ Turned on Linux Subsystem Beta (searched for \"Turning on Features\")\n+ Reboot\n+ Search for \"Bash\" and clicked on \"Run Bash command\"\n+ Answered \"y\"\n+ Waited for download and extracted file system\n+ When prompted setup developer account with username/password\n    + Documentation can be found at https://aka.ms/wsldocs\n+ Exit root install shell\n+ Search for \"Bash\" locally\n+ Launched \"Bash on Ubuntu on Windows\"\n+ Authenticate with your username/password\n\n\n## Setting up Go under Bash for Windows 10\n\nWith Bash installed these are the steps I took to compile Go\nunder Bash on Ubuntu on Windows.\n\n```shell\n    sudo apt-get update && sudo apt-get upgrade -y\n    sudo apt-get autoremove\n    sudo apt-get install build-essential clang git-core unzip zip -y\n    export CGO_ENABLE=0\n    git clone https://github.com/golang/go go1.4\n    git clone https://github.com/golang/go go\n    cd go1.4\n    git checkout go1.4.3\n    cd src\n    ./all.bash\n    cd\n    export PATH=$PATH:$HOME/go1.4/bin\n    cd go\n    git checkout go1.7\n    cd src\n    ./all.bash\n    cd\n    export PATH=$HOME/go/bin:$HOME/bin:$PATH\n    export GOPATH=$HOME\n```\n\nNote some tests failing during compilation in both 1.4.3 and 1.7. They mostly failed\naround network sockets.  This is probably a result of the limitations in the Linux subsystem\nunder Windows.\n\nIf successful you should be able to run `go version` as well as install additional Go based software\nwith the usual `go get ...` syntax.\n\nIn your `.bashrc` or `.profile` add the following\n\n```shell\n    export PATH=$HOME/go/bin:$HOME/bin:$PATH\n    export GOPATH=$HOME\n```\n\n\n## Improved vim setup\n\nI like the vim-go packages for editing Go code in vim. They are easy to setup.\n\n```shell\n     mkdir -p ~/.vim/autoload ~/.vim/bundle \n     curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim\n     git clone https://github.com/fatih/vim-go.git ~/.vim/bundle/vim-go\n```\n\nExample $HOME/.vimrc\n\n```vimrc\n    execute pathogen#infect()\n    syntax on\n    filetype plugin on\n    set ai\n    set nu\n    set smartindent\n    set tabstop=4\n    set shiftwidth=4\n    set expandtab\n    let &background = ( &background == \"dark\"? \"light\" : \"dark\" )\n    let g:vim_markdown_folding_disabled=1\n```\n\nColor schemes are browsable at [vimcolors.com](http://vimcolors.com). They can be installed in\n$HOME/.vim/colors.\n\n1. git clone and place the colorscheme\n2. place the *.vim file holding the color scheme into $HOME/.vim/colors\n3. start vim and at the : do colorscheme NAME where NAME is the scheme you want to try\n\nYou can find the default shipped color schemes in /usr/share/vim/vimNN/colors where vimNN is the version number\ne.g. /usr/share/vim/vim74/colors.\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2016, R. S. Doiel",
        "date": "2016-08-15",
        "keywords": [
          "Golang",
          "Windows",
          "Bash",
          "Linux Subsystem"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Exploring Bash for Windows 10 Pro"
      },
      "url": "posts/2016/08/15/Setting-up-Go-under-Bash-for-Windows-10.json"
    },
    {
      "content": "\n\nFrom Markdown and Bash to mkpage\n================================\n\nBy R. S. Doiel 2016-08-16\n\nWhen I started maintaining a website on GitHub a few years ago my needs\nwere so simple I hand coded the HTML.  Eventually I adopted \na markdown processor for maintaining the prose. My \"theme\" was a\nCSS file and some HTML fragments to wrap the markdown output. If I needed \ninteractivity I used JavaScript to access content via a web API. \nLife was simple, all I had to learn to get started was Git and how to\npopulate a branch called \"gh-pages\".\n\n\n## Deconstructing Content Management Systems\n\nRecently my website needs have grown. I started experimenting with static\nsite generators thinking an existing system would be the right fit. \nWhat I found were feature rich systems that varied primarily in \nimplementation language and template engine. Even though I wasn't\nrequired to run Apache, MySQL and PHP/Perl/Python/Ruby/Tomcat it felt \nlike the static site generators were racing to fill a complexity \nvacuum. In the end they were interesting to explore but far more\nthan I was willing to run. I believe modern content management systems can\nbe deconstruct into something simpler.\n\nSome of the core elements of modern content management systems are\n\n+ creation and curation of data sources (including metadata)\n+ transforming data sources if needed\n+ mapping a data source to appropriate template set\n+ rendering template sets to produce a final website\n\nModern static site generators leave creation and curation to your \ntext editor and revision control system (e.g. vi and git). \n\nMost static site generators use a simplified markup. A populate one is\ncalled [Markdown](https://en.wikipedia.org/wiki/Markdown). This \"markup\"\nis predictable enough that you can easily convert the results to HTML and\nother useful formats with tools like [pandoc](http://pandoc.org/). In most \nstatic site generators your content is curated in Markdown and when the \npages are built it is rendered to HTML for injection into your website's \ntemplate and theme.\n\nMapping the data sources to templates, combining the templates and rendering \nthe final website is where most systems introduce a large amount of complexity.\nThis is true of static site generators like [Jekill](https://jekyllrb.com) and \n[Hugo](https://gohugo.io).\n\n\n## An experimental deconstruction\n\nI wanted a simple command line tool that would make a single web page.\nIt would take a few data sources and formats and run them through a\ntemplate system. The template system needed to be simple but support\nthe case where data might not be available. It would be nice if it handled\nthe case of repetitious data like that used in tables or lists. Ideally\nI could render many pages from a single template assuming a simple website\nand layout.\n\n### A single page generator\n\n[mkpage](https://github.com/rsdoiel/mkpage) started as an experiment in\nbuilding a simple single page generator. It's responsibilities\ninclude mapping data sources to the template, transforming data if needed\nand rendering the results. After reviewing the websites I've setup in\nthe last year or two I realized I had three common types of data.\n\n1. Plain text or content that did not need further processing\n2. Markdown content (e.g. page content, navigation lists)\n3. Occasionally I include content from JSON feeds\n\nI also realized I only needed to handle three data sources.\n\n1. strings\n2. files\n3. web resources\n\nEach of these sources might provide plain text, markdown or JSON data formats.\n\nThat poses the question of how to express the data format and the data \nsource when mapping the content into a template. The web resources are\neasy in the sense that the web responses include content type information.\nFiles can be simple too as the file extension indicates their\nformat (e.g. \".md\" for Markdown, \".json\" for JSON documents). What remained\nwas how to identify a text string's format.  I opted for a prefix ending in \na colon (e.g. \"text:\" for plain text, \"markdown:\" for markdown \nand \"json:\" for JSON). This mapping allows for a simple key/value\nrelationship to be expressed easily on the command line.\n\n### mkpage in action\n\nDescribing how to build \"mypage.html\" from \"mypage.md\" and \"nav.md\" \n(containing links for navigating the website) is as easy as typing\n\n```shell\n    mkpage \"content=mypage.md\" \"navigation=nav.md\" page.tmpl > mypage.html\n```\n\nIn this example the template is called \"page.tmpl\" and we redirect the \noutput to \"mypage.html\".\n\n\nAdding a custom page title is easy too.\n\n```shell\n    mkpage \"title=text:My Page\" \\\n        \"content=mypage.md' \"navigation=nav.md\" \n        page.tmpl \\\n        > mypage.html\n```\n\nLikewise integrating some JSON data from weather.gov is relatively straight\nforward. The hardest part is discovering the [URL](http://forecast.weather.gov/MapClick.php?lat=34.0522&lon=118.2437&DFcstType=json) \nthat returns JSON!  Notice I have added a weather field and the URL. When data\nis received back from weather.gov it is JSON decoded and then passed to the\ntemplate for rendering using the \"range\" template function.\n\n```shell\n    mkpage \"title=My Page\" \\\n        \"content=mypage.md\" \\\n        \"navigation=nav.md\" \\\n        \"weather=http://forecast.weather.gov/MapClick.php?lat=34.0522&lon=118.2437&DFcstType=json\" \\\n        page.tmpl \\\n        > mypage.html\n```\n\nWhat is *mkpage* doing?\n\n1. Reading the data sources and formats from the command line\n2. Transforming the Markdown and JSON content appropriately\n3. Applying them to the template (e.g. page.tmpl)\n4. Render the results to stdout\n\nBuilding a website then is only a matter of maintaining navigation in\n*nav.md* and identifying the pages needing to be created. I can easily \nautomated that using the Unix find, grep, cut and sort. Also with find \nI can iteratively process each markdown file applying a \ntemplate and rendering the related HTML file.  This can be done for a site \nof a few pages (e.g. about, resume and cv) to more complex websites like \nblogs and repository activities.\n\nHere's an example template that would be suitable for the previous\ncommand line example. It's mostly just HTML and some curly bracket notation \nsprinkled in.\n\n```html\n    <!DOCTYPE html>\n    <html>\n    <head>\n        {{with .title}}<title>{{- . -}}</title>{{end}}\n        <link rel=\"stylesheet\" href=\"css/site.css\">\n    </head>\n    <body>\n        <nav>\n        {{ .navigation }}\n        </nav>\n        <section>\n        {{ .content }}\n        </section>\n        <aside>\n        Weather Demo<br />\n        <ul>\n        {{range .weather.data.text}}\n            <li>{{ . }}</li>\n        {{end}}\n        </ul>\n        </aside>\n\n    </body>\n    </html>\n```\n\nYou can find out more about [mkpage](https://github.com/rsdoiel/mkpage)\n[rsdoiel.github.io/mkpage](https://rsdoiel.github.io/mkpage).\n\nTo learn more about Go's text templates see \n[golang.org/pkg/text/template](https://golang.org/pkg/text/template/). \n\nIf your site generator needs are more than *mkpage* I suggest [Hugo](https://gohugo.io). \nIt's what I would probably reach for if I was building a large complex organizational\nsite or news site.\n\nIf you're looking for an innovative and rich author centric content system\nI suggest Dave Winer's [Fargo](http://fargo.io) outliner and [1999.io](https://1999.io).\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2016, R. S. Doiel",
        "date": "2016-08-16",
        "keywords": [
          "Bash",
          "Markdown",
          "site generator",
          "mkpage",
          "pandoc"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "From Markdown and Bash to mkpage"
      },
      "url": "posts/2016/08/16/From-Markdown-and-Bash-to-mkpage.json"
    },
    {
      "content": "\n\n# Android, Termux and Dev Environment\n\nBy R. S. Doiel 2016-09-20\n\nRecently I got a new Android 6 tablet. I got a case with a tiny Bluetooth keyboard. I started wondering if I could use it as a development device when on the road. So this is my diary of that test.\n\n## Challenges\n\n1. Find a way to run Bash without rooting my device\n2. See if I could use my normal web toolkit\n\t+ curl\n\t+ jq\n\t+ sed\n\t+ grep\n3. See if I could compile or add my own custom Golang programs\n4. Test setup by running a local static file server, mkpage and update my website\n\n## Searching for Android packages and tools of my toolbox\n\nAfter searching with Duck Duck Go and Google I came across the [termux](https://termux.com). Termux provides a minimal Bash shell environment with support for adding\npackages with _apt_ and _dpkg_.  The repositories visible to *termux* include\nmost of the C tool chain (e.g. clang, make, autoconf, etc) as well as my old Unix favorites _curl_, _grep_, _sed_, _gawk_ and a new addition to my toolkit _jq_.  Additionally you'll find recent versions (as of Sept. 2016) versions of _Golang_, _PHP_, _python_, and _Ruby_.\n\nThis quickly brought me through step 3.  Installing _go_, _git_, and _openssh_ completed what I needed to test static site development with some of the tools in our incubator at [Caltech Library](https://caltechlibrary.github.io).\n\n## Setting up for static site development\n\nAfter configuring _git_, adding my public key to GitHub and running _go get_ on my\ncustom static site tools I confirmed I could build and test static websites from my Android tablet using *Termux*.\n\nHere's the list of packages I installed under *Termux* to provide a suitable shell environment for writing and website constructions.\n\n```shell\n    apt install autoconf automake bash-completion bc binutils-dev bison \\\n        bzip2 clang cmake coreutils ctags curl dialog diffutils dos2unix \\\n        expect ffmpeg findutils gawk git gnutls golang grep gzip \\\n\timagemagick jq less lynx m4 make-dev man-dev nano nodejs \\\n        openssh patch php-dev python readline-dev rlwrap rsync ruby-dev \\\n        sed sensible-utils sharutils sqlite tar texinfo tree unzip vim \\\n        w3m wget zip\n```\n\nThis then allowed me to setup my *golang* environment variables and install\nmy typical custom written tools\n\n```shell\n    export PATH=$HOME/bin:$PATH\n    export GOPATH=$HOME\n    export GOBIN=$HOME/bin\n    go get github.com/rsdoiel/shelltools/...\n    go get github.com/caltechlibrary/mkpage/...\n    go get github.com/caltechlibrary/md2slides/...\n    go get github.com/caltechlibrary/ws/...\n```\n\nFinally pulled down some content to test.\n\n```shell\n    cd\n    mkdir Sites\n    git clone https://github.com/rsdoiel/rsdoiel.github.io.git Sites/rsdoiel.github.io\n    cd  Sites/rsdoiel.github.io\n    ws\n```\n\nThis started the local static site webserver and I pointed by Firefox for Android at http://localhost:8000 and saw a local copy of my personal website. From there I wrote this article and updated it just as if I was working on a Raspberry Pi or standard Linux laptop.\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2016, R. S. Doiel",
        "date": "2016-09-20",
        "keywords": [
          "Bash",
          "cURL",
          "jq",
          "sed",
          "grep",
          "search",
          "golang",
          "Android"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Android, Termux and Dev Environment"
      },
      "url": "posts/2016/09/20/Android-Termux-Dev-environment.json"
    },
    {
      "content": "\n\n# NodeJS, NPM, Electron\n\nBy R. S. Doiel 2017-10-20\n\nElectron is an app platform leveraging web technologies. Conceptually it is a\nmashup of NodeJS and Chrome browser. [Electron](https://electron.atom.io/) site\nhas a nice starter app. It displays a window with Electron version info and\n'hello world'.\n\nBefore you can get going with _Electron_ you need to have a\nworking _NodeJS_ and _NPM_. I usually compile from source and this\nwas my old recipe (adjusted for v8.7.0).\n\n```shell\n    cd\n    git clone https://github.com/nodejs/node.git\n    cd node\n    git checkout v8.7.0\n    ./configure --prefix=$HOME\n    make && make install\n```\n\nTo install an _Electron Quick Start_ I added the additional steps.\n\n```shell\n    cd\n    git clone https://github.com/electron/electron-quick-start\n    cd electron-quick-start\n    npm install\n    npm start\n```\n\nNotice _Electron_ depends on a working _node_ and _npm_.  When I\ntried this recipe it failed on `npm install` with errors regarding\ninternal missing node modules.\n\nAfter some fiddling I confirmed my node/npm install failed because\nI had install the new version of over a partially installed previous\nversion. This causes the node_modules to be populated with various\nconflicting versions of internal modules.\n\nSorting that out allowed me to test the current version of\n*electron-quick-start* cloned on 2017-10-20 under _NodeJS_ v8.7.0.\n\n## Avoiding Setup Issues in the future\n\nThe *Makefile* for _NodeJS_ includes an 'uninstall' option. Revising\nmy _NodeJS_ install recipe above I now do the following to setup a machine\nto work with _NodeJS_ or _Electron_.\n\n```shell\n    git clone git@github.com:nodejs/node.git\n    cd node\n    ./configure --prefix=$HOME\n    make uninstall\n    make clean\n    make -j 5\n    make install\n```\n\nIf I am on a device with a multi-core CPU (most of the time) you can speed\nup the make process using a `-j CPU_CORE_COUNT_PLUS_ONE` option (e.g. `-j 5`\nfor my 4 core x86 laptop).\n\nOnce _node_ and _npm_ were working normally the instructions in the\n*electron-quick-start* worked flawlessly on my x86.\n\nI have tested the node install recipe change on my Pine64 Pinebook, on \nseveral Raspberry Pi 3s as well as my x86 Ubuntu Linux laptop.\n\nI have not gotten Electron up on my Pine64 Pinebook or Raspberry Pi's yet. \n`npm install` outputs errors suggesting that it is expecting an x86 architecture.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2017, R. S. Doiel",
        "date": "2017-10-20",
        "keywords": [
          "Javascript",
          "NodeJS",
          "Electron"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "NodeJS, NPM, Electron"
      },
      "url": "posts/2017/10/20/node-npm-electron.json"
    },
    {
      "content": "\n\n# Harvesting my Gists from GitHub\n\nBy R. S. Doiel 2017-12-10\n\nThis is a just quick set of notes on harvesting my Gists on GitHub so I\nhave an independent copy for my own website. \n\n## Assumptions\n\nIn this gist I assume you are using Bash on a POSIX system (e.g. Raspbian \non a Raspberry Pi) with the standard compliment of Unix utilities (e.g. cut, \nsed, curl). I also use Stephen Dolan's [jq](https://github.com/stedolan/jq)\nas well as Caltech Library's [datatools](https://github.com/caltechlibrary/datatools).\nSee the respective GitHub repositories for installation instructions.\nThe gist harvest process was developed against GitHub's v3 API\n(see developer.github.com). \n\nIn the following examples \"USER\" is assumed to hold your GitHub user id \n(e.g. rsdoiel for https://github.com/rsdoiel).\n\n## Getting my basic profile\n\nThis retrieves the public view of your profile.\n\n```shell\n    curl -o USER \"https://api.github.com/users/USER\"\n```\n\n## Find the urL for your gists\n\nGet the gists url from `USER.json.\n\n```shell\n    GISTS_URL=$(jq \".gists_url\" \"USER.json\" | sed -E 's/\"//g' | cut -d '{' -f 1)\n    curl -o gists.json \"${GISTS_URL}\"\n```\n\nNow `gists.json` should hold a JSON array of objects representing your Gists.\n\n## Harvesting the individual Gists.\n\nWhen you look at _gists.json_ you'll see a multi-level JSON structure.  It has been\nformatted by the API so be easy to scrape.  But since this data is JSON and Caltech Library\nhas some nice utilities for working with JSON I'll use *jsonrange* and *jq* to pull out a list\nof individual Gists URLS.\n\n```shell\n    jsonrange -i gists.json | while read I; do \n        jq \".[$I].files\" gists.json | sed -E 's/\"//g'\n    done\n```\n\nExpanding this we can now curl each individual gist metadata to find URL to the raw file.\n\n\n```shell\n    jsonrange -i gists.json | while read I; do \n        jq \".[$I].files\" gists.json | jsonrange -i - | while read FNAME; do\n            jq \".[$I].files[\\\"$FNAME\\\"].raw_url\" gists.json | sed -E 's/\"//g'; \n        done;\n    done\n```\n\nNow that we have URLs to the raw gist files we can use curl again to fetch each.\n\nWhat do we want to store with our harvested gists?  The raw files, metadata\nabout the Gist (e.g. when it was created), the Gist ID. Putting it all together\nwe have the following script.\n\n```shell\n    #!/bin/bash\n    if [[ \"$1\" = \"\" ]]; then\n        echo \"USAGE: $(basename \"$0\") GITHUB_USERNAME\"\n        exit 1\n    fi\n\n    USER=\"$1\"\n    curl -o \"$USER.json\" \"https://api.github.com/users/$USER\"\n    if [[ ! -s \"$USER.json\" ]]; then\n        echo \"Someting went wrong getting https://api.github.cm/users/${USER}\"\n        exit 1\n    fi\n\n    GISTS_URL=$(jq \".gists_url\" \"$USER.json\" | sed -E 's/\"//g' | cut -d '{' -f 1)\n    curl -o gists.json \"${GISTS_URL}\"\n    if [[ ! -s gists.json ]]; then\n        echo \"Someting went wrong getting ${GISTS_URL}\"\n        exit 1\n    fi\n\n    # For each gist harvest our file\n    jsonrange -i gists.json | while read I; do\n        GIST_ID=$(jq \".[$I].id\" gists.json | sed -E 's/\"//g')\n        mkdir -p \"gists/$GIST_ID\"\n        echo \"Saving gists/$GIST_ID/metadata.json\"\n        jq \".[$I]\" gists.json > \"gists/$GIST_ID/metadata.json\"\n        jq \".[$I].files\" gists.json | jsonrange -i - | while read FNAME; do\n            URL=$(jq \".[$I].files[\\\"$FNAME\\\"].raw_url\" gists.json | sed -E 's/\"//g')\n            echo \"Saving gist/$GIST_ID/$FNAME\"\n            curl -o \"gists/$GIST_ID/$FNAME\" \"$URL\"\n        done;\n    done\n```\n\n\n\n\n\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2017, R. S. Doiel",
        "date": "2017-12-10",
        "keywords": [
          "GitHub",
          "Gists",
          "JSON"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Harvesting my Gists from GitHub"
      },
      "url": "posts/2017/12/10/harvesting-my-gists-from-github.json"
    },
    {
      "content": "\n\n# Raspbian Stretch on DELL E4310 Laptop\n\nby R. S. Doiel 2017-12-18\n\nToday I bought a used Dell E4310 laptop. The E4310 is an \"old model\" now\nbut certainly not vintage yet.  It has a nice keyboard and reasonable \nscreen size and resolution. I bought it as a writing machine. I mostly\nwrite in Markdown or Fountain depending on what I am writing these days.\n\n## Getting the laptop setup\n\nThe machine came with a minimal bootable Windows 7 CD and an blank \ninternal drive. Windows 7 installed fine but was missing the network \ndrivers for WiFi.  I had previously copied the new [Raspbian Stretch](https://www.raspberrypi.org/blog/raspbian-stretch/) ISO to a USB drive. While\nthe E4310 didn't support booting from the USB drive Windows 7 does make\nit easy to write to a DVRW. After digging around and finding a blank disc\nI could write to it was a couple of mouse clicks and a bit of waiting \nand I had new bootable Raspbian Stretch CD.\n\nBooting from the Raspbian Stretch CD worked like a charm. I selected \nthe graphical install which worked well though initially the trackpad \nwasn't visible so I just used keyboard navigation to setup the install.\nAfter the installation was complete and I rebooted without the install\ndisc everything worked except the internal WiFi adapter.\n\nI had several WiFi dongles that I use with my Raspberry Pis so I \nborrowed one and with that was able to run the usual `sudo apt update \n&& sudo apt upgrade`.\n\nWhile waiting for the updates I did a little web searching and found \nwhat I needed to know on the Debian Wiki (see\nhttps://wiki.debian.org/iwlwifi?action=show&redirect=iwlagn).  Following\nthe instructions for *Debian 9 \"Stretch\"* ---\n\n```shell\n    sudo vi /etc/apt/sources.list.d/non-free.list \n    # adding the deb source line from the web page\n    sudo apt update && sudo apt install fireware-iwlwifi\n    sudo modprobe -r iwlwifi; sudo modprobe iwlwifi\n    sudo shutdown -r now\n```\n\nAfter that everything came up fine.\n\n## First Impressions\n\nFirst, I like Raspbian Pixel. It was fun on my Pi but on an Intel box\nwith 4Gig RAM it is wicked fast.  Pixel is currently my favorite flavor \nof Debian GNU/Linux. It is simple, minimal with a consistent UI for \nan X based system. Quite lovely. \n\nIf you've got an old laptop you'd like to breath some life into \nRaspbian Stretch is the way to go.\n\n\n### steps for my install process\n\n+ Booted from a minimal Windows 7 CD to get a basic OS minus networking\n+ Used Windows 7 and the internal DVD-RW to create a Raspbian Stretch CD\n+ Booted from the Raspbian Stretch CD and installed Raspbian replacing Windows 7\n+ Used a spare WiFi dongle initially to fetch the non-free iwlwifi modules\n+ Updated my source list, re-run apt update and upgrade\n+ Rebooted and everything came up and is running\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2017, R. S. Doiel",
        "date": "2017-12-18",
        "keywords": [
          "Raspbian",
          "Raspberry Pi OS",
          "amd64",
          "i386",
          "operating systems"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Raspbian Stretch on DELL E4310 Laptop"
      },
      "url": "posts/2017/12/18/raspbian-stretch-on-amd64.json"
    },
    {
      "content": "\n\n# Go, Bleve and Library oriented software\n\nBy R. S. Doiel, 2018-02-19\n(updated: 2018-02-22)\n\nIn 2016, Stephen Davison, asked me, \"Why use Go and Blevesearch for\nour library projects?\" After our conversation I wrote up some notes so\nI would remember. It is now 2018 and I am revising these notes. I\nthink our choice paid off.  What follows is the current state of my\nreflection on the background, rational, concerns, and risk mitigation\nstrategies so far for using [Go](https://golang.org) and\n[Blevesearch](https://blevesearch.com) for Caltech Library projects.\n\n## Background\n\nI first came across Go a few years back when it was announced as an\nOpen Source project by Google at an Google I/O event (2012). The\noriginal Go authors were Robert Griesemer, Rob Pike, and Ken\nThompson. What I remember from that presentation was Go was a rather\nconsistent language with the features you need but little else.  Go\ndeveloped at Google as a response to high development costs for C/C++\nand Java in addition to challenges with performance and slow\ncompilation times.  As a language I would put Go between C/C++ and\nJava. It comes the ease of writing and reading you find in languages\nlike Python. Syntax is firmly in the C/C++ family but heavily\nsimplified. Like Java it provides many modern features including rich basic\ndata structures and garbage collection. It has a very complete standard\nlibrary and provides very good tooling.  This makes it easy to\ngenerate code level documentation, format code, test, efficiently profile, \nand debug.\n\nOften programming languages develop around a specific set of needs.\nThis is true for Go. Given the Google origin it should not be\nsurprising to find that Go's primary strengths are working with \nstructured data, I/O and concurrency. The rich standard\nlibrary is organized around a package concept. These include packages\nsupporting network protocols, file and socket I/O as well as various\nencoding and compression scheme. It has particularly strong support\nfor XML, JSON, CSV formatted data out of the box. It has a template\nlibrary for working with plain text formats as well as generating safe\nHTML. You can browse Go's standard library https://golang.org/pkg/.\n\nAn additional feature is Go's consistency. Go code that compiles under\nversion 1.0 still compiles under 1.10. Even before 1.0 code changes\nthat were breaking came with tooling to automatically updates existing\ncode.  Running code is a strong element of Go's evolution.\n\nGo is unsurprising and has even been called boring.  This turns out to\nbe a strength when building sustainable projects in a small team.\n\n\n## Why do I write Go?\n\nFor me Go is a good way to write web services, assemble websites,\ncreate search appliances and write command line (cli) utilities. When\na shell script becomes unwieldy Go is often what I turn to.  Go is\nwell suited to building tools as well as systems.  Go based command\nline tools are very easy to orchestrate with shell and Python.\n\nGo runs on all the platforms I actively use - Windows, Mac OS X, Linux\non both Intel and ARM (e.g. Raspberry Pi, Pine64). It has experimental\nsupport for Android and iOS.  I've used a tool called\n[GopherJS](http://gopherjs.org) to write web browser applications that\ntransform my command line tools into web tools with a friendlier user\ninterface (see our [BibTeX Tools](https://caltechlibrary.github.io/bibtex/webapp/)).\n\nGo supports cross compiling out of the box. This means a production\nsystem running on AWS, Google's compute engine or Microsoft's Azure\ncan be compiled from Windows, Mac OS or even a Raspberry Pi!\nDeployment is a matter of copying the (self contained) compiled binary\nonto the production system. This contrasts with other\nplatforms like Perl, PHP, Python, NodeJS and Ruby where you need to\ninstall not only your application code but all dependencies. While\ninterpretive languages retain an advantage of having a REPL, Go\nbased programs have advantages of fast compile times and easy deployment.\n\nIn many of the projects I've written in Go I've only required a few\n(if any) 3rd party libraries (packages in Go's nomenclature). This is\nquite a bit different from my experience with Perl, PHP, Python,\nNodeJS and Ruby. This is in large part a legacy of having grown up at\nGoogle before become an open source project. While the Go standard\npackages are very good there is a rich ecosystem for 3rd party\npackages for specialized needs. I've found I tend to rely only on a\nfew of them. The one I've used the most is\n[Bleve](http://blevesearch.com).\n\nBleve is a Go package for building search engines. When I originally\ncame across Bleve (around 2014), it was described as \"Lucene lite\". \n\"Lucene lite\" was an apt description, but I find it easier\nto use than Lucene. When I first used Bleve I embedded its\nfunctionality into the tools I used to process data and present web\nservices. It did not have much in the way of stand alone command line\ntooling.  Today I increasingly think of Bleve as \"Elastic Search\nlite\". It ships with a set of command line tools that include support\nfor building Bleve's indexes.  My current practice is to only embed the search\nportion of the packages. I can use the Bleve command line for the\nrest.  In 2018, Bleve is being actively developed, has a small vibrant\ncommunity and is used by [Couchbase](https://couchbase.com), a well\nestablished NoSQL player.\n\n\n## Who is using Go?\n\nMany companies use Go. The short list includes\nGoogle, Amazon, Netflix, Dropbox, Box, eBay, Pearsons and even\nWalmart and Microsoft. This came to my attention at developer conferences\nback in 2014.  People from many of these companies started\npresenting at conferences on pilot projects that had been successful\nand moved to production. Part of what drove adoption was the ease\nof development in Go along with good system performance. I also think\nthere was a growing disenchantment with alternatives like C++, C sharp\nand Java as well as the weight of the LAMP, Tomcat, and OpenStack.\n\nHighly visible Go based projects include\n\n+ [Docker](http://docker.org) and [Rocket](http://www.docker.com) - Containerization for running process in the cloud\n+ [Kubernettes](http://kubernetes.io/) and [Terraform](https://www.terraform.io/) - Container orchestration systems\n+ [Hugo](http://hugo.io) - the fast/popular static website generator, an alternative to Jekyll, for those who want speed\n+ [Caddy](https://caddyserver.com/) - a Go based web server trying to unseat Apache/NGinX focusing on easy of use plus speed\n+ [IPFS](http://ipfs.io) - a cutting edge distributed storage system based on block chains\n\n\n### Who is using Blevesearch?\n\nHere's some larger projects using Bleve.\n\n+ [Couchbase](http://www.couchbase.com), a NoSQL database platform are replacing Lucene with Bleve.  Currently the creator of Bleve works for them.\n+ [Hugo](http://hugo.io) can integrate with Bleve for search and index generation\n+ [Caddy](https://caddyserver.com/) integrates with Bleve to provide an embedded search capability\n\n\n## Managing risks\n\nIn 2014 Go was moving from bleeding to leading edge. Serious capital\nwas behind its adoption and it stopped being an exotic conference\nitem. In 2014 Bleve was definitely bleeding edge. By late 2015 and early\n2016 the program level API stabilized. People were piloting projects\nwith it. This included our small group at Caltech Library. In 2015\nnon-English language support appeared followed by a growing list\nof non-European languages in 2016. By mid 2016 we started to see \nmissing features like alternative sorting added. While Bleve isn't\nyet 1.0 (Feb. 2018) it is reliable. The primary challenge for the Bleve\nproject is documentation targeting the novice and non-Programmer users.\nBleve has proven effective as an indexing and search platform for \narchival, library, and data repository content.\n\nAdopting new software comes with risk. We have mitigated this in two ways.\n\n1. Identify alternative technology (a plan B)\n2. Architect our systems for easy decomposition and re-composition\n\nIn the case of Go, packages can be compiled to a C-Shared\nlibrary. This allows us to share working Go packages with languages\nlike Python, R, and PHP. We have included shared Go/Python modules\non our current road map for projects.\n\nFor Blevesearch the two alternatives are Solr and Elastic\nSearch. Both are well known, documented, and solid.  The costs would be\nrecommitting to a Java stack and its resource requirements. We have\nalready identified what we want to index and that could be converted\nto either platform if needed.  If we stick with Go but dropped \nBlevesearch we would swap out the Bleve specific code for Go packages \nsupporting Solr and Elastic Search.\n\n\nThe greatest risk in adopting Go for library and archive projects was \nknowledge transfer. We addressed this \nby knowledge sharing and insuring the Go codebase can \nbe used via command line programs.  Additionally \nwe are adding support for Go based Python modules.\nTraining also is available in the form of books, websites and\nonline courses ([lynda.com](https://www.lynda.com/Go-tutorials/Up-Running-Go/412378-2.html) offers a \"Up Running Go\" course).\n\n\n## What are the benefits?\n\nFor library and archives software we have found Go's benefits include\nimproved back end systems performance at a lower cost, ease of development, \nease of deployment, a rich standard library focused on the types of things \nneeded in library and archival software.  Go plays nice with\nother systems (e.g. I create an API based service in Go that can easily\nbe consumed by a web browser running JavaScript or Perl/PHP/Python\ncode running under LAMP). In the library and archives setting Go \ncan become a high performance duck tape. We get the performance and \nreliability of C/Java type systems with code simplicity \nsimilar to Python.\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2018, R. S. Doiel",
        "date": "2018-02-19",
        "keywords": [
          "Golang",
          "Bleve",
          "search"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Go, Bleve and Library oriented software"
      },
      "url": "posts/2018/02/19/go-bleve-and-libraries.json"
    },
    {
      "content": "\n\n# Go based Python modules\n\nBy R. S. Doiel, 2018-02-24\n\nThe problem: I have written a number of Go packages at work.\nMy colleagues know Python and I'd like them to be able to use the\npackages without resorting to system calls from Python to the\ncommand line implementations. The solution is create a C-Shared\nlibrary from my Go packages, using Go's _C_ package and combine it\nwith Python's _ctypes_ package.  What follows is a series of \nsimple recipes I used to understand the details of how that worked.\n\n\n## Example 1, libtwice.go and twice.py\n\nMany of the the examples I've come across on the web start by \nshowing how to run a simple math operation on the Go side with\nnumeric values traveling round trip via the C shared library layer. \nIt is a good place to start as you only need to consider type \nconversion between both Python's runtime and Go's runtime.  It \nprovides a simple illustration of how the Go *C* package, Python's\n*ctypes* module and the toolchain work together.\n\nIn this example we have a function in Go called \"twice\" it takes\na single integer, doubles it and returns the new value.  On\nthe Go side we create a _libtwice.go_ file with an empty `main()` \nfunction.  Notice that we also import the *C* package and use \na comment decoration to indicate the function we are exporting\n(see https://github.com/golang/go/wiki/cgo and \nhttps://golang.org/cmd/cgo/\nfor full story about Go's _C_ package and _cgo_).\nPart of the what _cgo_ and the *C* package does is use the \ncomment decoration to build the signatures for the function calls\nin the shared C library.  The Go toolchain does all the heavy \nlifting in making a *C* shared library based on comment \ndirectives like \"//export\". We don't need much for our twice\nfunction.\n\n```Go\n    package main\n    \n    import (\n    \t\"C\"\n    )\n    \n    //export twice\n    func twice(i int) int {\n    \treturn i * 2\n    }\n    \n    func main() {}\n```\n\nOn the python side we need to wrap our calls to our shared library\nbringing them into the Python runtime in a useful and idiomatically\nPython way. Python provides a few ways of doing this. In my examples\nI am using the *ctypes* package.  _twice.py_ looks like this--\n\n```python\n    import ctypes\n    import os\n    \n    # Set our shared library's name\n    lib_name='libtwice'\n    \n    # Figure out shared library extension\n    uname = os.uname().sysname\n    ext = '.so'\n    if uname == 'Darwin':\n        ext = '.dylib'\n    if uname == 'Windows':\n        ext = '.dll'\n    \n    # Find our shared library and load it\n    dir_path = os.path.dirname(os.path.realpath(__file__))\n    lib = ctypes.cdll.LoadLibrary(os.path.join(dir_path, lib_name+ext))\n    \n    # Setup our Go functions to be nicely wrapped\n    go_twice = lib.twice\n    go_twice.argtypes = [ctypes.c_int]\n    go_twice.restype = ctypes.c_int\n    \n    # Now write our Python idiomatic function\n    def twice(i):\n        return go_twice(ctypes.c_int(i))\n    \n    # We run this test code if with: python3 twice.py\n    if __name__ == '__main__':\n        print(\"Twice of 2 is\", twice(2))\n```\n\nNotice the amount of lifting Python's *ctypes* does for us. It provides\nfor converting C based types to their Python counter parts. Indeed the\nadditional Python source here is focused around using that functionality\nto create a simple Python function called twice. This pattern of \nbringing in a low level version of our desired function and then \npresenting in a Pythonic one is common in more complex C based Python\nmodules.  In general we need *ctypes* to access and wrapping our \nshared library. The *os* module is used so we can find our C \nshared library based on the naming conventions of our host OS. \nFor simplicity I've kept the shared library (e.g. _libtwice.so_ \nunder Linux) in the same directory as the python module \ncode _twice.py_.\n\nThe build command for Linux looks like---\n\n```shell\n    go build -buildmode=c-shared -o libtwice.so libtwice.go\n```\n\nUnder Windows it would look like---\n\n```shell\n    go build -buildmode=c-shared -o libtwice.dll libtwice.go\n```\n\nand Mac OS X---\n\n```shell\n    go build -buildmode=c-shared -o libtwice.dynlib libtwice.go\n```\n\nYou can test the Python module with---\n\n```shell\n    python3 twice.py\n```\n\nNotice the filename choices. I could have called the Go shared\nlibrary anything as long as it wasn't called `twice.so`, `twice.dll`\nor `twice.dylib`. This constraint is to avoid a module name collision\nin Python.  If we had a Python script named `twice_test.py` and \nimport `twice.py` then Python needs to make a distinction between\n`twice.py` and our shared library. If you use a Python package\napproach to wrapping the shared library you would have other options\nfor voiding name collision.\n\nHere is an example of `twice_test.py` to make sure out import is\nworking.\n\n```python\n    import twice\n    print(\"Twice 3\", twice.twice(3))\n```\n\nExample 1 is our base recipe. The next examples focus on handling\nother data types but follow the same pattern.\n\n\n## Example 2, libsayhi.go and sayhi.py\n\nI found working with strings a little more nuanced. Go's concept of\nstrings are oriented to utf-8. Python has its own concept of strings \nand encoding.  Both need to pass through the C layer which assumes \nstrings are a char pointer pointing at contiguous memory ending \nin a null. The *sayhi* recipe is focused on moving a string from \nPython, to C, to Go (a one way trip this time). The example uses \nGo's *fmt* package to display the string. \n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"fmt\"\n    )\n    \n    //export say_hi\n    func say_hi(msg *C.char) {\n    \tfmt.Println(C.GoString(msg))\n    }\n    \n    func main() { }\n```\n\nThe Go source is similar to our first recipe but our Python modules\nneeds to use *ctypes* to get you Python string into shape to be\nunpacked by Go.\n\n```python\n   import ctypes\n   import os\n   \n   # Set the name of our shared library\n   lib_name = 'libsayhi'\n\n   # Figure out shared library extension\n   uname = os.uname().sysname\n   ext = '.so'\n   if uname == 'Darwin':\n       ext = '.dylib'\n   if uname == 'Windows':\n       ext = '.dll'\n   \n   # Find our shared library and load it\n   dir_path = os.path.dirname(os.path.realpath(__file__))\n   lib = ctypes.cdll.LoadLibrary(os.path.join(dir_path, lib_name+ext))\n   \n   # Setup our Go functions to be nicely wrapped\n   go_say_hi = lib.say_hi\n   go_say_hi.argtypes = [ctypes.c_char_p]\n   # NOTE: we don't have a return type defined here, the message is \n   # displayed from Go\n   \n   # Now write our Python idiomatic function\n   def say_hi(txt):\n       return go_say_hi(ctypes.c_char_p(txt.encode('utf8')))\n   \n   if __name__ == '__main__':\n       say_hi('Hello!')\n```\n\nPutting things together (if you are using Windows or Mac OS X\nyou'll adjust name output name, `libsayhi.so`, to match the\nfilename extension suitable for your operating system).\n\n```bash\n    go build -buildmode=c-shared -o libsayhi.so libsayhi.go\n```\n\nand testing.\n\n```bash\n    python3 sayhi.py\n```\n\n\n## Example 3, libhelloworld.go and helloworld.py\n\nIn this example we send a Python string to Go (which expects utf-8)\nbuild our \"hello world\" message and then send it back to Python\n(which needs to do additional conversion and decoding).\n\nLike in previous examples the Go side remains very simple. The heavy\nlifting is done by the *C* package and the comment `//export`. We\nare using `C.GoString()` and `C.CString()` to flip between our native\nGo and C datatypes.\n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"fmt\"\n    )\n    \n    //export helloworld\n    func helloworld(name *C.char) *C.char {\n    \ttxt := fmt.Sprintf(\"Hello %s\", C.GoString(name))\n    \treturn C.CString(txt)\n    }\n    \n    func main() { }\n```\n\nIn the python code below the conversion process is much more detailed.\nPython isn't explicitly utf-8 like Go. Plus we're sending our Python \nstring via C's char arrays (or pointer to chars). Finally when we \ncomeback from Go via C we have to put things back in order for Python. \nOf particular note is checking how the byte arrays work then \nencoding/decoding everything as needed. We also explicitly set the result \ntype from our Go version of the helloworld function.\n\n```python\n    import ctypes\n    import os\n    \n    # Set the name of our shared library\n    lib_name = 'libhelloworld'\n\n    # Figure out shared library extension\n    uname = os.uname().sysname\n    ext = '.so'\n    if uname == 'Darwin':\n        ext = '.dylib'\n    if uname == 'Windows':\n        ext = '.dll'\n    \n    # Find our shared library and load it\n    dir_path = os.path.dirname(os.path.realpath(__file__))\n    lib = ctypes.cdll.LoadLibrary(os.path.join(dir_path, lib_name+ext))\n    \n    # Setup our Go functions to be nicely wrapped\n    go_helloworld = lib.helloworld\n    go_helloworld.argtypes = [ctypes.c_char_p]\n    go_helloworld.restype = ctypes.c_char_p\n    \n    # Now write our Python idiomatic function\n    def helloworld(txt):\n        value = go_helloworld(ctypes.c_char_p(txt.encode('utf8')))\n        if not isinstance(value, bytes):\n            value = value.encode('utf-8')\n        return value.decode()\n    \n    \n    if __name__ == '__main__':\n        import sys\n        if len(sys.argv) > 1:\n            print(helloworld(sys.argv[1]))\n        else:\n            print(helloworld('World'))\n```\n\nThe build recipe remains the same as the two previous examples.\n\n```bash\n    go build -buildmode=c-shared -o libhelloworld.so libhelloworld.go\n```\n\nHere are two variations to test.\n\n```bash\n     python3 helloworld.py\n     python3 helloworld.py Jane\n```\n\n\n## Example 4, libjsonpretty.go and jsonpretty.py\n\nIn this example we send JSON encode text to the Go package,\nunpack it in Go's runtime and repack it using the `MarshalIndent()`\nfunction in Go's JSON package before sending it back as Python\nin string form.  You'll see the same encode/decode patterns as \nin our *helloworld* example.\n\nGo code\n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"encoding/json\"\n    \t\"fmt\"\n    \t\"log\"\n    )\n    \n    //export jsonpretty\n    func jsonpretty(rawSrc *C.char) *C.char {\n    \tdata := new(map[string]interface{})\n    \terr := json.Unmarshal([]byte(C.GoString(rawSrc)), &data)\n    \tif err != nil {\n    \t\tlog.Printf(\"%s\", err)\n    \t\treturn C.CString(\"\")\n    \t}\n    \tsrc, err := json.MarshalIndent(data, \"\", \"    \")\n    \tif err != nil {\n    \t\tlog.Printf(\"%s\", err)\n    \t\treturn C.CString(\"\")\n    \t}\n    \ttxt := fmt.Sprintf(\"%s\", src)\n    \treturn C.CString(txt)\n    }\n    \n    func main() {}\n```\n\nPython code\n\n```python\n    import ctypes\n    import os\n    import json\n    \n    # Set the name of our shared library\n    lib_name = 'libjsonpretty'\n\n    # Figure out shared library extension\n    uname = os.uname().sysname\n    ext = '.so'\n    if uname == 'Darwin':\n        ext = '.dylib'\n    if uname == 'Windows':\n        ext = '.dll'\n\n    dir_path = os.path.dirname(os.path.realpath(__file__))\n    lib = ctypes.cdll.LoadLibrary(os.path.join(dir_path, lib_name+ext))\n    \n    go_jsonpretty = lib.jsonpretty\n    go_jsonpretty.argtypes = [ctypes.c_char_p]\n    go_jsonpretty.restype = ctypes.c_char_p\n    \n    def jsonpretty(txt):\n        value = go_jsonpretty(ctypes.c_char_p(txt.encode('utf8')))\n        if not isinstance(value, bytes):\n            value = value.encode('utf-8')\n        return value.decode()\n    \n    if __name__ == '__main__':\n        src = '''\n    {\"name\":\"fred\",\"age\":25,\"height\":75,\"units\":\"inch\",\"weight\":\"239\"}\n    '''\n        value = jsonpretty(src)\n        print(\"Pretty print\")\n        print(value)\n        print(\"Decode into dict\")\n        o = json.loads(value)\n        print(o)\n```\n\nBuild command\n\n```shell\n    go build -buildmode=c-shared -o libjsonpretty.so libjsonpretty.go\n```\n\nAs before you can run your tests with `python3 jsonpretty.py`.\n\nIn closing I would like to note that to use these examples you Python3\nwill need to be able to find the module and shared library. For \nsimplicity I've put all the code in the same directory. If your Python\ncode is spread across multiple directories you'll need to make some \nadjustments.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2018, R. S. Doiel",
        "date": "2018-02-24",
        "keywords": [
          "Golang",
          "Python",
          "shared libraries"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Go based Python modules"
      },
      "url": "posts/2018/02/24/go-based-python-modules.json"
    },
    {
      "content": "\n\n# Accessing Go from Julia\n\nBy R. S. Doiel, 2018-03-11\n\nThe problem: I've started exploring Julia and I would like to leverage existing\ncode I've written in Go. Essentially this is a revisit to the problem in my\nlast post [Go based Python Modules](https://rsdoiel.github.io/blog/2018/02/24/go-based-python-modules.html) \nbut with the language pairing of Go and Julia.\n\n\n## Example 1, libtwice.go, libtwice.jl and libtwice_test.jl\n\nIn out first example we send an integer value from\nJulia to Go and back via a C shared library (written in Go). While Julia doesn't\nrequire type declarations I will be using those for clarity. Like in my previous post\nI think this implementation this is a good starting point to see how Julia interacts with\nC shared libraries. Like before I will present our Go code, an explanation \nfollowed by the Julia code and commentary.\n\nOn the Go side we create a _libtwice.go_ file with an empty `main()` \nfunction.  Notice that we also import the *C* package and use \na comment decoration to indicate the function we are exporting\n(see https://github.com/golang/go/wiki/cgo and \nhttps://golang.org/cmd/cgo/\nfor full story about Go's _C_ package and _cgo_).\nPart of the what _cgo_ and the *C* package does is use the \ncomment decoration to build the signatures for the function calls\nin the shared C library.  The Go toolchain does all the heavy \nlifting in making a *C* shared library based on comment \ndirectives like \"//export\". We don't need much for our twice\nfunction.\n\n```Go\n    package main\n    \n    import (\n    \t\"C\"\n    )\n    \n    //export twice\n    func twice(i int) int {\n    \treturn i * 2\n    }\n    \n    func main() {}\n```\n\nLike in our previous Python implementation we need to build the C shared\nlibrary before using it from Julia. Here are some example Go build commands\nfor Linux, Windows and Mac OS X. You only need to run the one that applies\nto your operating system.\n\n```shell\n    go build -buildmode=c-shared -o libtwice.so libtwice.go\n    go build -buildmode=c-shared -o libtwice.dll libtwice.go\n    go build -buildmode=c-shared -o libtwice.dynlib libtwice.go\n```\n\nUnlike the Python implementation our Julia code will be split into two files. _libtwice.jl_ will\nhold our module definition and _libtwice_test.jl_ will hold our test code. In the\ncase of _libtwice.jl_ we will access the C exported function via a function named *ccall*. \nJulia doesn't require a separate module to be imported in order to access a C shared library.\nThat makes our module much simpler. We still need to be mindful of type conversion.  Both \nGo and Julia provide for rich data types and structs.  But between Go and Julia we have C \nand C's basic type system.  On the Julia side *ccall* and Julia's type system help us\nmanaging C's limitations.\n\nHere's the Julia module we'll call _libtwice.jl_.\n\n```Julia\n    module libtwice\n            \n    # We write our Julia idiomatic function\n    function twice(i::Integer)\n        ccall((:twice, \"./libtwice\"), Int32, (Int32,), i)\n    end\n\n    end\n```\n\nWe're will put the test code in a file named _libtwice\\_test.jl_. Since this isn't\nan establish \"Package\" in Julia we will use Julia's *include* statement to get bring the\ncode in then use an *import* statement to bring the module into our current name space.\n\n```Julia\n    include(\"libtwice.jl\")\n    import libtwice\n    # We run this test code for libtwice.jl\n    println(\"Twice of 2 is \", libtwice.twice(2))\n```\n\nOur test code can be run with\n\n```shell\n    julia libtwice_test.jl\n```\n\nNotice the amount of lifting that Julia's *ccall* does. The Julia code is much more compact\nas a result of not having to map values in a variable declaration. We still have the challenges \nthat Julia and Go both support richer types than C. In a practical case we should consider \nthe over head of running to two runtimes (Go's and Julia's) as well as whether or not \nimplementing as a shared library even makes sense. But if you want to leverage existing \nGo based code this approach can be useful.\n\nExample 1 is our base recipe. The next examples focus on handling\nother data types but follow the same pattern.\n\n\n## Example 2, libsayhi.go, libsayhi.jl and libsayhi_test.jl\n\nLike Python, passing strings passing to or from Julia and Go is nuanced. Go is expecting \nUTF-8 strings. Julia also supports UTF-8 but C still looks at strings as a pointer to an\naddress space that ends in a null value. Fortunately in Julia the *ccall* function combined with\nJulia's rich type system gives us straight forward ways to map those value. \nGo code remains unchanged from our Python example in the previous post. \nIn this example we use Go's *fmt* package to display the string. In the next example\nwe will round trip our string message.\n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"fmt\"\n    )\n    \n    //export say_hi\n    func say_hi(msg *C.char) {\n    \tfmt.Println(C.GoString(msg))\n    }\n    \n    func main() { }\n```\n\nThe Go source is the similar to our first recipe. No change from our\nprevious posts' Python example. It will need to be compiled to create our\nC shared library just as before. Run the go build line that applies to\nyour operating system (i.e., Linux, Windows and Mac OS X).\n\n```shell\n    go build -buildmode=c-shared -o libsayhi.so libsayhi.go\n    go build -buildmode=c-shared -o libsayhi.dll libsayhi.go\n    go build -buildmode=c-shared -o libsayhi.dylib libsayhi.go\n```\n\nOur Julia module looks like this.\n\n```julia\n    module libsayhi\n\n    # Now write our Julia idiomatic function using *ccall* to access the shared library\n    function say_hi(txt::AbstractString)\n        ccall((:say_hi, \"./libsayhi\"), Int32, (Cstring,), txt)\n    end\n\n    end\n```\n\nThis code is much more compact than our Python implementation.\n\nOur test code looks like\n\n```julia\n    include(\"./libsayhi.jl\")\n    import libsayhi\n    libsayhi.say_hi(\"Hello again!\")\n```\n\nWe run our tests with\n\n```shell\n    julia libsayhi_test.jl\n```\n\n\n## Example 3, libhelloworld.go and librhelloworld.cl and libhelloworld_test.jl\n\nIn this example we send a string round trip between Julia and Go. \nMost of the boiler plate we say in Python is gone due to Julia's type system. In\naddition to using Julia's *ccall* we'll add a *convert* and *bytestring* function calls\nto bring our __Cstring__ back to a __UTF8String__ in Julia.\n\nThe Go implementation remains unchanged from our previous Go/Python implementation. \nThe heavy lifting is done by the *C* package and the comment \n`//export`. We are using `C.GoString()` and `C.CString()` to flip between \nour native\nGo and C datatypes.\n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"fmt\"\n    )\n    \n    //export helloworld\n    func helloworld(name *C.char) *C.char {\n    \ttxt := fmt.Sprintf(\"Hello %s\", C.GoString(name))\n    \treturn C.CString(txt)\n    }\n    \n    func main() { }\n```\n\nAs always we must build our C shared library from the Go code. Below is\nthe go build commands for Linux, Windows and Mac OS X. Pick the line that\napplies to your operating system to build the C shared library.\n\n```shell\n    go build -buildmode=c-shared -o libhelloworld.so libhelloworld.go\n    go build -buildmode=c-shared -o libhelloworld.dll libhelloworld.go\n    go build -buildmode=c-shared -o libhelloworld.dylib libhelloworld.go\n```\n\nIn our Julia, _libhelloworld.jl_, the heavy lifting of type conversion\nhappens in Julia's type system and in the *ccall* function call. Additionally we need\nto handle the conversion from __Cstring__ Julian type to __UTF8String__ explicitly\nin our return value via a functions named *convert* and *bytestring*.\n\n```julia\n    module libhelloworld\n\n    # Now write our Julia idiomatic function\n    function helloworld(txt::AbstractString)\n        value = ccall((:helloworld, \"./libhelloworld\"), Cstring, (Cstring,), txt)\n        convert(UTF8String, bytestring(value))\n    end\n\n    end\n```\n\nOur test code looks similar to our Python test implementation.\n\n```julia\n    include(\"libhelloworld.jl\")\n    import libhelloworld\n \n    if length(ARGS) > 0\n        println(libhelloworld.helloworld(join(ARGS, \" \")))\n    else\n        println(libhelloworld.helloworld(\"World\"))\n    end\n```\n\nAs before we see the Julia code is much more compact than Python's.\n\n\n## Example 4, libjsonpretty.go, libjsonpretty.jl and libjsonpretty_test.jl\n\nIn this example we send JSON encode text to the Go package,\nunpack it in Go's runtime and repack it using the `MarshalIndent()`\nfunction in Go's JSON package before sending it back to Julia\nin C string form.  You'll see the same encode/decode patterns as \nin our *libhelloworld* example.\n\nGo code\n\n```go\n    package main\n    \n    import (\n    \t\"C\"\n    \t\"encoding/json\"\n    \t\"fmt\"\n    \t\"log\"\n    )\n    \n    //export jsonpretty\n    func jsonpretty(rawSrc *C.char) *C.char {\n    \tdata := new(map[string]interface{})\n    \terr := json.Unmarshal([]byte(C.GoString(rawSrc)), &data)\n    \tif err != nil {\n    \t\tlog.Printf(\"%s\", err)\n    \t\treturn C.CString(\"\")\n    \t}\n    \tsrc, err := json.MarshalIndent(data, \"\", \"    \")\n    \tif err != nil {\n    \t\tlog.Printf(\"%s\", err)\n    \t\treturn C.CString(\"\")\n    \t}\n    \ttxt := fmt.Sprintf(\"%s\", src)\n    \treturn C.CString(txt)\n    }\n    \n    func main() {}\n```\n\nBuild commands for Linux, Windows and Mac OS X are as before, pick the one that matches\nyour operating system.\n\n```shell\n    go build -buildmode=c-shared -o libjsonpretty.so libjsonpretty.go\n    go build -buildmode=c-shared -o libjsonpretty.dll libjsonpretty.go\n    go build -buildmode=c-shared -o libjsonpretty.dylib libjsonpretty.go\n```\n\nOur Julia module code\n\n```Julia\n    module libjsonpretty\n\n    # Now write our Julia idiomatic function\n    function jsonpretty(txt::AbstractString)\n        value = ccall((:jsonpretty, \"./libjsonpretty\"), Cstring, (Cstring,), txt)\n        convert(UTF8String, bytestring(value))\n    end\n    \n    end\n```\n\nOur Julia test code\n\n```Julia\n    include(\"./libjsonpretty.jl\")\n    import libjsonpretty\n\n    src = \"\"\"{\"name\":\"fred\",\"age\":25,\"height\":75,\"units\":\"inch\",\"weight\":\"239\"}\"\"\"\n    println(\"Our origin JSON src\", src)\n    value = libjsonpretty.jsonpretty(src)\n    println(\"And out pretty version\\n\", value)\n```\n\nAs before you can run your tests with `julia libjsonpretty_test.jl`.\n\nIn closing I would like to note that to use these examples I am assuming your\nJulia code is in the same directory as your shared C library. Julia, like Python3,\nhas a feature rich module and Package system. If you are creating a serious Julia\nproject then you need to be familiar with how Julia's package and module system works\nand place your code and shared libraries appropriately.\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2018, R. S. Doiel",
        "date": "2018-03-11",
        "keywords": [
          "Golang",
          "Julia",
          "shared libraries"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Accessing Go from Julia"
      },
      "url": "posts/2018/03/11/accessing-go-from-julia.json"
    },
    {
      "content": "\n\n# Review: Software Tools in Pascal\n\nBy R. S. Doiel, 2018-07-22\n(updated: 2018-07-22, 1:39 pm, PDT)\n\n\nThis book is by Brian W. Kernighan and P. J. Plauger. It is an\nexample of the type of books I find I re-read and want in my\npersonal library. The book covers software construction through \na series of programs written in pascal. It is about how these \nprograms work, how to approach problems and write sound software.\nI was surprised I did not know about this book when I was browsing \nthe [Open Library](https://openlibrary.org) this weekend.  While \nPascal was a popular in the 1980's it has faded for most people in the \nearly 21st century.  This review maybe a small bit of nostalgia. \nOn the other hand I suspect \n[\"Software Tools in Pascal\"](https://openlibrary.org/books/OL4258115M/Software_tools_in_Pascal)\nis one of the short list of computer books that will remain useful\nover the long run.\n\n\n## What's covered\n\nThe book is organized around specific programs and their implementations.\nThe implementations provided are simple and straight forward. Each\nsection is followed by a set of \"exercises\" that extend the ideas\nshown in the section. In this way you could derive the modern equivalent\nof these tools.\n\nThe topics you build tools for in the text are\nfilters, files, sorting, text patterns, editing, formatting, \nand macro processing.\n\nIf you want to follow the book along in Pascal then I think Free Pascal\navailable in many Debian distributions including Raspbian on the Raspberry\nPi is a good choice.  Likewise Wirth's Pascal is easy enough to port\nto other languages and indeed this would be a useful exercise when I\nre-read the book the next time.\n\nThe book presents a very nice set of text oriented programs to explore\nprogramming or re-connect with your programming roots.\n\n## Read the book\n\n<iframe width=\"165\" frameBorder=\"0\" height=\"400\" src=\"https://openlibrary.org/books/OL4258115M/Software_tools_in_Pascal/widget\"></iframe>\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2018, R. S. Doiel",
        "date": "2018-07-22",
        "keywords": [
          "Pascal",
          "programming",
          "book review"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Review: Software Tools in Pascal"
      },
      "url": "posts/2018/07/22/software-tools-in-pascal.json"
    },
    {
      "content": "\n\nFreeDOS to Oberon System 3\n==========================\n\nBy R. S. Doiel, 2019-07-28\n\n>    UPDATE: (2021-02-26, RSD) Under VirtualBox 6.1 these\n>    instructions still fail. My hope is to revise these \n>    instructions when I get it all sorted out.\n>\n>    Many links such as the ftp site at ETH Oberon are \n>    no more. I've updated this page to point at Wayback machine\n>    or included content in here where I cannot find it else where.\n>\n>    UPDATE: (2021-02-19, RSD) Under VirtualBox 6.1 these instructions \n>    fail. For VirtualBox I’ve used FreeDOS 1.3rc3 Live CD installing \n>    the “Plain DOS” without problems.\n>\n>    UPDATE: (2021-03-16, RSD) After reviewing my post, correcting\n>    some mistakes I finally was able to get FreeDOS up and running\n>    on VirtualBox 6.1. This allows NativeOberon 2.3.6 to be brought\n>    up by booting the \"oberon0.dsk\" virtual floppy and following\n>    the instructions included. You need to know how to use\n>    the Oberon mouse and the way commands work in Oberon.\n\nWhat follows are notes on getting a FreeDOS 1.2[^1] and \nthen Native Oberon[^2] running under VirtualBox 6.0. You might \nwonder why these two are together. While it was\neasy to run the Native Oberon installation process that process\nassumes you have a properly partitioned hard disk and VirtualBox\nseems to skip that process. I found taking advantage of FreeDOS\nsimplified things for me.\n\nMy goal was running Oberon System 3, but setting up a Virtual Box\nwith FreeDOS 1.2 gave me a virtual machine that functions like a \n1999 era PC. From there all the steps in the Oberon instructions\njust worked.\n\n## Creating FreeDOS 1.2 Virtual Box\n\nI've been doing a bit if computer history reading and decided to\nbring up some older systems as a means to understand where\nthings were.  The first computers I had access to were 8080, 8086\nmachines running MS DOS based. My first computer programming language\nwas Turbo Pascal. Feeling a bit nostalgic I thought it would be\ninteresting to use it again and see what I remembered from the days\nof old. While PC and MS DOS no longer exist as commercial productions\nan wonderful group of Open Source hackers have brought new life into\nDOS with FreeDOS 1.2[^3]. You'll find many of your old familiar commands\nbut also some nice improvements. You can even run it under VirtualBox\nwhich is what I proceeded to do.\n\n### VirtualBox 6.0 setup\n\nThe [FreeDOS](https://freedos.org) website includes a CD ROM image\nthat you can use to install it. There are couple small hitches though\nto get it working under VirtualBox. First go to the [download](https://freedos.org/download) page and download the [CDROM \"standard\" installer\"](http://www.freedos.org/download/download/FD12CD.iso).\n\nWhile that is downloading you can setup your VirtualBox machine.\nFirst to remember is DOS compared to today's operating systems is\nfrugal in its hardware requirements. As a result I picked very modest\nsettings for my virtual machine. \n\n1. Launch VirtualBox\n2. From the menu, pick Machine then pick new\n3. Name your machine (e.g. \"FreeDOS 1.2\"), select the type: \"Other\" and Operating system of \"DOS\"\n4. Set memory size as you like, I just accepted the default 32MB\n5. Hard disk, pick \"Create a virtual hard disc now\"\n6. Hard disk file type, pick \"VHD (Virtual Hard Disk)\"\n7. Storage on physical hard disk, I picked Dynamically allocated both either is fine\n8. File location and size, I accepted the default location and size\n9. Before starting my FreeDOS box I made a couple of changes using \"settings\" menu icon\n    a. Display, I picked bumped memory up to 128M and picked VBoxSVGA with 33D acceleration (for games)\n    b. Storage, I added a second floppy drive (empty)\n    c. Network, I picked attached to NAT\n10. When looking at my virtual machine's detail page I clicked on the Optical drive (empty), click \"choose disc image\" and pointed at the downloaded installed CD\n11. Click Start.\n12. At \"Welcome to FreeDOS 1.2\" blue screen, hit TAB key\n13. You will see a line that begins with a boot instruction. Add a space than add the word \"raw\" (without quotes) press enter\n14. Follow the install instructions, when you get to \"Drive C: does not appear to be partitioned\" dialog, pick \"Yes - Partition drive C:\"\n15. On the next screen pick \"Yes - Please reboot now\"\n16. When at the \"Welcome to FreeDOS 1.2\" screen hit TAB again\n17. Once again add a space and type \"raw\" to the command then press enter\n18. Pick \"Yes - continue with the installation\"\n19. Pick \"Yes - Please erase and format drive C:\"\n20. At this point its a normal FreeDOS install\n21. When the install is done and reboots \"eject\" the virtual CD form the \"Optical Drive\" in the VirtualBox panel, then choose \"boot from system disk\",you now should have a working FreeDOS on VirtualBox\n\n## Native Oberon System 3 on Virtual Box\n\nNative Oberon can be found at http://www.ethoberon.ethz.ch/native/.\nThere is a related ftp site[^4] where you can download the necessary\nfiles for the stand alone version. \n\nHere's the steps I used in my Mac to download Native Oberon and\ninto a file on my desktop called \"NativeOberon-Standalone\". Open\nthe macOS Terminal application. I assume you've got a Unix\ncommand called [wget](https://en.wikipedia.org/wiki/Wget)\nalready installed[^5].\n\n> NOTE: The ETH ftp server is no more. I've included Web Archive\n> links and links to my own copies of the files needed to\n> install Native Oberon 2.3.6 in the paragraphs that follow.\n> RSD, 2021-03-16\n\n```bash\n\n    cd\n    mkdir -p Desktop/NativeOberon-Standalone\n    cd Desktop/NativeOberon-Standalone\n    wget ftp://ftp.ethoberon.ethz.ch/ETHOberon/Native/StdAlone/\n\n```\n\nClone your FreeDOS Box first. You'll want to do a \"Full Clone\". You'll\nalso want to \"remove\" any optical disks or floppies. You do that from\nthe virtual boxes' detail page and clicking on the drive and picking the\n\"Remove disk from virtual drive\" in the popup menu.\n\nAt this point we have a a virtual machine that is very similar to an \n1999 era PC installed with MS DOS.  [Native Oberon](http://web.archive.org/web/20190929033749/http://www.ethoberon.ethz.ch/native/) Normally you'd\ninstall [Native Oberon via 1.44MB floppy disks](/blog/2019/07/28/NativeOberon-StnAlone-2.3.6.zip \"Zip file of individual floppies\"). \nWe can simulate that with our Virtual machine.\nIn the folder of you downloaded there is disc called \"oberon0.dsk\". That\ncan go in our first floppy drive. But how to we get the rest of the \nfiles onto a virtual floppies? This wasn't obvious to me at first.\n\nThe Oberon install disks were organized as follows\n\n| PACKAGE    | FILENAME     | SIZE  | DSK   |\n| ---------- | ------------ | ----- | ----- |\n| Oberon-0      | [oberon0.dsk](oberon0.dsk \"boot disk\")  |          | 0 | \n| Gadgets       | [gadgets.arc](gadgets1.arc \"a modified gadgets.arc to fit 1.4 floppy\")  | 1.4  2.9 | 1 | \n| Documentation | [docu.arc](docu.arc \"documentation\")     | 1.3  2.5 | 2 | \n| Applications  | [apps.arc](apps.arc \"applications\")     | 1.3  2.8 | 3 | \n| Tutorials     | [tutorial.arc](tutorial.arc \"tutorial\") | 0.3  0.8 | 4 | \n| Pr3Fonts      | [pr3fonts.arc](pr3fonts.arc \"fonts\") | 0.3  0.6 | 4 | \n| Pr6Fonts      | [pr6fonts.arc](pr6fonts.arc \"fonts\") | 0.5  1.8 | 4 | \n| Source1       | [source1.arc](source1.arc \"Source Code\")  | 0.9  2.5 | 5 | \n| Source2       | [source2.arc](source2.arc \"Source Code\")  | 1.2  3.5 | 6 | \n| Source3       | [source3.arc](source3.arc \"Source Code\")  | 0.6  1.7 | 7 | \n\n\nIt turns out you can create 1.44MB Fat16 disc images from the\nVirtual Box 6.0 floppy drive link.  When you click on the floppy\ndrive in the details page you have a choice that includes \"create a new floppy disc\". Select this, find the disc a filename like \"disk1\". Click\non the virtual floppy disk in the Virtual Box and \"remove\"\nthe disc then create disk2, disk3, etc. In each the empty disc image\nfiles places the files from the table above. These image files can then\nbe opened on your host operating system and files copied to them. \nIt's a tedious process but this gives you something the Oberon System \ncan read and install from. Originally I just put all the files into an \nISO CD ROM image but I could not figure out how to mount that from this\nversion of Oberon. Now when you start up your Oberon V3 virtual machine\nyou can install the rest of the software like Gadgets.\n\n\n[^1]: FreeDOS is an Open Source implementation of PC/MS DOC\n\n[^2]: Native Oberon is a 1990's version of Oberon System running on i386\n\n[^3]: Download FreeDOS from http://freedos.org/download\n\n[^4]: Download Native Oberon Stand Alone from [ftp://ftp.ethoberon.ethz.ch/ETHOberon/Native/StdAlone](NativeOberon-StdAlone-2.3.6.zip \"Zip of what used to be available in that directory at ftp.ethoberon.ethz.ch\")\n\n[^5]: wget is easily installed with [HomeBrew](https://brew.sh/) or [Mac Ports](https://www.macports.org/)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2018, R. S. Doiel",
        "date": "2019-07-28",
        "keywords": [
          "FreeDOS",
          "Oberon System"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "FreeDOS 1.2 to Oberon System 3",
        "updated": "2021-03-16"
      },
      "url": "posts/2019/07/28/freedos-to-oberon-system-3.json"
    },
    {
      "content": "\n\nMostly Oberon\n=============\n\nBy R. S. Doiel, 2020-04-11\n\n**Mostly Oberon** is a series of blog posts documenting my exploration of the Oberon Language, Oberon System and the various rabbit wholes I inevitably fell into.\n\n## Overview\n\nOberon is a classical computer language and operating system originated by Professors Niklaus Wirth and Jürg Gutknecht at [ETH](https://en.wikipedia.org/wiki/ETH_Zurich) circa 1987.  It was inspired by their experiences in California at the [Xerox Palo Alto Research Center](https://en.wikipedia.org/wiki/PARC_\\(company\\)).  This series of blog posts are my meandering exploration of Oberon-07 language based on [Project Oberon 2013](http://www.projectoberon.com/).\n\nNOTE: Oberon grew from Wirth's Modula, which grew from Pascal, which grew from his experiences with Algol.\n\n### My Voyage\n\nI am new to both Oberon and the Oberon System.  Oberon language is in the tradition of ALGOL, Pascal, Modula 1 and 2 as well as incorporating ideas from the parent of Object Oriented languages Simula. The Oberon language reminds me of my first programming language [Turbo Pascal](https://en.wikipedia.org/wiki/Turbo_Pascal).  Oberon's language shape is more Pascal than C. For that reason I think it has largely been overlooked.\n\nOberon-07 is Wirth's most recent refinement of the Oberon language.  It is a terse and powerful systems language.  It strikes a different computing path then many popular programming languages used in 2020.  You find its influence along with Simula in more recent popular languages like [Go](https://golang.org).\n\nWhile Wirth conceived of Oberon in the context of a whole system it's use in research and instruction means it is also well suited [POSIX](https://en.wikipedia.org/wiki/POSIX) based systems (e.g. BSD, Linux, macOS).  The difference in programming in Oberon for a POSIX system versus a native Oberon System is primarily in the modules you import. These posts will focus on using Oberon language in a POSIX environment.\n\nNOTE: Oberon was initially a project including the CERES Hardware, Oberon compiler and Oberon operating system for networked workstations.\n\nThe latest Oberon is Prof. Niklaus Wirth and Paul Reeds' Project Oberon 2013. If you want to explore it I suggest using Peter De Wachter's [emulator](https://github.com/pdewacht/oberon-risc-emu). Project Oberon also his links to the updated books and articles in PDF format which are easy to read (or print) on most computing devices.\n\n\n## A starting point\n\nI am starting my exploration with Karl Landström's [OBNC](https://miasap.se/obnc/) compiler. I am focusing on getting comfortable using and writing in the Oberon language.\n\nHere's an example of a simple \"Hello World\" program in Oberon written for a POSIX system. I've named the [source code](HelloWorld.Mod) `HelloWorld.Mod`.\n\nNOTE: In 2020 common POSIX systems include [Linux](https://en.wikipedia.org/wiki/Linux), [BSD](https://en.wikipedia.org/wiki/Berkeley_Software_Distribution) and [macOS](https://en.wikipedia.org/wiki/MacOS).\n\n\n~~~\n\n    MODULE HelloWorld;\n      IMPORT Out;\n    BEGIN\n      Out.String(\"Hello World!\"); Out.Ln;\n    END HelloWorld.\n\n~~~\n\n\nWhile this is longer than a Python \"hello world\" program it is much shorter than I remember writing in Java and about the same number of lines as in C. `BEGIN` and `END` are similar to our opening and closing curly braces in C and the module is the basic unit of source code in Oberon. `IMPORT` includes the module `Out` (modules are similar to a included library in C) for sending values to the console (stdout in POSIX). One thing to note, Oberon language(s) are case sensitive. All language terms are capitalized. This makes it easy to distinguish between source code written in Oberon versus the Oberon language itself.\n\nThe `Out` module includes methods for displaying various data types native\nto Oberon. There is a corresponding `In` for receiving input as well as\nsome additional modules provided with our chosen compiler implementation.\n\nModules in Oberon can include a module wide initialization block. The\n`BEGIN` through `END HelloWorld.` are an initialization block. This is\nsimilar to C or Go's \"main\" function for our POSIX environment.\n\n### OBNC\n\nIf you want to run my \"Hello World\" you need to compile it.  I have found that [OBNC](https://miasap.se/obnc/) compiler runs well on Linux, macOS and [Raspberry Pi](https://www.raspberrypi.org). Karl has also made a precompiled version that runs on Windows available too. It is the Oberon compiler I plan to use in this series of posts.\n\nOBNC compiles Oberon source into C then into machine code for the computer system you are running on. Because it is compiling to C it can function as a [cross compiler](https://en.wikipedia.org/wiki/Cross_compiler). This opens the door to [bare metal programming](https://en.wikipedia.org/wiki/Bare_machine).\n\nIf you're following along please install OBNC on your computer.  Instructions are found at https://maisap.se/obnc. Karl also has excellent documentation and is responsive to questions about his implementation. His contact methods are included on his website.\n\n\n### Running OBNC\n\nOBNC provides a Oberon-07 compiler with some optional modules for working in a POSIX environment.  Compiling our \"Hello World\" is easy from your shell or terminal.\n\n\n~~~\n\n    obnc HelloWorld.Mod\n\n~~~\n\n\nIf all goes well this should produce an executable file named `HelloWorld` (or `HelloWorld.exe` on Windows). You can now run this program with a command like `./HelloWorld` (or `HelloWorld` on Windows).\n\n### Learning more about Oberon\n\nI have faced two challenges in my exploration of Oberon, finding a compiler I was happy with (thank you Karl for OBNC) and sorting out the literature around Oberon language implementations and system versions.\n\nOberon has a rich history though it was not well known in Southern California in 2020. Oberon's history is primarily academic and European. It was commonly used in college level instruction in Europe from it's inception at ETH in the late 80's through the early 2000s. The Oberon System is an Open Source system (predating the term by a decade) and was created in the spirit of other academic systems such as BSD. There are many books (physical books as opposed to ebooks) dating from that era.  They covered the Oberon language and system of their time.  From a historical computing perspective they remain very interesting. But running Oberon on modern 2020 hardware is a little more challenging. Fortunately Prof. Emeritus Wirth and Paul Reed brought things up to date in 2013. I recommend Reed's [www.projectoberon.com](http://www.projectoberon.com) as a good place to start. He includes links to revised versions of the classic Oberon and Oberon System texts written by Wirth et el. Prof. Wirth's [website](https://inf.ethz.ch/personal/wirth/) is still maintained and he features links to most of his major publications. His is the canonical source of information on Oberon.\n\nNOTE: Prof. Wirth's personal website at ETH was available as of 2020-04-11. \n\nI have found the ACM [Digital Library](https://dl.acm.org/) and the ETH [Research Collection](https://www.research-collection.ethz.ch/?locale-attribute=en) very helpful.  While much of the material is now historic it remains useful for both techniques and inspiration.  Today's hardware, even a Raspberry Pi Zero, is more resource rich than the original systems Oberon ran on.\n\nThe online community for Oberon and Oberon System seems mostly centered around a [mail list](https://lists.inf.ethz.ch/mailman/listinfo/oberon) at ETH and net news group [comp.lang.oberon](https://groups.google.com/forum/#!forum/comp.lang.oberon)\n\n\n\n\n\n\n\n\n### Next\n\n+ Next [Modules and Procedures](../12/Mostly-Oberon-Modules.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "byline": "R. S. Doiel",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-04-11",
        "keywords": [
          "Oberon",
          "Wirth",
          "Gutknecht",
          "ETH",
          "Parc",
          "programming",
          "operating systems"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 1,
        "series": "Mostly Oberon",
        "title": "Mostly Oberon"
      },
      "url": "posts/2020/04/11/Mostly-Oberon.json"
    },
    {
      "content": "\n\nOberon Modules and Procedures\n=============================\n\nBy R. S. Doiel, 2020-04-12\n\nThis is the second post in the [Mostly Oberon](../11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit wholes I inevitably fell into.\n\n## Modules\n\nThe module is a primary code unit of Oberon language. Modules allow you to focus on functional units of code and can be readily composed into larger solutions.\nA module's name should match the filename you are saving it under. A module starts with declaring it's name and ends the declaration with a semicolon\nthe statement separator in Oberon. Our simple \"Hello World\" example \nshows the basic code shape.\n\n\n~~~{.oberon}\n\n    MODULE HelloWorld;\n      IMPORT Out;\n    BEGIN\n      Out.String(\"Hello World!\"); Out.Ln;\n    END HelloWorld.\n\n~~~\n\n\nModules end with a `END` followed by the module's name and a period.\nAny text following the `END` statement is ignored by the compiler. This\nturns out to be very useful as a place to write up ideas about the code\nyou're working on. You can also write any additional special instructions \nthere (e.g. document usage). You can even use it as a scratch pad knowing \nthat the compiler will ignore it.\n\nHere's an example\n\n\n~~~{.oberon}\n\n    MODULE HelloWorld;\n      IMPORT Out;\n    BEGIN\n      Out.String(\"Hello World!\"); Out.Ln;\n    END HelloWorld.\n\n    This program isn't very useful. It has no interactive ability.\n    It'd be nice if it could be more specific about who it was saying\n    hello to.\n\n~~~\n\n\nFor a module to be really useful you want to have the capability\nof including both private and public code. Public code\nallows us to reuse our code in other modules while the private code \nkeeps internal things inside the module safe from colliding with other\nmodules private code. This technique is classically known as \n\"information hiding\" and in computer sciences texts as \"scope\". Lets \ncreate a a more composable module called `SayingHi.Mod`.  In \naddition to display \"Hello World!\" we want a public method \n(procedure in Oberon terminology) that can ask for a name and print \nout a salutation. We will use the `SayingHi.Mod` module along with \na newer version of `HelloWorld.Mod` named `HelloWorld2.Mod`.\n\n\n## Procedures\n\nHow do we write methods in Oberon?  Methods are declared\nusing the keyword `PROCEDURE` followed by their name, a \ndeclaration of any parameters and if the procedure returns a\nvalue (i.e. is a function) it also includes that declaration. \nNext we declare any internal variables needed by the procedure.\nThis is followed by the procedure's body.  The body of the \nprocedure is defined by a `BEGIN` and `END` statement structure. \nThe body contains the steps the procedure needs to execute.\n\nWe'll create a procedure called \"HelloWorld\" in our new module.\nSince we will use this procedure from our new `HelloWorld2.Mod` \nour new \"HelloWorld\" procedure needs to be public.  A public \nprocedure in `SayingHi.Mod` is available for use in our new \n`HelloWorld2.Mod` (or by another module).  Marking a procedure \npublic in Oberon is a little different than in other languages. \nA Module's procedure is public if its name ends with an asterisk. \nBelow is a sketch of our module `SayingHi.Mod` so far.\n\nNOTE: This technique is also used to mark variables, records and constants as public and available to other modules. Public variables are \"read only\" in other modules.\n\n\n~~~{.oberon}\n\n    MODULE SayingHi;\n      IMPORT Out;\n    \n      PROCEDURE HelloWorld*;\n      BEGIN\n        Out.String(\"Hello World!\"); Out.Ln;\n      END HelloWorld;\n    END SayingHi.\n\n~~~\n\n\nThis modules looks allot like `HelloWorld.Mod` with a couple key\ndifferences. Rather than relying on the module's begin and end \nstatements we declare a procedure with its own begin and end statements.\nNotice the procedures end statement includes the procedure name and\nis terminated by semicolon rather than a period.  Like `HelloWorld.Mod`\nwe import the `Out` module to display our greeting.\n\n## Putting it all together\n\nLet's create a new \"Hello World\" module called `HelloWorld2.Mod` and\nuse our `SayingHi` module instead of directly importing `Out`.\n\n\n~~~{.oberon}\n\n    MODULE HelloWorld2;\n      IMPORT SayingHi;\n    BEGIN\n      SayingHi.HelloWorld;\n    END HelloWorld2.\n\n~~~\n\n\nWe can compile our module with OBNC using the command\n\n\n~~~\n\n    obnc HelloWorld2.Mod\n\n~~~\n\n\nWe can run our new \"Hello World\" with the command\n\n\n~~~\n\n    ./HelloWorld2\n\n~~~\n\n\nAt this point we have a way of saying \"Hello World!\" whenever\nwe need in our Oberon programs. But just printing \"Hello World!\"\nto the screen isn't very interactive. It'd be nice if we could\nhave the computer ask our name and then respond with a greeting.\n\nWe'll modify our SayingHi to include a new procedure called \"Greetings\"\nand that procedure needs to ask us our name and then display\nan appropriate greeting. \"Greetings\" will be a public procedure\nmarked by an asterisk like \"HelloWorld\". \n\n\"Greetings\" has three tasks\n\n1. Ask politely for our name\n2. Get the name typed in with our keyboard\n3. Assemble and display a polite greeting\n\nTo keep our \"Greeting\" procedure short we'll split this\nup into some private procedures. These will not be available\noutside `SayingHi.Mod`. Here's a sketch of our improved module.\n\n\n~~~{.oberon}\n\n    MODULE SayingHi;\n      IMPORT In, Out;\n    \n      PROCEDURE HelloWorld*;\n      BEGIN\n        Out.String(\"Hello World!\"); Out.Ln;\n      END HelloWorld;\n    \n      PROCEDURE AskOurName;\n      BEGIN\n        Out.String(\"Excuse me, may I ask your name? \");\n      END AskOurName;\n    \n      PROCEDURE GetName(VAR ourName : ARRAY OF CHAR);\n      BEGIN\n        In.Line(ourName);\n      END GetName;\n    \n      PROCEDURE AssembleGreeting(ourName : ARRAY OF CHAR);\n      BEGIN\n        Out.String(\"Hello \");Out.String(ourName);\n        Out.String (\", very nice to meeting you.\"); Out.Ln;\n      END AssembleGreeting;\n    \n      PROCEDURE Greetings*;\n        VAR ourName : ARRAY 256 OF CHAR;\n      BEGIN\n        AskOurName;\n        GetName(ourName);\n        AssembleGreeting(ourName);\n      END Greetings;\n    END SayingHi.\n\n~~~\n\n\nNow let's add our Greetings procedure to `HelloWorld2.Mod`.\n\n\n~~~{.oberon}\n\n    MODULE HelloWorld2;\n      IMPORT SayingHi;\n    BEGIN\n      SayingHi.HelloWorld;\n      SayingHi.Greetings;\n    END HelloWorld2.\n\n~~~\n\n\nWe compile and run it the same way as before\n\n\n~~~\n\n    obnc HelloWorld2\n    ./HelloWorld2\n\n~~~\n\n\nWhen you run `HelloWorld2` you should now see something like\n(I've answered \"Robert\" and pressed return after the second line.\n\n\n~~~\n\n   Hello World!\n   Excuse me, may I ask your name? Robert\n   Hello Robert, very nice to meeting you.\n\n~~~\n\n\n\n## Reading our code\n\nWhile our revised modules are still short they actually exercise\na number of language features. Let's walk through the code \nblock by block and see what is going.\n\n`HelloWorld2.Mod` is responsible for the general management of\nour program namely say \"Hello World!\" and also for initiating\nand responding with a more personal greeting.  It does this by\nfirst importing our `SayingHi.Mod` module.\n\n\n~~~\n\n    IMPORT SayingHi;\n\n~~~\n\n\n[HelloWorld2.Mod](HelloWorld2.Mod) doesn't have any of its own \nprocedures and like our original [HelloWorld.Mod](HelloWorld.Mod)\nrelies on the module's initialization block to run our two public \nprocedures from `SayingHi`. It calls first `SayingHi.HelloWorld;` \nthen `SayingHi.Greetings'` before existing. Other than using the \n`SayingHi` module it is similar in spirit to our first \n[HelloWorld.Mod](HelloWorld.Mod).\n\nOur second module [SayingHi.Mod](SayingHi.Mod) does the heavy lifting.\nIt contains both public and private procedures.  If you tried to\nuse `GetName` from `SayingHi` in `HelloWorld2.Mod` you would get a\ncompiler error. As far as `HelloWorld2.Mod` is concerned `GetName`\ndoes not exist. This is called information hiding and is an important\ncapability provided by Oberon's Modules system. \n\n### explore `SayingHi` more deeply\n\nIn `SayingHi.Mod` we introduce two important concepts.\n\n1. Public and Private procedures\n2. variables to hold user input\n\n`SayingHi.Mod` imports two module, `In` which is for getting\ntext input from the keyboard, and `Out` which is used for displaying\ntext to standard output.\n\n\n~~~{.oberon}\n\n    IMPORT In, Out;\n\n~~~\n\n\n`In` and `Out` are to modules you will commonly use to either\nreceive input (`In`) from the keyboard or display output (`Out`)\nto the terminal or shell. They provide simple methods for working\nwith variables and constants and built-in Oberon data types. \nThis is a very useful as it lets us focus our procedures\non operating on data rather than the low level steps needed to\ninteract with the operating system and hardware.\n\nNOTE: __basic types__, Oberon has a number of basic types, BYTE holds a byte as a series of bit, CHAR holds a single ASCII character, INTEGER holds a signed integer value, REAL holds a floating point number and BOOLEAN holds a True/False value.\n\nThe first procedure is `HelloWorld` and it's pretty straight forward.\nIt displays a \"Hello World!\" message in our terminal. It uses `Out`.\n`Out.String` to display the \"Hello World!\" and `Out.Ln` to force a new\nline. `Out.String` is responsible for displaying values that are of type\n`ARRAY OF CHAR`. This includes text we provided in double quotes.\n\n\n~~~{.oberon}\n\n    PROCEDURE HelloWorld*;\n    BEGIN\n      Out.String(\"Hello World!\"); Out.Ln;\n    END HelloWorld;\n\n~~~\n\n\nThe notable thing about `HelloWorld*` is its annotation `*`.\nThis asterisk indicates to the compiler that this is\na public procedure and should be made available to other modules.\nProcedures, variables, constants, records (data structures) can be\nmade public with this simple annotation.  If we left off the `*`\nthen we would not be able to use `HelloWorld` procedure from other\nmodule.\n\nOur second procedure is `AskOurName`. It's private because it lacks\nthe `*`. It is invisible to `HelloWorld2.Mod`. It is visible within\n`SayingHi` module and we'll use it later in `Greetings*`. Before\na procedure, variable, constant or record can be used it must be\ndeclared. That is why we most define `AskOurName` before we define\n`Greetings*`. `AskOurName` is in other respects very similar to \n`HelloWorld*`.\n\n\n~~~{.oberon}\n\n    PROCEDURE AskOurName;\n    BEGIN\n      Out.String(\"Excuse me, may I ask your name? \");\n    END AskOurName;\n\n~~~\n\n\nOur third procedure `GetName` is a little more interesting.\nIt demonstrates several features of the Oberon language. Most\nobvious is that it is the first procedure which contains a\nparameter list.\n\n\n~~~{.oberon}\n\n    PROCEDURE GetName(VAR ourName: ARRAY OF CHAR);\n\n~~~\n\n\nThere is allot packed in this single statement in addition\nto putting a name to our procedure. Specifically it uses\na `VAR` in the parameter.  Oberon provides two kinds of parameters\nin declaring procedures. The two are `VAR` and static.  A `VAR` \nparameter means that the procedure is allowed to up date the value \nin the memory location indicated by the name. A static variable \n(a parameter without the `VAR` prefix passes in a read only value. \nThis allows us to distinguish between those procedures and variables\nwhere that can be modified by the procedure and those which\nwill be left the same. Inside of `GetName` we call the \n`In` module using the `Line`. This retrieves a line of text\n(a sequence of keyboard strokes ended with the return key).\n\n\n~~~{.oberon}\n\n    In.Line(ourName);\n\n~~~\n\n\nBecause `ourName` was a variable parameter in `GetName` it\ncan be modified by `In.Line`.\n\nOur next procedure `AssembleGreeting` is private like\n`AskOurName` and `GetName`. Like `HelloWorld*` and `AskOurName`\nit makes use of the `Out` module to display content.\nUnlike `HelloWorld*` it has a parameter but this time\na static one. Notice the missing `VAR`. This indicates that\n`AssembleGreeting` doesn't modify, cannot modify `ourName`.\n\n\n~~~{.oberon}\n\n    PROCEDURE AssembleGreeting(ourName : ARRAY OF CHAR);\n    BEGIN\n      Out.String(\"Hello \");Out.String(ourName);\n      Out.String (\", very nice to meeting you.\"); Out.Ln;\n    END AssembleGreeting;\n\n~~~\n\n\nThe use of `Out.String` is more elaborate then before. Notice how\nwe use trailing spaces to make the output more readable.\n\nOur final procedure is public, `Greetings*`. It does not\nhave any parameters.  Importantly it does include a\nvariable for use inside the procedure called `ourName`. \nThe `VAR` line declares `ourName` as an `ARRAY 256 OF CHAR`. \nThis declaration tells the compiler to allocate memory \nfor storing `ourName` while `Greetings*` is being executed. \nThe declaration tells us three things. First the storage\nis continuous block of memory, that is what `ARRAY` means.\nThe second is the size of this memory block is 256 `CHAR`\nlong and the that we will be storing `CHAR` values in it.\n\nThe memory for `ourName` will be populated when we pass\nthe variable to `GetName` based on what we type at the\nkeyboard. If we type more than 256 ASCII characters they\nwill be ignored. After `GetName` records the typed character\nwe use the memory associated with the `ourName` variable\nwe read that memory to display what we typed in \nthe procedure named `AssembleGreeting`.\n\n\n### Going a little deeper\n\nOberon is a typed language meaning that \nvariables are declared, allocated and checked during compile time\nfor specific characteristics. The one variable we created `ourName`\nin the `Greetings` procedure reserves the space for 256 \n[ASCII](https://en.wikipedia.org/wiki/ASCII) characters. \nIn Oberon we call a single ASCII character a `CHAR`.  Since it\nwould be useful to work with more than one `CHAR` in relationship\nto others Oberon also supports a variable type called `ARRAY`. \nAn `ARRAY` is represented as a block of memory that is allocated\nby the Oberon run time. Because it is allocated ahead of time we\nneed to know its size (i.e. how many `CHAR` are we storing). In\nour case we have declared `ARRAY 256 OF CHAR`. That means we can\nhold names up to 256 ASCII characters. \n\n`Greetings*` does three things and the second thing, `GetName` \nreceives the characters typed at the keyboard.  `GetName` has\na parameter list. In this case the only one parameter is declared\n`VAR ourName : ARRAY OF CHAR`. Notice the similarity and\ndifference between the `VAR` statement in `Greetings` versions\nthe parameter list.  Our `GetName` can accept **any** length of\n`ARRAY OF CHAR` and it **only** can accept an `ARRAY OF CHAR`.\nIf you try to pass another type of variable to `GetName` the\ncompiler will stop with an error message.\n\nWhy is this important?\n\nWe've minimized the memory we've used in our program.  Memory is \ntypically allocated on the stack (a block of memory made available \nby the operating system to the program). We've told the operating \nsystem we need 256 `CHAR` worth of consecutive memory locations \nwhen we allocated room the variable `ourName` in `Greetings`. When \nwe invoke `GetName` Oberon knows to use that same memory location \nfor the value of `ourName` defined in the parameter.  In turn\nwhen `In.String(ourName);` is called the module `In` knows\nto store the name typed on the keyboard in that location of memory.\nWhen `Out.String(outName);` is called the compiler knows to use\nthe same location of memory to send the contents to the display.\nWhen we finally finish the `Greetings*` procedure the memory is \nreleased back to the operating system for re-use by this or\nother programs.\n\n### What we've explored\n\n1. Using a module to break down a simple problem\n2. Using a module's ability to have public and private procedures \n3. Touched on how memory is used in a simple interactive program\n\n\n\n### Next and Previous\n\n+ Next [Basic Types](../18/Mostly-Oberon-Basic-Types.html)\n+ Previous [Mostly Oberon](../11/Mostly-Oberon.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-04-12",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 2,
        "series": "Mostly Oberon",
        "title": "Oberon Modules and Procedures"
      },
      "url": "posts/2020/04/12/Mostly-Oberon-Modules.json"
    },
    {
      "content": "\n\nOberon Basic Types\n==================\n\n\nBy R. S. Doiel, 2020-04-18\n\nThis is the third post in the [Mostly Oberon](../11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit wholes I inevitably fell into.\n\n## Simple Types\n\nOberon is a small systems language. It provides a useful but \nlimited umber of basic types. These can be be\nthought of as simple types mapping to specific memory locations\nand more complex types composed of multiple memory locations.\n\nNOTE: __basic types__, INTEGER, REAL, CHAR, ARRAY, RECORD and POINTER TO\n\n### INTEGER\n\nIntegers are easiest to be thought of as whole numbers. They may be\npositive numbers or negative numbers. Declaring an integer\nvariable `i` it would look something like\n\n\n~~~{.oberon}\n\n    VAR i : INTEGER;\n\n~~~\n\n\nSetting `i`'s value to seven would look like\n\n\n~~~{.oberon}\n\n    i := 7;\n\n~~~\n\n\n\n### REAL\n\nReal holds real numbers. Real numbers contain a fractional \ncomponent. We normally notate them with\na decimal value e.g. \"0.01\". Like integers they can also be \npositive or negative.\n\nDeclaring a real number variable `a` would look like\n\n\n~~~{.oberon}\n\n    VAR a : REAL;\n\n~~~\n\n\nSetting the value of `a` to seven and one tenth (7.1) would\nlook like\n\n\n~~~{.oberon}\n\n    a := 7.1;\n\n~~~\n\n\n### CHAR\n\nA CHAR is a single ASCII character. Oberon, unlike more recent\nlanguages like Go or Julia, predates the wide adoption of UTF-8.\nThe character is represented in memory as one 8 bit byte.\nIf you need to work with an extended character set then you need\nto either re-encode the values into ASCII. At this time[^now] there\nis no standard way of handling None ASCII character systems natively.\nIf you need to work directly with an encoding such as UTF-8 you'll\nneed to develop your own modules and procedures for handily their\nencoding, decoding and other operations.\n\nDeclaring a CHAR variable `c` would look like\n\n\n~~~{.oberon}\n\n    VAR c: CHAR;\n\n~~~\n\n\nSetting the value of `c` to capital Z would look like\n\n\n~~~{.oberon}\n\n    c := \"Z\";\n\n~~~\n\n\nNote: Oberon expects double quotes to notate a character.\n\n\n### More complex types\n\nThe simplest types would prove problematic when addressing\nmore complex data representations if Oberon lacked two three built-in\ntypes - ARRAY, RECORD and POINTER TO. \n\n### ARRAY\n\nAn array is a sequence of memory locations which contain a common\ntype.  In Oberon-07 all arrays have to have a known link. This is\nbecause the Oberon compiler is responsible for pre-allocating\nmemory when the program starts to hold the array.  While this\nseems restrictive our next data type, RECORD, lets us move\ninto more dynamic memory structures.  Pre-allocating the array\nsize also has the advantage that we can re-use those locations\neasily in a type safe manner.\n\nDeclaring a variable \"name\" as an array of twelve characters would \nlook like and declaring a variable \"scores\" as an array of ten\nintegers would look like\n\n\n~~~{.oberon}\n\n    VAR \n      name : ARRAY 24 OF CHAR;\n      scores : ARRAY 10 OF INTEGER;\n\n~~~\n\n\nThe length of the array immediately follows the keyword \"ARRAY\" and\nthe \"OF CHAR\" or \"OF INTEGER\" phrases describes the types that can be \ncontained in the array. In the \"OF CHAR\" the type is \"CHAR\" the \n\"OF INTEGER\" is the type \"INTEGER\". \n\nSetting an array value can be done using an index. In this example\nthe zero-th element (first element of the array) is set to the value\n102. \n\n\n~~~{.oberon}\n\n    scores[0] := 102;\n\n~~~\n\n\nIn the case of CHAR arrays the whole array can be set in a simple \nsingle assignment.\n\n\n~~~{.oberon}\n\n    name := \"Ada Lovelace\";\n\n~~~\n\n\nTwo key points of arrays in Oberon are a known length and a single \ntype of data associated with them. Arrays can have more than\none dimension but the cells of the array most contain the same type.\n\nNOTE: __type safety__, Type safe means the compiler or run time verify that the data stored at that location conforms to the program defined, this is helpful in maintaining program correctness.\n\n### RECORD\n\nThe RECORD is Oberon's secret sauce. The record is used to\ncreate new types if data representations. It extend Oberon's basic \ntypes creating structured data representation. In this example we'll \ncreate a record that holds an game's name, a list of three player names \nand a list of three scores. We'll call this record type \n\"TopThreeScoreboard\". \n\n\n~~~{.oberon}\n\n    TYPE\n      TopThreeScoreboard = RECORD\n        gameName : ARRAY 24 OF CHAR;\n        playerNames : ARRAY 3, 24 OF CHAR;\n        scores : ARRAY 3 OF INTEGER\n      END;\n\n~~~\n\n\nNow that we have describe a record of type \"TopThreeScoreboard\" we can\ndeclare it with our \"VAR\" statement.\n\n\n~~~{.oberon}\n\n    VAR\n      scoreboard : TopThreeScoreboard;\n\n~~~\n\n\nSetting the element values in a record uses a dot notation\nand if those elements are themselves. In this case we'll set\nthe game name to \"Basketball\", the three players are\n\"Ada Lovelace\", \"Blaise Pascal\", and \"John McCarthy\", with\nthe scores 102, 101, 100.\n\n\n~~~{.oberon}\n\n   scoreboard.gameName := \"Basketball\";\n   scoreboard.playerNames[0] := \"Ada Lovelace\";\n   scoreboard.scores[0] := 102;\n   scoreboard.playerNames[1] := \"Blaise Pascal\";\n   scoreboard.scores[0] := 101;\n   scoreboard.playerNames[2] := \"John McCarthy\";\n   scoreboard.scores[0] := 100;\n\n~~~\n\n\nRecords are also used to create dynamic memory structures such as lists, trees and maps (see note on \"AD\").  The dynamic nature of records is achieved with\nour next type \"POINTER TO\".\n\nNOTE: __AD__, Prof. Wirth wrote an excellent text on [Algorithms and Data structures](https://inf.ethz.ch/personal/wirth/AD.pdf) available in PDF format.\n### POINTER TO\n\nOberon is a type safe language. To keep things safe in a type\nsafe language you need to place constraints around random\nmemory access. Memory can be thought of a list of locations and\nwe can go to those locations if we know their address. A pointer\nin most languages holds an address. Oberon has pointers but they\nmust point at specific data types. So like array you have to indicate\nthe type of the thing you are pointing at in a declaration. \nE.g. `VAR a : POINTER TO CHAR;` would declare a variable 'a' \nthat points to a memory location that holds a CHAR. The more common \ncase is we use \"POINTER TO\" in records to create dynamic data \nstructures such as linked lists.\n\nHere's a simple data structure representing a dynamic list\nof characters. Let's call it a DString and we will implement\nit using a single link list. The list can be implemented by\ndefining a RECORD type that holds a single character and a pointer\nto the next record. We can then also define a pointer to this type\nof record.  If there is no next character record\nwe assume we're at the end of the string.\n\n\n~~~{.oberon}\n\n    TYPE\n      DStringDesc = RECORD\n        value : CHAR;\n        next : POINTER TO DStringDesc\n      END;\n\n      DString : POINTER TO DStringDesc;\n\n~~~\n\n\nRECORD types are permitted to use recursive definition so our \n\"next\" value is itself a type \"DStringDesc\".  Declaring a \nDString variable is as easy as declaring our scoreboard type variable.\n\n\n~~~{.oberon}\n\n  VAR\n    VAR s : DString;\n\n~~~\n\n\nSetting our DString is a little trickier. This is where\nOberon's procedures come into play. We can pass our variable \"s\"\nof type DString to a procedure to build out our DString from an simple\narray of characters. Note \"s\" is declared as a \"VAR\" parameter\nin our procedure heading. Our `SetDString` will also need to handle\ncreating new elements in our dynamic string. That is what Oberon's\nbuilt-in `NEW()` procedure does. It allocates new memory for our\nlist of records.\n\n\n~~~{.oberon}\n\n    PROCEDURE SetDString(VAR s : DString; buf : ARRAY OF CHAR);\n        VAR i : INTEGER; cur, tmp : DString;\n    BEGIN\n      (* Handle the case where s is NIL *)\n      IF s = NIL THEN\n        NEW(s);\n        s.value := 0X;\n        s.next := NIL;\n      END;\n      cur := s;\n      i := 0;\n      (* check to see if we are at end of string or array *)\n      WHILE (buf[i] # 0X) & (i < LEN(buf)) DO\n        cur.value := buf[i];\n        IF cur.next = NIL THEN\n          NEW(tmp);\n          tmp.value := 0X;\n          tmp.next := NIL;\n          cur.next := tmp;\n        END;\n        (* Advance our current pointer to the next element *)\n        cur := cur.next;\n        i := i + 1;\n      END;\n    END SetDString;\n\n~~~\n\n\nWe can move our string back into a fixed length array of char\nwith a similar procedure.\n\n\n~~~{.oberon}\n\n    PROCEDURE DStringToCharArray(s : DString; VAR buf : ARRAY OF CHAR);\n      VAR cur : DString; i, l : INTEGER;\n    BEGIN\n      l := LEN(buf);\n      i := 0;\n      cur := s;\n      WHILE (i < l) & (cur # NIL) DO\n        buf[i] := cur.value; \n        cur := cur.next;\n        i := i + 1;\n      END;\n      (* Zero out the rest of the string. *)\n      WHILE (i < l) DO\n        buf[i] := 0X;\n        i := i + 1;\n      END;\n    END DStringToCharArray;\n\n~~~\n\n\nAt this stage we have the basics of data organization. Modules\nallow us to group operations and data into cohesive focused units.\nProcedures allow us to define consistent ways of interacting with\nout data, and types singularly and collectively allow us to structure\ndata in a way that is useful to solving problems.\n\n## Putting it all together\n\nHere is a [module demoing our basic type](BasicTypeDemo.Mod). In it\nwe can define procedures to demo our assignments, display their results\nall called from inside the module's initialization block.\n\n\n~~~{.oberon}\n\n    MODULE BasicTypeDemo;\n      IMPORT Out;\n    \n      (* These are our custom data types definitions. *)\n      TYPE\n          TopThreeScoreboard = RECORD\n            gameName : ARRAY 24 OF CHAR;\n            playerNames : ARRAY 3, 24 OF CHAR;\n            scores : ARRAY 3 OF INTEGER\n          END;\n    \n          DStringDesc = RECORD\n            value : CHAR;\n            next : POINTER TO DStringDesc\n          END;\n    \n          DString = POINTER TO DStringDesc;\n    \n      (* Here are our private variables. *)\n      VAR \n        i : INTEGER;\n        a : REAL;\n        c: CHAR;\n        name : ARRAY 24 OF CHAR;\n        scores : ARRAY 10 OF INTEGER;\n        scoreboard : TopThreeScoreboard;\n        s : DString;\n    \n    \n      PROCEDURE SimpleTypes;\n      BEGIN\n        i := 7;\n        a := 7.1;\n        c := \"Z\";\n      END SimpleTypes;\n    \n      PROCEDURE DisplaySimpleTypes;\n      BEGIN\n        Out.String(\" i: \");Out.Int(i, 1);Out.Ln;\n        Out.String(\" a: \");Out.Real(a, 1);Out.Ln;\n        Out.String(\" c: \");Out.Char(c);Out.Ln;\n      END DisplaySimpleTypes;\n    \n    \n      PROCEDURE MoreComplexTypes;\n      BEGIN\n        scores[0] := 102;\n        name := \"Ada Lovelace\";\n        scoreboard.gameName := \"Basketball\";\n        scoreboard.playerNames[0] := \"Ada Lovelace\";\n        scoreboard.scores[0] := 102;\n        scoreboard.playerNames[1] := \"Blaise Pascal\";\n        scoreboard.scores[0] := 101;\n        scoreboard.playerNames[2] := \"John McCarthy\";\n        scoreboard.scores[0] := 100;\n      END MoreComplexTypes;\n    \n      PROCEDURE DisplayMoreComplexTypes;\n        VAR i : INTEGER;\n      BEGIN\n        i := 0;\n        Out.String(\" Game: \");Out.String(scoreboard.gameName);Out.Ln;\n        WHILE i < LEN(scoreboard.playerNames) DO\n          Out.String(\"    player, score: \");\n          Out.String(scoreboard.playerNames[i]);Out.String(\", \");\n          Out.Int(scoreboard.scores[i], 1);\n          Out.Ln;\n          i := i + 1;\n        END;\n      END DisplayMoreComplexTypes;\n    \n      PROCEDURE SetDString(VAR s : DString; buf : ARRAY OF CHAR);\n          VAR i : INTEGER; cur, tmp : DString;\n      BEGIN\n        (* Handle the case where s is NIL *)\n        IF s = NIL THEN\n          NEW(s);\n          s.value := 0X;\n          s.next := NIL;\n        END;\n        cur := s;\n        i := 0;\n        (* check to see if we are at end of string or array *)\n        WHILE (buf[i] # 0X) & (i < LEN(buf)) DO\n          cur.value := buf[i];\n          IF cur.next = NIL THEN\n            NEW(tmp);\n            tmp.value := 0X;\n            tmp.next := NIL;\n            cur.next := tmp;\n          END;\n          cur := cur.next;\n          i := i + 1;\n        END;\n      END SetDString;\n    \n      PROCEDURE DStringToCharArray(s : DString; VAR buf : ARRAY OF CHAR);\n        VAR cur : DString; i, l : INTEGER;\n      BEGIN\n        l := LEN(buf);\n        i := 0;\n        cur := s;\n        WHILE (i < l) & (cur # NIL) DO\n          buf[i] := cur.value; \n          cur := cur.next;\n          i := i + 1;\n        END;\n        (* Zero out the rest of the string. *)\n        WHILE (i < l) DO\n          buf[i] := 0X;\n          i := i + 1;\n        END;\n      END DStringToCharArray;\n    \n    BEGIN\n      SimpleTypes;\n      DisplaySimpleTypes;\n      MoreComplexTypes;\n      DisplayMoreComplexTypes;\n      (* Demo our dynamic string *)\n      Out.String(\"Copy the phrase 'Hello World!' into our dynamic string\");Out.Ln;\n      SetDString(s, \"Hello World!\");\n      Out.String(\"Copy the value of String s into 'name' our array of char\");Out.Ln;\n      DStringToCharArray(s, name);\n      Out.String(\"Display 'name' our array of char: \");Out.String(name);Out.Ln;\n    END BasicTypeDemo.\n\n~~~\n\n\n## Reading through the code\n\nThere are some nuances in Oberon syntax that can creep up on you.\nFirst while most statements end in a semi-colon there are noticeable\nexceptions. Look at the record statements in particular.  The last\nelement of your record before the `END` does not have a semicolon.\nIn that way it is a little like a `RETURN` value in a function\nlike procedure.\n\nIn creating our `DString` data structure the Oberon idiom is to first\ncreate a description record, `DStringDesc` then create a pointer to\nthe descriptive type, i.e. `DString`. This is a very common\nidiom in building out complex data structures. A good place to learn\nabout implementing algorithms and data structures in Oberon-07 is \nProf. Wirth's 2004 edition of [Algorithms and Data Structures](https://inf.ethz.ch/personal/wirth/AD.pdf) which\nis available from his personal website in PDF.\n\n\n### Next and Previous\n\n+ Next [Loops and Conditions](../19/Mostly-Oberon-Loops-and-Conditions.html)\n+ Previous [Modules and Procedures](../12/Mostly-Oberon-Modules.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-04-18",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 3,
        "series": "Mostly Oberon",
        "title": "Oberon Basic Types"
      },
      "url": "posts/2020/04/18/Mostly-Oberon-Basic-Types.json"
    },
    {
      "content": "\nOberon Loops and Conditions\n===========================\n\nBy R. S. Doiel, 2020-04-19\n\nThis is the four post in the [Mostly Oberon](../11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\n## Data Flow\n\nOberon is a small systems language and while it is minimalist.\nIt provides you with the necessary primitives to get things done.\nI've touched on code organization, basic types and basic type\nextensions in the previous articles.  I have shown the basic\ncontrol statements but have not talked about them yet.\n\nOberon offers four basic control statements. \n\nIF, ELSIF, ELSE\n: Basic condition test and execution\n\nASSERT\n: A mechanism to trigger a program halt\n\nWHILE DO, ELSIF DO\n: The Loop structure in the language (aside from recursive procedures)\n\nFOR TO, FOR TO BY\n: A counting Loop where incrementing a counter by an integer value (e.g. 1 or by a specified constant).\n\n## IF, ELSIF, ELSE\n\nThe first two provide for conditional statements of the form\nif a condition is true do something. Almost ever computer language\nhas some form of a conditional express and the Oberon IF, ELSIF,\nELSE typical of what you find is more computer languages today.\nBoth ELSIF and ELSE are optional.\n\n```Oberon\n    IF (s = \"Freda\") OR (s = \"Mojo\") THEN\n      Out.String(\"Wowie Zowie! I remember you from ZBS stories.\");Out.Ln;\n    ELSIF (s = \"Bilbo\") OR (s = \"Gandolf\") THEN\n      Out.String(\"Greets, I remember from the Hobbit.\");Out.Ln;\n    ELSE\n      Out.String(\"Glad to meet you \");Out.String(s);Out.Ln;\n    END;\n```\n\n## ASSERT\n\nThe second expression, ASSERT, is a little different. If ASSERT\nevaluates an expression that is FALSE then your program is halted.\nThis is like combining an \"if EXPR is false then system exit\".\n\n```Oberon\n    Out.String(\"Should I continue? Y/n \");\n    In.Line(s);\n    Out.Ln;\n    ASSERT((s = \"Y\") OR (s = \"y\"));\n    (* If you didn't enter Y or y the program will halt *)\n```\n\n\n## WHILE DO, ELSIF DO\n\nOberon-07 also provides two loop structures. These are very \nsimilar to other languages as well. The only expectation is that\na while loop may contain an ELSIF which continues the loop\nexecution until both clauses return FALSE.\n\nThe basic while loop, counting 1 to 10.\n\n```Oberon\n    i := 0;\n    WHILE i < 10 DO\n       i := i + 1;\n       Out.Int(i, 1);Out.String(\" \");\n    END;\n```\n\nA while, elsif loop, counting 1 to 10, then 10 to 100 by 10.\n\n```Oberon\n    i := 0;\n    WHILE i < 10 DO\n       i := i + 1;\n       Out.Int(i, 1); Out.String(\" \");\n    ELSIF i < 100 DO\n       i := i + 10;\n       Out.Int(i, 1);Out.String(\" \");\n    END;\n```\n\n\n## FOR Loops\n\nThe FOR loop in Oberon is very similar to modern FOR loops.\nThe FOR loop increments an integer value with in a range.\nYou the default increments the start value by 1 but if a \nBY clause is included you can control how the increment value\nworks.\n\nRegular for loop, `i` is incremented by 1.\n\n```Oberon\n    FOR i := 1 TO 10 DO\n       Out.Int(i, 1);Out.String(\" \");\n    END;\n```\n\nUsing a BY clause incrementing `i` by 2.\n\n```Oberon\n    FOR i := 0 TO 20 BY 2  DO\n       Out.Int(i, 1);Out.String(\" \");\n    END;\n```\n\n\n## Putting it all together\n\nThe following [module](LoopsAndConditions.Mod) demonstrates\nthe conditional and loop syntax.\n\n```Oberon\n    MODULE LoopsAndConditions;\n      IMPORT In, Out;\n    \n    PROCEDURE IfElsifElseDemo;\n      VAR s : ARRAY 128 OF CHAR;\n    BEGIN\n      Out.String(\"Enter your name: \");\n      In.Line(s);\n      Out.Ln;\n      IF (s = \"Freda\") OR (s = \"Mojo\") THEN\n        Out.String(\"Wowie Zowie! I remember you from ZBS stories.\");Out.Ln;\n      ELSIF (s = \"Bilbo\") OR (s = \"Gandolf\") THEN\n        Out.String(\"Greets, I remember from the Hobbit.\");Out.Ln;\n      ELSE\n        Out.String(\"Glad to meet you \");Out.String(s);Out.Ln;\n      END;\n    END IfElsifElseDemo;\n    \n    PROCEDURE AssertDemo;\n      VAR s : ARRAY 128 OF CHAR;\n    BEGIN\n      Out.String(\"Should I continue? Y/n \");\n      In.Line(s);\n      Out.Ln;\n      ASSERT((s = \"Y\") OR (s = \"y\"));\n    END AssertDemo;\n    \n    PROCEDURE WhileDemo;\n      VAR i : INTEGER;\n    BEGIN\n      Out.String(\"Basic WHILE counting from 1 to 10\");Out.Ln;\n      i := 0;\n      WHILE i < 10 DO\n         i := i + 1;\n         Out.Int(i, 1);Out.String(\" \");\n      END;\n      Out.Ln;\n      Out.String(\"WHILE ELSIF, count 1 to 10 THEN 10 to 100\");Out.Ln;\n      i := 0;\n      WHILE i < 10 DO\n         i := i + 1;\n         Out.Int(i, 1); Out.String(\" \");\n      ELSIF i < 100 DO\n         i := i + 10;\n         Out.Int(i, 1);Out.String(\" \");\n      END;\n      Out.Ln;\n      Out.String(\"Demo of while loop counting one to ten, then by tenths.\");\n    END WhileDemo;\n    \n    PROCEDURE ForDemo;\n      VAR i : INTEGER;\n    BEGIN\n      Out.String(\"Basic FOR LOOP counting from 1 to 10\");Out.Ln;\n      FOR i := 1 TO 10 DO\n         Out.Int(i, 1);Out.String(\" \");\n      END;\n      Out.Ln;\n      Out.String(\"FOR loop counting by twos 1 to 20\");Out.Ln;\n      FOR i := 0 TO 20 BY 2  DO\n         Out.Int(i, 1);Out.String(\" \");\n      END;\n      Out.Ln;\n    END ForDemo;\n    \n    BEGIN\n      IfElsifElseDemo;\n      AssertDemo;\n      WhileDemo;\n      ForDemo;\n    END LoopsAndConditions.\n```\n\n\n### Next and Previous\n\n+ Next [Combining Oberon-07 and C with OBNC](../../05/01/Combining-Oberon-and-C.html)\n+ Previous [Basic Types](../18/Mostly-Oberon-Basic-Types.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-04-19",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 4,
        "series": "Mostly Oberon",
        "title": "Oberon Loops and Conditions"
      },
      "url": "posts/2020/04/19/Mostly-Oberon-Loops-and-Conditions.json"
    },
    {
      "content": "\n\n# Combining Oberon-07 and C with OBNC\n\nBy R. S. Doiel, 2020-05-01\n\nThis is the fifth post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html)\nseries. Mostly Oberon documents my exploration of the Oberon\nLanguage, Oberon System and the various rabbit holes I will\ninevitably fall into.\n\nIn my day job I write allot of code in Go and\norchestration code in Python.  It's nice having\nthe convenience of combining code written one\nlanguage with an another.  You can do the same\nwith [OBNC](https://miasap.se/obnc/).  The OBNC\ncompiler supports inclusion of C code in a\nstraight forward manner. In fact Karl's compiler\nwill generate the C file for you!\n\nIn learning how to combine C code and Oberon-07\nI started by reviewing Karl's [manual page](https://miasap.se/obnc/man/obnc.txt).\nThe bottom part of that manual page describes\nthe steps I will repeat below. The description\nsounds more complicated but when you walk through\nthe steps it turns out to be pretty easy.\n\n## Basic Process\n\nCreating a C extension for use with OBNC is very\nstraight forward.\n\n1. Create a Oberon module with empty exported procedures\n2. Create a Oberon test module that uses your module\n3. Compile your test module with OBNC\n4. Copy the generated module `.c` file to the same directory as your Oberon module source\n5. Edit the skeleton `.c`,  re-compile and test\n\nFive steps may sound complicated but in practice is\nstraight forward.\n\n## Fmt, an example\n\nIn my demonstration of Karl's instructions I will be\ncreating a module named `Fmt` that includes two\nprocedures `Int()` and `Real()` that let you use\na C-style format string to format an INTEGER\nor REAL as an ARRAY OF CHAR. We retain the idiomatic\nway Oberon works with types but allow a little more\nflexibility in how the numbers are converted and\nrendered as strings.\n\n### Step 1\n\nCreate [Fmt.Mod](Fmt.Mod) defining two exported procedures\n`Int*()` and `Real*()`. The procedures body should be\nempty. Karl's practice is to use exported comments to\nexplain the procedures.\n\n\n~~~ {.oberon}\n\n    MODULE Fmt;\n\n    \tPROCEDURE Int*(value : INTEGER; fmt: ARRAY OF CHAR;\n                       VAR dest : ARRAY OF CHAR);\n    \tEND Int;\n\n    \tPROCEDURE Real*(value : REAL; fmt: ARRAY OF CHAR;\n                        VAR dest : ARRAY OF CHAR);\n    \tEND Real;\n\n    BEGIN\n    END Fmt.\n\n~~~\n\n\n### Step 2\n\nCreate a test module, [FmtTest.Mod](FmtTest.Mod), for\n[Fmt.Mod](Fmt.Mod).\n\n\n~~~ {.oberon}\n\n    MODULE FmtTest;\n      IMPORT Out, Fmt;\n\n    PROCEDURE TestInt(): BOOLEAN;\n      VAR\n        fmtString : ARRAY 24 OF CHAR;\n        dest : ARRAY 128 OF CHAR;\n        i : INTEGER;\n    BEGIN\n        i := 42;\n        fmtString := \"%d\";\n        Fmt.Int(i, fmtString, dest);\n        Out.String(dest);Out.Ln;\n        RETURN TRUE\n    END TestInt;\n\n    PROCEDURE TestReal(): BOOLEAN;\n      VAR\n        fmtString : ARRAY 24 OF CHAR;\n        dest : ARRAY 128 OF CHAR;\n        r : REAL;\n    BEGIN\n        r := 3.145;\n        fmtString := \"%d\";\n        Fmt.Real(r, fmtString, dest);\n        Out.String(dest);Out.Ln;\n        RETURN TRUE\n    END TestReal;\n\n    BEGIN\n      ASSERT(TestInt());\n      ASSERT(TestReal());\n      Out.String(\"Success!\");Out.Ln;\n    END FmtTest.\n\n~~~\n\n\n### Step 3\n\nGenerate a new [Fmt.c](Fmt.c) by using the\nOBNC compiler.\n\n\n~~~ {.shell}\n\n    obnc FmtTest.Mod\n    mv .obnc/Fmt.c ./\n\n~~~\n\n\nthe file `.obnc/Fmt.c` is your C template file. Copy it\nto the directory where Fmt.Mod is.\n\n### Step 4\n\nUpdate the skeleton `Fmt.c` with the necessary C code.\nHere's what OBNC generated version.\n\n\n~~~ {.c}\n\n    /*GENERATED BY OBNC 0.16.1*/\n\n    #include \"Fmt.h\"\n    #include <obnc/OBNC.h>\n\n    #define OBERON_SOURCE_FILENAME \"Fmt.Mod\"\n\n    void Fmt__Int_(OBNC_INTEGER value_, const char fmt_[], \n                   OBNC_INTEGER fmt_len, char dest_[], \n                   OBNC_INTEGER dest_len)\n    {\n    }\n\n\n    void Fmt__Real_(OBNC_REAL value_, const char fmt_[],\n                    OBNC_INTEGER fmt_len, char dest_[],\n                    OBNC_INTEGER dest_len)\n    {\n    }\n\n\n    void Fmt__Init(void)\n    {\n    }\n\n~~~\n\n\nHere's the skeleton revised with do what we need to be done.\n\n\n~~~ {.c}\n\n    #include \".obnc/Fmt.h\"\n    #include <obnc/OBNC.h>\n    #include <stdio.h>\n\n    #define OBERON_SOURCE_FILENAME \"Fmt.Mod\"\n\n    void Fmt__Int_(OBNC_INTEGER value_, \n                   const char fmt_[], OBNC_INTEGER fmt_len,\n                   char dest_[], OBNC_INTEGER dest_len)\n    {\n        sprintf(dest_, fmt_, value_);\n    }\n\n\n    void Fmt__Real_(OBNC_REAL value_, const char fmt_[],\n                    OBNC_INTEGER fmt_len, char dest_[],\n                    OBNC_INTEGER dest_len)\n    {\n        sprintf(dest_, fmt_, value_);\n    }\n\n\n    void Fmt__Init(void)\n    {\n    }\n\n~~~\n\n\nNOTE: You need to change the path for the `Fmt.h` file reference.\nI also add the `stdio.h` include so I have access to the C\nfunction I wish to use. Also notice how OBNC the signature\nfor the functions use the `_` character to identify mapped values\nas well as the char arrays being provided with a length parameter.\nIf you are doing more extensive string work you'll want to take\nadvantage of these additional parameters so insure that the\nas strings are terminated properly for Oberon's reuse.\n\n\n### Step 5\n\nRecompile and test.\n\n\n~~~ {.shell}\n\n    obnc FmtTest.Mod\n    ./FmtTest\n\n~~~\n\n\n### Next and Previous\n\n+ Next [Compiling OBNC on macOS](../06/Compiling-OBNC-on-macOS.html)\n+ Previously [Oberon Loops and Conditions](../../04/19/Mostly-Oberon-Loops-and-Conditions.html)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-05-01",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 5,
        "series": "Mostly Oberon",
        "title": "Combining Oberon-07 and C with OBNC"
      },
      "url": "posts/2020/05/01/Combining-Oberon-and-C.json"
    },
    {
      "content": "\nCompiling OBNC on macOS \n=======================\n\nBy R. S. Doiel, 2020-05-06\n\nThis is the sixth post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\nCompiling OBNC v0.16.1 on macOS (10.13.6) using MacPorts (2.6.2) \nis straight forward if you have the required dependencies and \nenvironment setup up. Below are my notes to get everything working.\n\n## Prerequisites\n\n+ OBNC v0.16.1\n+ SDL v1.2\n+ Boehm-Demers-Weiser GC\n+ A C compiler and linker (OBNC uses this to generate machine specific code)\n\n### SDL 1.2\n\nMacPorts has libsdl 1.2 available as a package called \"libsdl\"\n(not surprisingly). There are other versions of the SDL available\nin ports but this is the one we're using.\n\n\n~~~\n\n   sudo port install libsdl\n\n~~~\n\n\n### The Boehm-Demers-Weiser GC\n\nYou need to install the Boehm-Demers-Weiser GC installed. Using\nMacPorts it is almost as easy as installing under Debian. The\npackage is less obviously named than under Debian. The package\nyou want is \"beohmgc\".\n\n\n~~~\n\n    sudo port install boehmgc\n\n~~~\n\n\nMore info on the GC.\n\n+ [The Boehm-Demers-Weiser GC](https://www.hboehm.info/gc/)\n+ [MacPorts page](https://ports.macports.org/port/boehmgc/summary)\n\n### C compiler and linker\n\nXCode is provides a C compiler and linker. That is what is installed on my\nmachine. It can be a bit of a pain at times with obscure errors, particularly with regards to the linker. Your milleage may very. I know you can\ninstall other C compilers (e.g. Clang) but I haven't tried them yet.\n\n## Setting up my environment\n\nYou need to update your CC variables to find the header and\nshared library files for compilation of obnc with `build`. (I added\nthese to my `.bash_profile`). New Macs ships with zsh and\nyour settings might be in a different location. MacPorts puts \nits libraries under the `/opt/local` directory.\n\n\n~~~\n\n    export C_INCLUDE_PATH=\"/usr/include:/usr/local/include:/opt/local/include\"\n    export LIBRARY_PATH=\"/usr/lib:/usr/local/lib:/opt/local/lib\"\n    export LD_LIBRARY_PATH=\"/usr/lib:/usr/local/lib:/opt/local/lib\"\n\n~~~\n\n\n## OBNC environment variables\n\nThis follows' Karl's docs.  Additionally if you install OBNC extlib so\nyou can do POSIX shell programs you'll need to set your\n`OBNC_IMPORT_PATH` environment.  An example of including a default\ninstall location and local home directory location.\n\n\n~~~\n\n    export OBNC_IMPORT_PATH=\"/usr/local/lib/obnc:$HOME/lib/obnc\"\n\n~~~\n\n\n### Next and Previous\n\n+ Next [Oberon-07 and the file system](../09/Oberon-07-and-the-filesystem.html)\n+ Previous [Combining Oberon-07 and C](../01/Combining-Oberon-and-C.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-05-06",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 6,
        "series": "Mostly Oberon",
        "title": "Compiling OBNC on macOS"
      },
      "url": "posts/2020/05/06/Compiling-OBNC-on-macOS.json"
    },
    {
      "content": "\n\n# Oberon-07 and the file system\n\nBy R. S. Doiel, 2020-05-09 (updated: 2021-10-29)\n\nThis is the seventh post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\n## Working with files in Oberon-07\n\nIn a POSIX system we often talk of opening files,\nwriting and reading files and close files. The Oberon\nlanguage reflects a more Oberon System point of view.\n\nThe Oberon System generally avoids modality in favor\nof action. Modality is where a context must be set\nbefore a set of actions are possible. The `vi` \ntext editor is a \"modal\" editor. You are in either\nedit (typing) mode or command mode. At the function\nlevel POSIX's `open()`, is also modal. You can \nopen a file for reading, open a file for writing,\nyou can open a file for appending, etc. The Oberon\nlanguage and base modules avoids modality.\n\nThe Oberon System is highly interactive but\nhas a very different idea about code, data and computer\nresources. In POSIX the basic unit of code is a program\nand the basic unit of execution is a program. In Oberon\nthe basic unit of code is the module and the basic unit\nof execution is the procedure.  Modules are brought into \nmemory and persist. As a result it is common in \nthe Oberon System to need to have file representations \nthat can persist across procedure calls. It provides\na set of abstractions that are a little bit like views\nand cursors found in database systems. In taking\nthis approach Oberon language eschews modality at the\nprocedure level. \n\nNOTE: Modules can be explicitly unload otherwise they persist until the computer is turned off\n\n## Key Oberon Concepts\n\nThe following are exported in the `Files` module.\n\nFile\n: is a handle to the representation of a file, a File and Rider form a view into a file.\n\nRider\n: similar to a database cursor, it is the mechanism that lets you navigate in a file\n\nNew\n: Creates a new file (in memory but not on disc).\n\nRegistration\n: Associates a file handle created with New with the file system. A file must be registered to persist in the file system.\n\nOld\n: Opens an existing file for use.\n\nSet\n: Set the position of a rider in a file\n\nPos\n: Gets the position of a rider in a file\n\nClose\n: Writes out unwritten buffers in file to disc, file handle is still value as is the rider.\n\nPurge\n: Sets a file's length to zero.\n\nDelete\n: Unregister the filename with the file system.\n\nIn the Oberon Systems a file can be \"opened\" many\ntimes with only one copy maintained in memory. This allows\nefficient operations across a module's procedures.\nLikewise a file can have one or more Riders associated with\nit. Each rider can move through the file independently operating on\nthe common in memory file. If a file is created with `New` but\nnot registered it can be treated like an in-memory temp file.\nClosing a file writes its buffers but the file remains accessible\nthrough it handle and riders. If a file is not modified it\ndoesn't need to be closed.\n\nIn POSIX we generally want to explicitly close the file when\nwe're through. In the Oberon language we only need to close\na file if we've modified it.\n\nThe behavior of files and riders in Oberon creates interesting\nnuances around deleting files.  The Delete operation can in\nprinciple happen multiple times before the file is deleted on\ndisc.  That is because the file handles and riders may still\nbe operating on it.  To know when a file is finally deleted \nwhen `Delete` procedure is called it includes a results\nparameter. When that value is set to zero by the `Delete`\nprocedure you know your file has been deleted.\n\nThe `Files` module provides a number of methods\nto read and write basic Oberon types. These use the rider\nrather than the file handle. Calling them automatically\nupdates the riders position. The procedures themselves\nmap to what we've seen in the modules `In` and `Out`.  \nThere are a few additional commands for file system house \nkeeping such as `Length`, `GetDate`, `Base`.\nSee the OBNC documentation for the `Files` module for\ndetails <https://miasap.se/obnc/obncdoc/basic/Files.def.html>.\n\nIn the following examples we'll be using the `Files`\nmodule to create, update and delete a file called \n`HelloWorld.txt`.\n\n### Creating a file\n\nThe recipe we want to follow for creating a file is\nNew (creates an empty file in memory), Register\n(associations the filename with the file system), \nSet the rider position, with the rider write our\ncontent and with the file call close because we've\nhave changed the file.\n\nLike our origin `SayingHi` we'll demonstrate this code\nin a new module called `TypingHi.Mod`. Below is\na procedure called `WriteHelloWorld`. It shows how\nto create, write and close the new file called\n\"HelloWorld.txt\".\n\n\n~~~\n\n  PROCEDURE WriteHelloWorld;\n    VAR\n      (* Define a file handle *)\n      f : Files.File;\n      (* Define a file rider *)\n      r : Files.Rider;\n  BEGIN\n    (* Create our file, New returns a file handle *)\n    f := Files.New(\"HelloWorld.txt\");\n    (* Register our file with the file system *)\n    Files.Register(f);\n    (* Set the position of the rider to the beginning *)\n    Files.Set(r, f, 0);\n    (* Use the rider to write out \"Hello World!\" *)\n    Files.WriteString(r, \"Hello World!\");\n    (* Write a end of line *)\n    Files.Write(r, 10);\n    (* Close our modified file *)\n    Files.Close(f);\n  END WriteHelloWorld;\n\n~~~\n\n\n#### Receipt in review\n\n+ New, creates our file\n+ Register, associates the file handle with the file system \n+ Set initializes the rider's position\n+ WriteString, writes our \"Hello World!\" to the file\n+ Close, closes the file, flushing unwritten content to disc\n\n\n### Working with an existing file\n\nIf we're working with an existing file we swap `New` for \na procedure named `Old`. We don't need to register the\nfile because it already exists.  We still need to set\nour rider and we want to read back the string we previously wrote.\nWe don't need to close it because we haven't\nmodified it. To demonstrate a new procedure is added to\nour module called `ReadHelloWorld`.\n\n\n~~~\n\n  PROCEDURE ReadHelloWorld;\n    VAR\n      f : Files.File;\n      r : Files.Rider;\n      (* We need a string to store what we have read *)\n      src : ARRAY 256 OF CHAR;\n  BEGIN\n    (* Create our file, New returns a file handle *)\n    f := Files.Old(\"HelloWorld.txt\");\n    (* Set the position of the rider to the beginning *)\n    Files.Set(r, f, 0);\n    (* Use the rider to write out \"Hello World!\" *)\n    Files.ReadString(r, src);\n    (* Check the value we read, if it is not the name, \n       halt the program with an error *)\n    ASSERT(src = \"Hello World!\");\n  END ReadHelloWorld;\n\n~~~\n\n\n#### Receipt in review\n\n+ Old, gets returns a file handle for an existing file\n+ Set initializes the rider's position\n+ ReadString, read our \"Hello World!\" string from the file\n+ Check the value we read with an ASSERT\n\n### Removing a file\n\nDeleting the file only requires knowing the name of the file.\nLike in `ReadHelloWorld` we'll use the built-in ASSERT\nprocedure to check if the file was successfully removed.\n\n\n~~~\n\n  PROCEDURE DeleteHelloWorld;\n    VAR\n      result : INTEGER;\n  BEGIN\n    (* Delete our file *)\n    Files.Delete(\"HelloWorld.txt\", result);\n    (* Check our result, if not zero then halt program with error *)\n    ASSERT(result = 0);\n  END DeleteHelloWorld;\n\n~~~\n\n\n#### Receipt in review\n\n+ Delete the file setting a result value\n+ Check the value with ASSERT to make sure it worked\n\n## Putting it all together.\n\nHere is the full listing of our module.\n\n\n~~~\n\n    MODULE TypingHi;\n      IMPORT Files;\n    \n      PROCEDURE WriteHelloWorld;\n        VAR\n          (* Define a file handle *)\n          f : Files.File;\n          (* Define a file rider *)\n          r : Files.Rider;\n      BEGIN\n        (* Create our file, New returns a file handle *)\n        f := Files.New(\"HelloWorld.txt\");\n        (* Register our file with the file system *)\n        Files.Register(f);\n        (* Set the position of the rider to the beginning *)\n        Files.Set(r, f, 0);\n        (* Use the rider to write out \"Hello World!\" *)\n        Files.WriteString(r, \"Hello World!\");\n        (* Write a end of line *)\n        Files.Write(r, 10);\n        (* Close our modified file *)\n        Files.Close(f);\n      END WriteHelloWorld;\n    \n      PROCEDURE ReadHelloWorld;\n        VAR\n          f : Files.File;\n          r : Files.Rider;\n          (* We need a string to store what we have read *)\n          src : ARRAY 256 OF CHAR;\n      BEGIN\n        (* Create our file, New returns a file handle *)\n        f := Files.Old(\"HelloWorld.txt\");\n        (* Set the position of the rider to the beginning *)\n        Files.Set(r, f, 0);\n        (* Use the rider to write out \"Hello World!\" *)\n        Files.ReadString(r, src);\n        (* Check the value we read, if it is not the name, \n           halt the program with an error *)\n        ASSERT(src = \"Hello World!\");\n      END ReadHelloWorld;\n    \n      PROCEDURE DeleteHelloWorld;\n        VAR\n          result : INTEGER;\n      BEGIN\n        (* Delete our file *)\n        Files.Delete(\"HelloWorld.txt\", result);\n        (* Check our result, if not zero then halt program with error *)\n        ASSERT(result = 0);\n      END DeleteHelloWorld;\n    \n    BEGIN\n        WriteHelloWorld();\n        ReadHelloWorld();\n        DeleteHelloWorld();\n    END TypingHi.\n\n~~~\n\n## Post Script, 2021-10-29\n\nOn October 29, 2021 I had an email conversation with Jules. It pointed out a problem in this implementation of Hello World.  I had incorrectly coded the end of line with `Files.WriteString(r, 0AX);` this is wrong.  At best it should have been `Files.Write(r, 10);`. There remains an issues with `Files.WriteString(\"Hello World!\");`. The Oakwood module `Files` defines \"WriteString\" to include the trailing NULL character. This will be output in the file. It all depends on how close to the Oakwood specification that your compiler implements the `Files` module.\n\n\n\n### Next and Previous\n\n+ Next [Dynamic Types](../25/Dynamic-types.html)\n+ Previous [Compiling OBNC on macOS](../06/Compiling-OBNC-on-macOS.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-05-09",
        "keywords": [
          "Oberon",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 7,
        "series": "Mostly Oberon",
        "title": "Oberon-07 and the file system",
        "updated": "2021-10-29"
      },
      "url": "posts/2020/05/09/Oberon-07-and-the-filesystem.json"
    },
    {
      "content": "\n\n# Dynamic types\n\nBy R. S. Doiel, 2020-05-25\n\nThis is the eighth post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html)\nseries. Mostly Oberon documents my exploration of the Oberon Language, \nOberon System and the various rabbit holes I will inevitably fall into.\n\n## Dynamic Types in Oberon\n\nOberon-07 is a succinct systems language. It provides a minimal\nbut useful set of basic static types. Relying on them addresses \nmany common programming needs. The Oberon compiler ensures \nstatic types are efficiently allocated in memory. One of the \nstrengths of Oberon is this ability to extend the type system. \nThis means when the basic types fall short you can take \nadvantage of Oberon's type  extension features. This includes \ncreating dynamically allocated data structures. In Oberon-07 \ncombining Oberon's `POINTER TO` and `RECORD` types allows us to\ncreate complex and dynamic data structures. \n\n\n## An example, dynamic strings \n\nStrings in Oberon-07 are typical declared as an `ARRAY OF CHAR` \nwith a specific length. If the length of a string is not \nknown a head of time this presents a challenge. One approach is \nto declare a long array but that would allocate allot of memory \nwhich may not get used. Another approach is to create a dynamic\ndata structure. An example is using a linked list of shorter \n`ARRAY OF CHAR`.  The small fixed strings can combine to \nrepresent much larger strings. When one fills up we add \nanother. \n\n### Pointers and records, an Oberon idiom \n\nOur data model is a pointer to a record where the record \ncontains an `ARRAY OF CHAR` and a pointer to the next record. \nA common idiom in Oberon for dynamic types is to declare a \n`POINTER TO` type and declare a `RECORD` type which contains\nthe `POINTER TO` type as an attribute.  If you see this idiom \nyou are looking at some sort of dynamic data structure. The \npointer type is usually named for the dynamic type you want \nwork with and the record type is declared using the same name \nwith a \"Desc\" suffix. In our case `DynamicString` will be the \nname of our `POINTER TO` type and our record type will be \ncalled `DynamicStringDesc` following the convention.  In our \nrecord structure we include a \"value\" to holding a short \nfixed length `ARRAY OF CHAR`  and a \"next\" to holding the \npointer to our next record.\n\nIn our record the value is declared as a static type. We need\nto know how long our \"short\" string should be? I.e. What length\nis our `ARRAY OF CHAR`? It's a question of tuning. If it is too \nshort we spend more time allocating new records, too long and \nwe are wasting memory in each record. A way to make tuning a \nlittle simpler is to use a constant value to describe our array \nlength. Then if we decide our array is too big \nor too small we can adjust the constant knowing that our record \nstructure and the procedures that use that the length \ninformation will continue to work correctly. \n\nLet's take a look at actual code (NOTE: vSize is our constant value). \n\n~~~\n\n    CONST\n      vSize = 128; \n    \n    TYPE\n      DynamicString* = POINTER TO DynamicStringDesc;\n      DynamicStringDesc* = RECORD \n        value : ARRAY vSize OF CHAR; \n        next : DymamicString; \n      END;\n\n~~~\n\nNOTE: Both `DynamicString` and `DynamicStringDesc` are defined \nusing an `*`. These are public and will be available \nto other modules.  Inside our record `DynamicStringDesc` we \nhave two private to our module attributes, `.value` and \n`.next`. They are private so that we can change our \nimplementation in the future without requiring changes in \nmodules that use our dynamic strings. Likewise our constant `vSize`\nis private as that is an internal implementation detail. This\npractice is called information hiding.\n\nNOTE: The asterisk in Oberon decorates procedures, types, variables\nand constants that are \"public\" to other modules.\n\nNOTE: Variables are always exported read only.\n\nNOTE: With information hiding some details of implementation allow us \nto keep a clean division between implementation inside the module and how\nthat implementation might be used. With out information hiding we often\nhave \"leaky\" abstractions that become brittle and hard to maintain and\nrely on.\n\n\n\n## Working with DynamicString\n\nOur type definitions describe to the compiler how to layout our \ndata in memory. The type system in Oberon-07 also ensures that \naccess to that memory is restricted to assignments, operations \nand procedures compatible with that type. To be useful from \nother modules we need a few procedures to help work with\nthis new data type. What follows is a minimal set needed to be \nuseful.\n\n### `New*(VAR str : DynamicString)`\n\n`New` will initialize a DynamicString object setting `.value` to \nan empty string. \n\n\n~~~\n\n  PROCEDURE New*(VAR str : DynamicString);\n  BEGIN NEW(str);\n    str.value := \"\"; \n    str.next := NIL;\n  END New;\n\n~~~\n\n\n### `Set*(VAR str : DynamicString; source : ARRAY OF CHAR)` \n\n`Set` copies an `ARRAY OF CHAR` into an existing DynamicString. \nThis requires that we add and link additional records if the \n`source` is longer than our current dynamic string. Set is a \nbridge procedure between an existing datatype, `ARRAY OF CHAR` \nand our new data type, `DynamicString`.\n\n\n~~~\n\n  PROCEDURE Set*(VAR str : DynamicString; source : ARRAY OF CHAR); \n    VAR cur, next : DynamicString; tmp : ARRAY vSize OF CHAR; \n        i, l : INTEGER;\n  BEGIN cur := str; cur.value := \"\";\n    l := Strings.Length(source);\n    i := 0; \n    WHILE i < l DO\n      Strings.Extract(source, i, i + vSize, tmp);\n      Strings.Append(tmp, cur.value);\n      i := i + Strings.Length(tmp);\n      IF (i < l) THEN\n        IF cur.next = NIL THEN\n          New(next); cur.next := next;\n        END;\n        cur := cur.next;\n      END; \n    END;\n  END Set;\n\n~~~\n\n### `ToCharArray*(str : DynamicString; VAR dest : ARRAY OF CHAR; VAR ok : BOOLEAN)`\n\n`ToCharArray` copies the contents of our dynamic string into an array \nof char setting `ok` to TRUE on success or FALSE if truncated. \nLike `Set*` it is a bridge procedure to let us move data output \nour new dynamic string type.\n\n\n~~~\n\n  PROCEDURE ToCharArray*(str : DynamicString; \n                         VAR dest : ARRAY OF CHAR; \n                         VAR ok : BOOLEAN);\n    VAR cur : DynamicString; i : INTEGER;\n  BEGIN \n    ok := FALSE;\n    cur := str; i := 0;\n    WHILE cur # NIL DO\n      i := i + Strings.Length(cur.value);\n      Strings.Append(cur.value, dest);\n      cur := cur.next;\n    END;\n    ok := (i = Strings.Length(dest));\n  END ToCharArray;\n\n~~~\n\nTwo additional procedures will likely be needed-- `Append` and \n`AppendCharArray`. This first one is trivial, if we want to add \none dynamic string onto another all we need to do is link the \nlast record of the first and point it to a copy of the second string we're appending.\n\n\n### `Append*(extra : DynamicString; VAR dest : DynamicString);`\n\n`Append` adds the `extra` dynamic string to `dest` dynamic string. Our \n\"input\" is `extra` and our output is a modified dynamic string \nnamed `dest`. This parameter order mimics the standard \n`Strings` module's `Append`.\n\nNOTE: Oberon idiom is often input values, modified value and \nresult values. Modified and result values are declared in the parameter\ndefinition using `VAR`.\n\nAlgorithm:\n\n1. Move to the end of `dest` dynamic string\n2. Create a new record at `cur.next`.\n3. Copy `extra.value` info.value `cur.next.value`\n4. Advance `extra` and `cur`, repeating steps 2 to 4 as needed.\n\nImplemented procedure.\n\n~~~\n\n  PROCEDURE Append*(extra: DynamicString; VAR dest : DynamicString);\n    VAR cur : DynamicString;  \n  BEGIN\n    (* Move to the end of the dest DynamicString *)\n    cur := dest;\n    WHILE cur.next # NIL DO cur := cur.next; END;\n    (* Starting initial pointer of `extra` copy its records\n       input new records created in `cur`. *)\n    WHILE extra # NIL DO\n      (* Create a new record *)\n      NEW(cur.next);\n      cur.next.value := \"\";\n      cur.next.next := NIL;\n      (* Copy extra.value into new record *)\n      Strings.Extract(extra.value, 0, vSize, cur.next.value);\n      (* Advance to next record for both cur and extra *)\n      extra := extra.next;\n      cur := cur.next;\n    END;\n  END Append;\n\n~~~\n\nA second procedure for appending an `ARRAY OF CHAR` also \nbecomes trivial. First convert the `ARRAY OF CHAR` to a dynamic \nstring then append it with the previous procedure.\n\n### `AppendCharArray*(src : ARRAY OF CHAR; VAR str : DynamicString);`\n\nThis procedure appends an ARRAY OF CHAR to an existing dynamic string.\n\n~~~\n\n  PROCEDURE AppendCharArray*(extra: ARRAY OF CHAR; VAR dest : DynamicString);\n    VAR extraStr : DynamicString;    \n  BEGIN\n    (* Convert our extra ARRAY OF CHAR into a DynamicString *)\n    New(extraStr); Set(extraStr, extra);\n    (* Now we can append. *)\n    Append(extraStr, dest);\n  END AppendCharArray;\n\n~~~\n\nAt some point we will want to know the length of our dynamic string.\n\n### `Length(str : DynamicString) : INTEGER`\n\nOur `Length` needs to go through our linked list and total up \nthe length of each value. We will use a variable called `cur` \nto point at the current record and add up our total length as \nwe walk through the list.\n\n~~~\n\n  PROCEDURE Length*( source : DynamicString) : INTEGER;\n    VAR cur : DynamicString; total : INTEGER;\n  BEGIN\n    total := 0;\n    cur := source;\n    WHILE cur # NIL DO\n      total := total + Strings.Length(cur.value);\n      cur := cur.next;\n    END; \n    RETURN total\n  END Length;\n\n~~~\n\n## Extending DynamicStrings module\n\nWith these few procedures we have a basic means of working with \ndynamic strings. Moving beyond this we can look at the standard \nOberon `Strings` module for inspiration.  If we use similar \nprocedure signatures we can create a drop in replacement \nfor `Strings` with `DynamicStrings`.\n\nNOTE: Procedure signatures refer to procedures type along \nwith the order and types of parameters. A quick review of the \nprocedure signatures for the standard module [Strings](https://miasap.se/obnc/obncdoc/basic/Strings.def.html) is \nprovided by the [OBNC](https://miasap.se/obnc) compiler docs. \n\nLet's look at recreating `Insert` as a potential guide to\na more fully featured [\"DynamicStrings.Mod\"](DynamicStrings.Mod). \nIn our `Insert` we modify the procedure signature so the \nsource and destinations are dynamic strings.\n\n\n### `Insert(source : DynamicString; pos : INTEGER; VAR dest : DynamicString)`\n\nThe `Insert` procedure inserts a `source` dynamic string at the \nposition provided into our `dest` dynamic string. We are implementing\nthe same signature  for our `DynamicStrings.Insert()` as \n`Strings.Insert()`. Only the parameters for source and destination\nare changed to `DynamicString`.\n\nInternally our procedure for `Insert` is a more complicated than\nthe ones we've written so far. It needs to do all the housing \nkeeping for making sure we add the right content in the correct\nspot.  The general idea is to find the record holding the split \npoint. Split that record into two records. The first retains \nthe characters before the insert position. The second holds the \ncharacters after the insert position and points to next record \nin the dynamic string. Once the split is accomplished it then \nis a matter of linking everything up. The record before the \ninsert position is set to point at the dynamic string to be \ninserted, the inserted dynamic string is set to point at the \nrecord that contained the rest of the characters after the \nsplit.\n\nIt is easy to extract a sub-string from an `ARRAY OF CHAR` \nusing the standard `Strings` module.  We can store the characters\nin the `.value` of the record after the split in a temporary \n`ARRAY OF CHAR`.  The temporary `ARRAY OF CHAR` can be used to \ncreate a new dynamic string record which will be linked to the \nrest of our destination dynamic string. The record which held \nthe characters before the insert position needs to be truncated \nand it needs to be linked to the dynamic string we want to \ninsert. NOTE: This will leave a small amount of unused \nmemory.\n\nNOTE: If conserving memory is critical then re-packing the \ndynamic string could be implemented as another procedure. The \ncost would be complexity and time to shift characters between \nlater records and earlier ones replacing excess NULL values.\n\nWe need to find the record where the split will occur. In the \nrecord to be split we need to calculate a relative \nsplit point. We then can copy the excess characters in that \nsplit record to a new record and truncate the `.value`'s \n`ARRAY OF CHAR` to create our split point. Truncating is easy \nin that we replace the CHAR in the `.values` that are not \nneeded with a NULL character. We can do that with a \nsimple loop. Likewise calculating the relative insertion \nposition can be done by taking the modulo of the `vSize` of \n`.value`.\n\nNOTE: In Oberon stings are terminated with a NULL \ncharacter. A NULL character holds the ASCII value `0X`.\n\nOur algorithm:\n\n1. Set `cur` to point to the start of our destination dynamic string\n2. Move `cur` to the record in the link list where the insertion will take place\n3. Calculate the relative split point in `cur.value`\n4. Copy the characters in `cur.value` from relative split point to end of `.value` into a temporary `ARRAY OF CHAR`\n5. Make a new record, `rest`, using the temporary `ARRAY OF CHAR` and update the value of `.next` to match that of `cur.next`\n6. Truncate the record (cur) at the relative split point\n7. Set `cur.next` to point to our `extra` dynamic string.\n8. Move to the end of extra with `cur`\n9. Set the `cur.next` to point at `rest`\n\nOur procedure:\n\n~~~\n\n  PROCEDURE Insert*(extra : DynamicString; \n                    pos : INTEGER; \n                    VAR dest : DynamicString);\n    VAR cur, rest : DynamicString;\n        tmp : ARRAY vSize OF CHAR;\n        i, splitPos : INTEGER; continue : BOOLEAN;\n  BEGIN\n    (* 1. Set `cur` to the start of our `dest` dynamic string *)\n    cur := dest;\n\n    (* 2. Move to the record which holds the split point *)\n    i := 0;\n    continue := (i < pos);\n    WHILE continue DO\n      i := i + Strings.Length(cur.value);\n      continue := (i < pos);\n      IF continue & (cur.next # NIL) THEN\n        cur := cur.next;\n      ELSE\n        continue := FALSE;\n      END;\n    END;\n\n    (* 3. Copy the characters in `cur.value` from relative\n          split point to end of `.value` into a \n          temporary `ARRAY OF CHAR` *)\n    splitPos := pos MOD vSize;\n    Strings.Extract(cur.value, splitPos,\n                    Strings.Length(cur.value), tmp);\n\n    (* 4. Make a new record, `rest`, using the temporary \n          `ARRAY OF CHAR` and update the value of `.next` to\n          match that of `cur.next` *)\n    New(rest); Set(rest, tmp);\n    rest.next := cur.next;\n\n    (* 5. Truncate `cur.value` at the relative split point *)\n    i := splitPos;\n    WHILE i < LEN(cur.value) DO\n      cur.value[i] := 0X;\n      INC(i);\n    END;\n\n    (* 6. Set `cur.next` to point to our `extra`\n          dynamic string. *)\n    cur.next := extra;\n\n    (* 7. Move to the end of extra with `cur` *)\n    WHILE cur.next # NIL DO cur := cur.next; END;\n\n    (* 8. Set the `cur.next` to point at `rest` *)\n    cur.next := rest;\n  END Insert;\n\n~~~\n\nWhile our `Insert` is the longest procedure so far the steps \nare mostly simple. Additionally we can easily extend this to \nsupport inserting a more traditional `ARRAY OF CHAR` using our\npreviously established design pattern of converting a basic type\ninto our dynamic type before calling the dynamic version of the\nfunction.\n\n~~~\n\n  PROCEDURE InsertCharArray*(source : ARRAY OF CHAR; \n                             pos : INTEGER; \n                             VAR dest : DynamicString);\n    VAR extra : DynamicString;\n  BEGIN\n    New(extra); Set(extra, source);\n    Insert(extra, pos, dest);\n  END InsertCharArray;\n\n~~~\n\n## Where to go next\n\nIt is possible to extend our \"DynamicStrings.Mod\" into a drop \nin replacement for the standard `Strings`.  I've included a \nskeleton of that module as links at the end of this article \nwith stubs for the missing implementations such as `Extract`, \n`Replace`, `Pos`, and `Cap`.  I've also included a \n\"DynamicStringsTest.Mod\" for demonstrating how it works.\n\nThe procedure I suggest is to mirror `Strings` replacing the \nparameters that are `ARRAY OF CHAR` with `DynamicString`. It \nwill be helpful to include some bridging procedures that accept \n`ARRAY OF CHAR` as inputs too. These will use similar names \nwith a suffix of `CharArray`.\n\n## Parameter conventions and order\n\nOberon is highly composable. The trick to creating a drop in \nreplacement module is use the same parameter signatures so \nyou only need to make minor changes like updating the `IMPORT` \nstatement and using a module alias to map the old module to the\nnew one.  The parameter signatures in `Strings` follow a \nconvention you'll see in other Oberon modules. The parameter\norder is based on the \"inputs\", \"modify parameters\", and \n\"output parameters\". Inputs are non-`VAR` parameters. The \nremaining are `VAR` parameters. I think of \"modify parameters\" \nas those objects who reflect side effects. I think of \"output\" \nas values that in other languages would be returned by \nfunctions.  This is only a convention. A variation I've \nread in other Oberon modules is \"object\", \"inputs\", \"outputs\". \n\"object\" and \"outputs\" are `VAR` parameters and \"inputs\" are \nnot. This ordering makes sense when we think of records as \nholding an object. In both cases ordering is a convention \nand not enforced by the language.  Convention and consistency is \nhelpful but readability is the most important.  Oberon is a \nreadable language. It does not reward obfuscation. Readability is \na great virtue in a programming language. When creating your own \nmodules choose readability based on the concepts you want to\nemphasize in the module (e.g. procedural, object oriented).\n\n## The modules so far\n\nYou can read the full source for the module discussed along\nwith a test module in the links that follow.\n\n+ [DynamicStrings.Mod](DynamicStrings.Mod)\n+ [DynamicStringsTest.Mod](DynamicStringsTest.Mod)\n\n\n### Next and Previous \n\n+ Next [Procedures as parameters](../../06/20/Procedures-as-parameters.html)\n+ Previous [Oberon-07 and the file system](../09/Oberon-07-and-the-filesystem.html) \n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-05-25",
        "keywords": [
          "Oberon",
          "programming",
          "type extension",
          "dynamic data"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 8,
        "series": "Mostly Oberon",
        "title": "Dynamic types"
      },
      "url": "posts/2020/05/25/Dynamic-types.json"
    },
    {
      "content": "\n\n# Procedures as parameters\n\nBy R. S. Doiel, 2020-06-20\n\nThis is the ninth post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series.\nMostly Oberon documents my exploration of the Oberon Language, Oberon System and the \nvarious rabbit holes I will inevitably fall into.\n\nOberon-07 supports the passing of procedures as parameters in a procedure. \nLet's create a module name [Noises.Mod](Noises.Mod) to explore this.\n\nThe key to supporting this is Oberon's type system.  We need to decide what our \ngeneric procedure will look like first. In our case our procedures that will display \nan animal noise will include the name of the animal speaking.  We'll call this type \nof procedure \"Noise\". It'll accept an ARRAY OF CHAR for the name as a parameter \nthen use the standard Out module to display the animal name and noise they make.\n\n\n~~~\n\n    TYPE\n      Noise = PROCEDURE (who : ARRAY OF CHAR);\n\n~~~\n\n\nThe two \"Noise\" procedures will be \"BarkBark\" and \"ChirpChirp\". They will\nimplement the same parameter signature as describe in the \"Noise\" type.\n\n\n~~~\n\n    PROCEDURE BarkBark(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Bark, bark\");Out.Ln();\n    END BarkBark;\n\n    PROCEDURE ChirpChirp(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Chirp, chirp\");Out.Ln();\n    END ChirpChirp;\n\n~~~\n\n\nWe'll also create a procedure, MakeNoise, that accepts the animal name and\nour \"Noise\" procedure name and it'll call the \"Noise\" type procedure \npassing in the animal name.\n\n\n~~~\n\n    PROCEDURE MakeNoise(name : ARRAY OF CHAR; noise : Noise);\n    BEGIN\n      (* Call noise with the animal name *)\n      noise(name);\n    END MakeNoise;\n\n~~~\n\n\nIf we invoke MakeNoise with our animal name and pass the name of the \nprocedure we want to do the MakeNoise procedure will generate our\nnoise output. Here' is what is looks like all together.\n\n\n~~~\n\n    MODULE Noises;\n      IMPORT Out;\n    \n    TYPE \n      Noise = PROCEDURE(who : ARRAY OF CHAR);\n    \n    PROCEDURE BarkBark(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Bark, bark\");Out.Ln();\n    END BarkBark;\n    \n    PROCEDURE ChirpChirp(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Chirp, chirp\");Out.Ln();\n    END ChirpChirp;\n    \n    PROCEDURE MakeNoise(name : ARRAY OF CHAR; noise : Noise);\n    BEGIN\n      (* Call noise with the animal name *)\n      noise(name);\n    END MakeNoise;\n    \n    BEGIN\n      MakeNoise(\"Fido\", BarkBark);\n      MakeNoise(\"Tweety\", ChirpChirp);\n      MakeNoise(\"Fido\", ChirpChirp);\n      MakeNoise(\"Tweety\", BarkBark);\n    END Noises.\n\n~~~\n\n\nNote when we pass the procedures we include their name **without** parenthesis.\nOur type definition tells the compiler that the procedure can be a parameter,\nany procedure with the same signature, e.g. `who : ARRAY OF CHAR` as the\nonly parameter will be treated as a \"Noise\" type procedures. \n\n### Next and Previous \n\n+ Next [Procedures in Records](../../07/07/Procedures-in-records.html)\n+ Previous [Dynamic types](../../05/25/Dynamic-types.html) \n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-06-20",
        "keywords": [
          "Oberon",
          "procedures",
          "passing procedures as parameters",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 9,
        "series": "Mostly Oberon",
        "title": "Procedures as parameters"
      },
      "url": "posts/2020/06/20/Procedures-as-parameters.json"
    },
    {
      "content": "\n\n# Procedures in records\n\nBy R. S. Doiel, 2020-07-07\n\nThis is the tenth post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series.\nMostly Oberon documents my exploration of the Oberon Language, Oberon System and the \nvarious rabbit holes I will inevitably fall into.\n\nIn my last post I looked at how Oberon-07 supports the passing of procedures as parameters in a procedure. In this one I am looking at how we can\ninclude procedures as a part of an Oberon RECORD. \n\nLet's modify our module name [Noises.Mod](Noises.Mod) to explore this.\nCopy \"Noises.Mod\" to \"Creatures.Mod\". Replace the \"MODULE Noises;\" line with\n\"MODULE Creatures;\" and the final \"END Noises.\" statement with \"END Creatures.\".\n\n\n~~~\n\n    MODULE Creatures;\n    \n    (* rest of code here *)\n\n    END Creatures.\n\n~~~\n\n\nThe key to supporting records with procedures as record attributes is once again Oberon's type system.  The type `Noise` we created in the previous post can also be used to declare a record attribute similar to how we use this new type to pass the procedure. In this exploration will create a linked list of \"Creature\" types which include a \"MakeNoise\" attribute.\n\nFirst let's define our \"Creature\" as a type as well as a \n`CreatureList`. Add the following under our `TYPE` \ndefinition in [Creatures.Mod](Creatures.Mod).\n\n\n~~~\n\n    Creature = POINTER TO CreatureDesc;\n    CreatureDesc = RECORD\n                     name : ARRAY 32 OF CHAR;\n                     noises : Noises;\n                   END;\n\n~~~\n\n\nLet's create a new `MakeCreature` procedure that will create\na populate a single `Creature` type record.\n\n\n~~~\n\n    PROCEDURE MakeCreature(name : ARRAY OF CHAR; noise : Noise; VAR creature : Creature);\n    BEGIN\n      NEW(creature);\n      creature.name := name;\n      creature.noise := noise;\n    END MakeCreature;\n\n~~~\n\n\nNow lets modify `MakeNoise` to accept the `Creature` type RECORD\nrather than a name and a noise procedure parameter.\n\n\n~~~\n\n    PROCEDURE MakeNoise(creature : Creator);\n    BEGIN\n      creature.noise(creature.name);\n    END MakeNoise;\n\n~~~\n\n\nHow does this all work?  The two \"Noise\" procedures \n\"BarkBark\" and \"ChirpChirp\" remain as in our original \n\"Noises\" module. But our new `MakeNoise` procedure\nlooks takes a `Creature` record rather than accepting a\nname and procedure as parameters. This makes the code \na little more concise as well as lets you evolve the\ncreature record type using an object oriented approach.\n\nOur revised module should look like this.\n\n\n~~~\n\n    MODULE Noises;\n      IMPORT Out;\n    \n    TYPE \n      Noise = PROCEDURE(who : ARRAY OF CHAR);\n\n      Creature = RECORD\n                   name : ARRAY 32 OF CHAR;\n                   noises : Noises;\n                 END;\n    \n    VAR\n      dog, bird : Creature;\n\n    PROCEDURE BarkBark(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Bark, bark\");Out.Ln();\n    END BarkBark;\n    \n    PROCEDURE ChirpChirp(who : ARRAY OF CHAR);\n    BEGIN\n      Out.String(who);\n      Out.String(\": Chirp, chirp\");Out.Ln();\n    END ChirpChirp;\n    \n    PROCEDURE MakeNoise(creature : Creature);\n    BEGIN\n      (* Call noise with the animal name *)\n      creature.noise(creature.name);\n    END MakeNoise;\n\n    PROCEDURE MakeCreature(name : ARRAY OF CHAR; noise : Noise; VAR creature : Creature);\n    BEGIN\n      NEW(creature);\n      creature.name := name;\n      creature.noise := noise;\n    END MakeCreaturel\n    \n    BEGIN\n      MakeCreature(\"Fido\", BarkBark, dog);\n      MakeCreature(\"Tweety\", ChirpChirp, bird);\n      MakeNoise(dog);\n      MakeNoise(bird);\n    END Noises.\n\n~~~\n\n\nWhere to go from here? Think about evolving [Creatures](Creatures.Mod) so\nthat you can create a dynamic set of creatures that mix and match their\nbehaviors. Another idea would be to add a \"MutateCreature\" procedure\nthat would let you change the noise procedure to something new.\n\n\n### Next and Previous \n\n+ Next [Portable Oberon-07](../../08/15/Portable-Oberon-07.html)\n+ Previous [Procedures as parameters](../../06/20/Procedures-as-parameters.html) \n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-07-07",
        "keywords": [
          "Oberon",
          "procedures",
          "record procedures",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 10,
        "series": "Mostly Oberon",
        "title": "Procedures in records"
      },
      "url": "posts/2020/07/07/Procedures-in-records.json"
    },
    {
      "content": "\n\n# Words Matter\n\nBy R. S. Doiel, 2020-07-08\n\nUPDATE (2020-08-15, RSD): When I added a post today I was VERY pleased to \nto see that GitHub now allows me to publish my blog via the \"main\" branch.\nIt's nice to see the change in the words we use.\n\n**Why does software development use the vocabulary of slavery and\nJim Crow to describe our creations?** What we call things matters.\nThis is especially true of the words we use day to day without thinking.\n\n```shell\n    git pull origin master\n```\n\n\"Naming things is a hard problem in computer science.\" That is\na phrase I remember from my student days. We name variables,\nprograms and algorithms. We name architectures. Naming is a choice.\nThe names convey meaning and intent. Names and terms are a human\ncommunication. They matter.\n\n```shell\n    git push origin master\n```\n\n\n## Names can change\n\nI remember the first time I encountered the terminology \"master/slave\"\ndescribing network and database architecture. I remember cringing at\nthe terms. I accepted the terminology because I was a student and\nnaively assumed that those terms were chosen innocently and did not\nmean what they did. I was wrong.\n\nExample MySQL command:\n\n```sql\n    CHANGE MASTER TO MASTER_HOST=host1,\n    MASTER_PORT=3002 FOR CHANNEL 'channel2';\n```\n\nWhen I did not challenge the use of those terms in computer science\nI became complicit in the status quo of systemic racism. I am not happy\nabout that. Not then and not now.  We need inclusive language\nin engineering. We need real diversity to find solutions to\ntoday's challenges.  In software engineering we very much control what\nwe call things. Software is an explicit form of written human\ncommunication. Words count. Words directly impact culture and our\ncommunity.\n\nExample MySQL commands:\n\n```sql\n    START SLAVE;\n    RESET SLAVE;\n    STOP SLAVE;\n```\n\nAs a direct benefactor of white male privilege I find the\nterminology of \"master/slave\" offensive.  I am certain those\nwords caused injury to those who did not benefit from the same white\nmale privilege.  Using \"master/slave\" terminology to describe database,\nreplication, network architectures or as used with version control\nsystems like Git is like polishing statues that glorify slavery.\nIt endorses inhumanity in a subtle and casual way.\n\nWe have a choice about how we communicate and what we communicate\nto convey meaning.  Let's use better words. It is time to change\nsome.\n\n\n## Practice Change\n\n**To change our community's vocabulary we need to thoughtfully choose terms**.\nMy friends and colleagues introduced me to using the term \"main\" as\na better descriptive word than \"master\" in Git repositories. When\nI started making the branch name changes in my Git repositories I ran\nacross a problem at GitHub.\n\n\n## Note the problem\n\nRecently GitHub made it possible to easily change the default branch.\nFor a number of years you could change the published documentation\nbranch from \"gh-pages\" to something you prefer.\nWhat you can't do is change the name of the branch used to publish\npersonal and group websites.  **GitHub explicitly states that the\npublication branch must be named \"master\".** I tested this and\nconfirmed the documentation is accurate as of today (2020-07-08, morning).\n\nWith the recent improvements in GitHub to allow default branches to\nbe named better it seems odd that you still have to publish\npersonal and group pages to \"master\" in order to publish a website. It\nnever made sense to me that person and group pages didn't use the default\nof \"gh-pages\" in the first place.\n\n\n## Taking action\n\nMorning (2020-07-08): I submitted a ticket to GitHub asking to have\nthe option of using another word besides \"master\" for the publication\nbranch in publishing my personal GitHub pages (i.e. this blog).\nUnfortunately the ticket doesn't have a public URL. I don't know how many\nother people have submitted similar requests. If only a few people\nhave requested this recently it will not be changed. Such is the nature\nof systemic problems.\n\nPlease help improve the words and names we use in software.\nI believe it can make a difference in creating a more inclusive and\nequitable community and profession. Raise the issue when it comes to\nyour attention. Silence becomes acceptance with systemic problems.\n\n## A reply\n\nEvening (2020-07-08): I got a reply today from Steve G of customer\nsupport. Not sure if the reply is a bot or human.  It was a nice polite\nreply (I wrote a nice polite ticket).  Steve mentioned that CEO Nat\nFriedman had addressed this on twitter and to follow the GitHub blog\nnews.  Steve said dropping master was a priority for GitHub but there\nis no time line for implementation.\n\nI am not sure how you can develop software with a priority in mind and\nnot have a sense of time it takes to implement it.  I mentioned that in my\nresponse to Steve G.\n\nAfter some Duck Duck searching I found a [BBC article](https://www.bbc.com/news/technology-53050955) dated June 15th, 2020 where Nat made the\nannouncement about Microsoft's GitHub making the change away from \"master\".\nNext week is July 15th. It will be interesting to see how much of an unscheduled priority this change is.\n\nI am skeptical.  If Steve G had indicated that they are actively working\nthe problem and provided a general time range I would be more inclined to\ngive Nat, GitHub and Microsoft the benefit of the doubt.  Given the rest\nof the content I read on Nat's twitter feed I don't think this is a priority\nbeyond press, publicity and stock price.\n\n\n## Where to go from here?\n\nJust as many sites have adopted more gender neutral terms in documentation\npractice we should encourage better descriptive terms for our algorithms,\nand architectures. If you run into terms perpetuating exclusion please\nspeak up.  Most of the web runs on web servers and databases.  Like GitHub\nthose software projects frequently use the terminology of \"master/slave\".\nIt is especially prevalent in documentation about replication. Blindly\nperpetuating the \"master/slave\" terminology to describe distributed\nsoftware and architectures is like polishing a statue to the old\nConfederacy. It can and should be change. We can communicate better\nwithout perpetuating the vocabulary of Jim Crow, segregation, slavery\nand oppression.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-07-08",
        "keywords": [
          "civil rights",
          "diversity",
          "equality"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Words Matter"
      },
      "url": "posts/2020/07/08/words-matter.json"
    },
    {
      "content": "\n\n# Portable Oberon-07\n\n## using OBNC modules\n\nThis is the eleventh post in the [Mostly Oberon](../../04/11/Mostly-Oberon.html) series.\nMostly Oberon documents my exploration of the Oberon Language, Oberon System and the\nvarious rabbit holes I will inevitably fall into.\n\n## Working with standard input\n\nBy R. S. Doiel, 2020-08-15 (updated: 2020-09-05)\n\nKarl Landström's [OBNC](https://miasap.se/obnc/), Oberon-07 compiler,\ncomes with an Oberon-2 inspired set of modules\ndescribed in the Oakwood Guidelines as well as\nseveral very useful additions making Oberon-07 suitable for\nwriting programs in a POSIX environment.  We're going to\nexplore three of the Oakwood modules and two of Karl's own additions\nin this post as we create a program called [SlowCat](SlowCat.Mod).\nI am using the term \"portable\" to mean the code can be compiled\nusing OBNC on macOS, Linux, and Raspberry Pi OS and Windows 10\n(i.e. wherever OBNC is available). The Oakwood Guideline modules\nfocus on portability between an Oberon System and other systems.\nI'll leave that discussion along with\n[POW!](http://www.fim.uni-linz.ac.at/pow/pow.htm)\nto the end of this post.\n\n\n### SlowCat\n\nRecently while I was reviewing logs at work using [cat](https://en.wikipedia.org/wiki/Cat_(Unix)), [grep](https://en.wikipedia.org/wiki/Grep)\nand [more](https://en.wikipedia.org/wiki/More_(command)) it\nstruck me that it would have been nice if **cat**\nor **more** came with a time delay so you could use them like a\nteleprompter. This would let you casually watch the file scroll\nby while still being able to read the lines. The program we'll build\nin this post is \"SlowCat\" which accepts a command line parameter\nindicating the delay in seconds between display each line read from\nstandard input.\n\n## Working with Standard Input and Output\n\nThe Oakwood guides for Oberon-2 describe two modules\nparticularly useful for working with standard input and output.\nThey are appropriately called `In` and `Out`. On many Oberon Systems\nthese have been implemented such that your code could run under Unix\nor Oberon System with a simple re-compile.  We've used `Out` in our\nfirst program of this series, \"Hello World\". It provides a means to\nwrite Oberon system base types to standard out.  We've used `In`\na few times too. But `In` is worth diving into a bit more.\n\n### In\n\nThe [In](http://miasap.se/obnc/obncdoc/basic/In.def.html) module provides\na mirror of inputs to those of [Out](http://miasap.se/obnc/obncdoc/basic/Out.def.html). In Karl's implementation we are interested in one procedure\nand module status variable.\n\n+ `In.Line(VAR line: ARRAY OF CHAR)` : Read a sequence of characters from standard input from the current position in the file to the end of line.\n+ `In.Done` : Is a status Boolean variable, if the last call to an procedure in `In` was successful then it is set TRUE, otherwise FALSE (e.g. we're at the end of a file)\n\nWe use Karl's `In.Line()` extension to the standard `In` implementation\nbefore and will do so again as it simplifies our code and keeps things\neasily readable.\n\nThere is one nuance with `In.Done` that is easy to get tripped up on.\n`In.Done` indicates if the last operation was successful.\nSo if you're using `In.Line()` then `In.Done`\nshould be true if reading the line was successful. If you hit the end of\nthe file then `In.Done` should be false.  When you write your loop\nthis can be counter intuitive.  Here is a example of testing `In.Done`\nwith a repeat until loop.\n\n\n~~~\n\n    REPEAT\n      In.Line(text);\n      IF In.Done THEN\n        Out.String(text);Out.Ln();\n      END;\n    UNTIL In.Done = FALSE;\n\n~~~\n\n\nSo when you read this it is easy to think of `In.Done` as you're\ndone reading from standard input but actually we need to check for `FALSE`.\nThe value of `In.Done` was indicating the success of reading our line.\nAn unsuccessful line read, meaning we're at the end of the file, sets\n`In.Done` to false!\n\n### Out\n\nAs mention `Out` provides our output functions. We'll be using\ntwo procedure from `Out`, namely `Out.String()` and `Out.Ln()`.\nWe've seen both before.\n\n### Input\n\n\"SlowCat\" needs to calculate how often to write a line of\ntext to standard output with the `Out` module.  To do that\nI need access to the system's current time.  There isn't an\nOakwood module for time. There is a module called \n`Input` which provides a \"Time\" procedure. As a result\nI need to import `Input` as well as `In` even though\nI am using `In` to manage reading the file I am processing\nwith \"SlowCat\".\n\nA note about Karl's implementation.  `Input` is an Oakwood\nmodule that provides access to three system resources -- \nmouse, keyboard and system time.  Karl \nprovides two versions `Input` and `Input0`, the first is\nintended to be used with the `XYPlane` module for graphical\napplications the second for POSIX shell based application.\nIn the case of \"SlowCat\" I've stuck with `Input` as I am \nonly accessing time I've stuck with `Input` to make my source\ncode more portable if you're using another Oberon compiler.\n\n## Working with Karl's extensions\n\nThis is the part of my code which is not portable\nbetween compiler implementations and with Oberon Systems.\nKarl provides a number of extension module wrapping various\nPOSIX calls.  We are going to use two,\n[extArgs](http://miasap.se/obnc/obncdoc/ext/extArgs.def.html)\nwhich provides access to command line arguments and\n[extConvert](http://miasap.se/obnc/obncdoc/ext/extConvert.def.html)\nwhich provides a means of converting strings to integers.\nIf you are using another Oberon compiler you'll need to \nfind their equivalents and change my code example. I\nuse `extArgs` to access the command line parameters\nincluded in my POSIX shell invocation and I've used\n`extConvert` to convert the string presentation of the\ndelay to an integer value for my delay.\n\n\n## Our Approach\n\nTo create \"SlowCat\" we need four procedures and one\nglobal variable.\n\n`Usage()`\n: display a help text if parameters don't make sense\n\n`ProcessArgs()`\n: to get our delay time from the command line\n\n`Delay(count : INTEGER)`\n: a busy wait procedure\n\n`SlowCat(count : INTEGER)`\n: take standard input and display like a teleprompter\n\n`count`\n: is an integer holding our delay value (seconds of waiting) which is set by ProcessArgs()\n\n### Usage\n\nUsage just wraps helpful text and display it to standard out.\n\n## ProcessArgs()\n\nThis a functional procedure. It uses two of Karl's extension\nmodules. It uses `extArgs` to retrieve the command line parameters\nand `extConvert` the string value retrieved into an integer.\n`ProcessArgs()` returns TRUE if we can successful convert the\ncommand line parameter and set the value of count otherwise return\nFALSE.\n\n## Delay(VAR count : INTEGER)\n\nThis procedure uses `Input0` to fetch the current epoch time\nand counts the number of seconds until we've reached our delay\nvalue. It's a busy loop which isn't ideal but does keep the\nprogram simple.\n\n## SlowCat(VAR count: INTEGER);\n\nThis is the heart of our command line program. It reads\na line of text from standard input, if successful writes it\nto standard out and then waits using delay before repeating\nthis process. The delay is only invoked when a reading a\nline was successful.\n\n## Putting it all together\n\nHere's a \"SlowCat\" program.\n\n\n~~~\n\n    MODULE SlowCat;\n      IMPORT In, Out, Input, Args := extArgs, Convert := extConvert;\n\n    CONST\n      MAXLINE = 1024;\n\n    VAR\n      count: INTEGER;\n\n    PROCEDURE Usage();\n    BEGIN\n      Out.String(\"USAGE:\");Out.Ln();\n      Out.Ln();\n      Out.String(\"SlowCat outputs lines of text delayed by\");Out.Ln();\n      Out.String(\"a number of seconds. It takes one parameter,\");Out.Ln();\n      Out.String(\"an integer, which is the number of seconds to\");Out.Ln();\n      Out.String(\"delay a line of output.\");Out.Ln();\n      Out.String(\"SlowCat works on standard input and output.\");Out.Ln();\n      Out.Ln();\n      Out.String(\"EXAMPLE:\");\n      Out.Ln();\n      Out.String(\"    SlowCat 15 < README.md\");Out.Ln();\n      Out.Ln();\n    END Usage;\n\n    PROCEDURE ProcessArgs() : BOOLEAN;\n      VAR i : INTEGER; ok : BOOLEAN; arg : ARRAY MAXLINE OF CHAR;\n          res : BOOLEAN;\n    BEGIN\n      res := FALSE;\n      IF Args.count = 1 THEN\n        Args.Get(0, arg, i);\n        Convert.StringToInt(arg, i, ok);\n        IF ok THEN\n           (* convert seconds to microseconds of clock *)\n           count := (i * 1000);\n           res := TRUE;\n        END;\n      END;\n      RETURN res\n    END ProcessArgs;\n\n    PROCEDURE Delay*(count : INTEGER);\n      VAR start, current, delay : INTEGER;\n    BEGIN\n       start := Input.Time();\n       REPEAT\n         current := Input.Time();\n         delay := (current - start);\n       UNTIL delay >= count;\n    END Delay;\n\n    PROCEDURE SlowCat(count : INTEGER);\n      VAR text : ARRAY MAXLINE OF CHAR;\n    BEGIN\n      REPEAT\n        In.Line(text);\n        IF In.Done THEN\n          Out.String(text);Out.Ln();\n          (* Delay by count *)\n          Delay(count);\n        END;\n      UNTIL In.Done = FALSE;\n    END SlowCat;\n\n    BEGIN\n      count := 0;\n      IF ProcessArgs() THEN\n        SlowCat(count);\n      ELSE\n        Usage();\n      END;\n    END SlowCat.\n\n~~~\n\n\n## Compiling and trying it out\n\nTo compile our program and try it out reading\nour source code do the following.\n\n\n~~~\n\n    obnc SlowCat.Mod\n    # If successful\n    ./SlowCat 2 < SlowCat.Mod\n\n~~~\n\n\n\n## Oakwood Guidelines and POW!\n\nOberon and Oberon-2 were both used in creating and enhancing the\nOberon System(s) as well as for writing programs on other operating\nsystems (e.g. Apple's Mac and Microsoft Windows).\nImplementing Oberon compilers on non Oberon Systems required clarification\nbeyond the specification. The Oakwood Guidelines were an agreement\nbetween some of the important Oberon-2 compiler implementers which\nattempted to fill in that gap while encouraging portability in\nsource code between operating systems. Portability was desirable\nbecause it allowed programmers (e.g. students) to compile\nand run their Oberon programs with minimal modification in any\nenvironment where an Oakwood compliant compiler was available.\n\nCitation for Oakwood can be found in [Oberon-2 Programming with Windows](https://archive.org/details/oberonprogrammin00mhlb/page/n363/mode/2up?q=Oakwood+Guidlines).\n\n> Kirk B.(ed): The Oakwood Guidelines for Oberon-2 Compiler Developers. Available via FTP from ftp.fim.uni-linz.ac.at, /pub/soft/pow-oberon/oakwood\n\nThe FTP machine doesn't exist any more and does not appear to have been included in JKU's preservation plans. Fortunately the POW! website has been preserved.\n\n[POW!](http://www.fim.uni-linz.ac.at/pow/pow.htm) was a\ndifferent approach. It was a compiler and IDE targeting\nother than Oberon Systems (e.g. Windows and later Java). It was\nintended to be used in a hybrid development environment and to\nfacilitate leveraging non-Oberon resources (e.g. Java classes,\nnative Windows API).  POW project proposed \"Opal\" which was a\nsuper set of modules that went beyond Oakwood. Having skimmed\n\"Oberon-2 Programming with Windows\" some may seem reasonable to\nport to Oberon-07, others less so.\n\nWhy Oakwood and POW? These efforts are of interest to Oberon-07\ndevelopers as a well worn path to write code that is easy to\ncompile on POSIX systems and on systems that are based on the\nmore recent [Project Oberon 2013](http://www.projectoberon.com/).\nIt enhances the opportunity to bring forward well written modules\nfrom prior systems like [A2](https://en.wikibooks.org/wiki/Oberon/A2)\nbut implemented for the next generation of Oberon Systems\nlike [Integrated Oberon](https://github.com/io-core/io).\n\n### Oakwood PDF\n\nFinding a PDF of the original Oakwood guidelines is going to become\ntricky in the future. It was created by Robinson Associates and the\ncopy I've read from 1995 includes a page saying not for distribution.\nWhich sorta makes sense in the era of closed source software\ndevelopment. It is problematic for those of us who want to explore\nhow systems evolved.  The term \"Oakwood Guidelines\" is bandied about\nafter 1993 and several of the modules have had influence on the language\nuse via book publications.  I was able to find a PDF of the 1995\nversion of the guidelines at\n[http://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf](http://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf).\n\nHere's a typical explanation of Oakwood from \n[http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines](http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines)\nfor a description of Oakwood.\n\n> __The Oakwood Guidelines for the Oberon-2 Compiler Developers /These guidelines have been produced by a group of Oberon-2 compiler developers, including ETH developers, after a meeting at the Oakwood Hotel in Croydon, UK in June 1993__\n\n[http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines](http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines)  \n(an OS/2 developer website) was helpful for providing details about Oakwood.\n\nIt would have been nice if the Oakwood document had made its way\ninto either ETH's or JKU's research libraries.\n\nLeveraging prior art opens doors to the past and future. Karl has\ndone with this with the modules he provides with his OBNC compiler\nproject.\n\n### Next and Previous\n\n+ Next [Oberon to Markdown](../../10/03/Oberon-to-markdown.html)\n+ Previous [Procedures in records](../..//07/07/Procedures-in-records.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-08-15",
        "keywords": [
          "Oberon",
          "portable",
          "stdin"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 11,
        "series": "Mostly Oberon",
        "title": "Portable Oberon-07"
      },
      "url": "posts/2020/08/15/Portable-Oberon-07.json"
    },
    {
      "content": "\n\n# Software Tools, Getting Started\n\n## Overview\n\nThis post is the first in a series revisiting the\nprograms described in the 1981 book by Brian W. Kernighan and\nP. J. Plauger's called [Software Tools in Pascal](https://archive.org/details/softwaretoolsinp00kern).\nThe book is available from the [Open Library](https://openlibrary.org/)\nand physical copies are still (2020) commonly available from used book\nsellers.  The book was an early text on creating portable command\nline programs.  \n\nIn this series I present the K & P (i.e. Software Tools in Pascal)\nprograms re-implemented in Oberon-07. I have testing my implementations\nusing Karl Landström's [OBNC](http://miasap.se/obnc/)\ncompiler and his implementation of the Oakwood Guide's modules\nfor portable Oberon programs. Karl also provides a few additional\nmodules for working in a POSIX environment (e.g. BSD, macOS, Linux,\nWindows 10 with Linux subsystem). I have also tested these\nprograms with Mike Spivey's [Oxford Oberon Compiler](http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler) an aside\nfrom the differences file extensions that both compilers use\nthe source code works the same. \n\nNOTE: OBNC compiler is the work of Karl Langström, it is portable across many systems where the C tool chain is available.\n\nNOTE: POSIX defines a standard of compatibility inspired by [UNIX](https://en.wikipedia.org/wiki/Unix), see <https://en.wikipedia.org/wiki/POSIX>\n\n\n## Getting Started.\n\nChapter one in K & P is the first chapter that presents code. It introduces\nsome challenges and constraints creating portable Pascal suitable for use\nacross hardware architectures and operating systems. In 1981 this included\nmainframes, minicomputers as well as the recent evolution of the microcomputer.\nThe programs presented build up from simple to increasingly complex as\nyou move through the book.  They provide example documentation and discuss\ntheir implementation choices. It is well worth reading the book for those\ndiscussions, while specific to the era, mirror the problems program authors\nface today in spite of the wide spread success of the POXIS model, the\nconsolidation of CPU types and improvements made in development tools in\nthe intervening decades.\n\nThrough out K & P you'll see the bones of many POSIX commands we have today.\n\nPrograms from this chapter include:\n\n1. **copyprog**, this is like \"cat\" in a POSIX system\n2. **charcount**, this is like the \"wc\" POSIX command using the \"-c\" option\n3. **linecount**, this is like the \"wc\" POSIX command using the \"-l\" option\n4. **wordcount**, this is like the \"wc\" POSIX command using the \"-w\" option\n5. **detab**, converts tabs to spaces using tab stops every four characters in a line\n\nAll programs in this chapter rely solely on standard input and output.\nToday's reader will notice an absence to common concepts in today's\ncommand line programs.  First is the lack of interaction with command line\nparameters, the second is no example take advantage of environment variables.\nThese operating system features were not always available across\noperating systems of the early 1980s. Finally I'd like to point out a\nreally nice feature included in the book. It is often left out as a topic\nin programming books.  K & P provide example documentation. It's structure\nlike an early UNIX man page. It very clear and short. This is something\nI wish all programming texts at least mentioned. Documentation is important\nto the program author because it clarifies scope of the problem being\ntackled and to the program user so they understand what they are using.\n\n\n### [1.1. File Copying](https://archive.org/details/softwaretoolsinp00kern/page/7/mode/1up)\n\nHere's how K & P describe \"copyprog.pas\" (referred to as \"copy\" in\nthe documentation).\n\n\n~~~\n\nPROGRAM\n\n    copy    copy input to output\n\nUSAGE\n\n    copy\n\nFUNCTION\n\n    copy copies its input to its output unchanged. It is useful for copying\n    from a terminal to a file, from file to file, or even from terminal to\n    terminal. It may be used for displaying the contents of a file, without\n    interpretation or formatting, by copying from the file to terminal.\n\nEXAMPLE\n\n    To echo lines type at your terminal.\n\n    copy\n    hello there, are you listening?\n    **hello there, are you listening?**\n    yes, I am.\n    **yes, I am.**\n    <ENDFILE>\n\n~~~\n\nThe source code for \"copyprog.pas\" is shown on\n[page 9](https://archive.org/details/softwaretoolsinp00kern/page/9/mode/1up)\nof K & P.  First the authors introduce the __copy__ procedure\nthen a complete the section introducing it in context of the complete Pascal\nprogram. After this first example K & P leave implementation of the full\nprogram up to the reader.\n\nThe body of the Pascal program invokes a procedure called\n[copy](https://archive.org/details/softwaretoolsinp00kern/page/8/mode/1up)\nwhich reads from standard input character by character and writes\nto standard output character by character without modification.  Two\nsupporting procedures are introduced, \"getc\" and \"putc\". These are shown\nin the complete program listing on page 9. They are repeatedly used\nthrough out the book. One of the really good aspects of this simple\nprogram is relying on the idea of standard input and output. This makes\n\"copyprog.pas\" a simple filter and template for writing many of the programs\nthat follow. K & P provide a good explanation for this simple approach.\nAlso note K & P's rational for working character by character versus\nline by line.\n\nMy Oberon-07 version takes a similar approach. The module looks remarkably\nsimilar to the Pascal but is shorter because reading and writing characters are\nprovided for by Oberon's standard modules \"In\" and \"Out\".\nI have chosen to use a \"REPEAT/UNTIL\" loop over the \"WHILE\"\nloop used by K & P is the attempt to read from standard input needs to happen\nat least once. Note in my \"REPEAT/UNTIL\" loop's terminating condition.\nThe value of `In.Done` is true on successful read and false\notherwise (e.g. you hit an end of the file). That means our loop must\nterminate on `In.Done # TRUE` rather than `In.Done = TRUE`. This appears\ncounter intuitive unless you keep in mind our loop stops when we having\nnothing more to read, rather than when we can continue to read.\nIt `In.Done` means the read was successful and does not\nmean \"I'm done and can exit now\". Likewise before writing out the character\nwe read, it is good practice to check the `In.Done` value. If `In.Done` is\nTRUE, I know can safely display the character using `Out.Char(c);`.\n\n~~~\n\nMODULE CopyProg;\nIMPORT In, Out;\n\nPROCEDURE copy;\nVAR\n  c : CHAR;\nBEGIN\n  REPEAT\n    In.Char(c);\n    IF In.Done THEN\n        Out.Char(c);\n    END;\n  UNTIL In.Done # TRUE;\nEND copy;\n\nBEGIN\n  copy();\nEND CopyProg.\n\n~~~\n\n#### Limitations\n\nThis program only works with standard input and output. A more generalized\nversion would work with named files.\n\n### [1.2 Counting Characters](https://archive.org/details/softwaretoolsinp00kern/page/13/mode/1up)\n\n~~~\n\nPROGRAM\n\n  charcount count characters in input\n\nUSAGE\n\n  charcount\n\nFUNCTION\n\n  charcount counts the characters in its input and writes the total\n  as a single line of text to the output. Since each line of text is\n  internally delimited by a NEWLINE character, the total count is the\n  number of lines plus the number of characters within each line.\n\nEXAMPLE\n\n  charcount\n  A single line of input.\n  <ENDFILE>\n  24\n\n~~~\n\n[On page 13](https://archive.org/details/softwaretoolsinp00kern/page/13/mode/1up)\nK & P introduces their second program, **charcount**. It is based on a single\nprocedure that reads from standard input and counts up the number of\ncharacters encountered then writes the total number found to standard out\nfollowed by a newline. In the text only the procedure is shown, it is\nassumed you'll write the outer wrapper of the program yourself as\nwas done with the **copyprog** program. My Oberon-07 version is very similar\nto the Pascal. Like in the our first \"CopyProg\" we will make use of the\n\"In\" and \"Out\" modules. Since we will\nneed to write an INTEGER value we'll also use \"Out.Int()\" procedure which\nis very similar to K & P's \"putdec()\". Aside from the counting this is very\nsimple  like our first program.\n\n~~~\n\nMODULE CharCount;\nIMPORT In, Out;\n\nPROCEDURE CharCount;\nVAR\n  nc : INTEGER;\n  c : CHAR;\nBEGIN\n  nc := 0;\n\n  REPEAT\n    In.Char(c);\n    IF In.Done THEN\n      nc := nc + 1;\n    END;\n  UNTIL In.Done # TRUE;\n  Out.Int(nc, 1);\n  Out.Ln();\nEND CharCount;\n\nBEGIN\n  CharCount();\nEND CharCount.\n\n~~~\n\n#### Limitations\n\nThe primary limitation in counting characters is most readers are\ninterested in visible character count. In our implementation\neven non-printed characters are counted. Like our first program\nthis only works on standard input and output. Ideally this should\nbe written so it works on any file including standard input and\noutput. If the reader implements that it could become part of a\npackage on statistical analysis of plain text files.\n\n### [1.3 Counting Lines](https://archive.org/details/softwaretoolsinp00kern/page/14/mode/1up)\n\n~~~\n\nPROGRAM\n\n  linecount count lines in input\n\nUSAGE\n\n  linecount\n\nFUNCTION\n\n  linecount counts the lines in its input and write the total as a\n  line of text to the output.\n\nEXAMPLE\n\n  linecount\n  A single line of input.\n  <ENDFILE>\n  1\n\n~~~\n\n**linecount**, from [page 15](https://archive.org/details/softwaretoolsinp00kern/page/15/mode/1up)\nis very similar to **charcount** except adding a\nconditional count in the loop for processing the file. In\nour Oberon-07 implementation we'll check if the `In.Char(c)`\ncall was successful but we'll add a second condition to see if the\ncharacter read was a NEWLINE. If it was I increment\nour counter variable.\n\n~~~\n\nMODULE LineCount;\nIMPORT In, Out;\n\nPROCEDURE LineCount;\nCONST\n  NEWLINE = 10;\n\nVAR\n  nl : INTEGER;\n  c : CHAR;\nBEGIN\n  nl := 0;\n  REPEAT\n    In.Char(c);\n    IF In.Done & (ORD(c) = NEWLINE) THEN\n      nl := nl + 1;\n    END;\n  UNTIL In.Done # TRUE;\n  Out.Int(nl, 1);\n  Out.Ln();\nEND LineCount;\n\nBEGIN\n  LineCount();\nEND LineCount.\n\n~~~\n\n#### Limitations\n\nThis program assumes that NEWLINE is ASCII value 10. Line delimiters\nvary between operating systems.  If your OS used carriage returns\nwithout a NEWLINE then this program would not count lines correctly.\nThe reader could extend the checking to support carriage returns,\nnew lines, and carriage return with new lines and cover most versions\nof line endings.\n\n\n### [1.4 Counting Words](https://archive.org/details/softwaretoolsinp00kern/page/14/mode/1up)\n\n~~~\n\nPROGRAM\n\n  wordcount count words in input\n\nUSAGE\n\n  wordcount\n\nFUNCTION\n\n  wordcount counts the words in its input and write the total as a\n  line of text to the output. A \"word\" is a maximal sequence of characters\n  not containing a blank or tab or newline.\n\nEXAMPLE\n\n  wordcount\n  A single line of input.\n  <ENDFILE>\n  5\n\nBUGS\n\n  The definition of \"word\" is simplistic.\n\n~~~\n\n[Page 17](https://archive.org/details/softwaretoolsinp00kern/page/17/mode/1up)\nbrings us to the **wordcount** program. Counting words can be\nvery nuanced but here K & P have chosen a simple definition\nwhich most of the time is \"good enough\" for languages like English.\nA word is defined simply as an run of characters separated by\na space, tab or newline characters.  In practice most documents\nwill work with this minimal definition. It also makes the code\nstraight forward.  This is a good example of taking the simple\nroad if you can. It keeps this program short and sweet.\n\nIf you follow along in the K & P book note their rational\nand choices in arriving at there solutions. There solutions\nwill often balance readability and clarity over machine efficiency.\nWhile the code has progressed from \"if then\" to \"if then else if\"\nlogical sequence, the solution's modeled remains\nclear. This means the person reading the source code can easily verify\nif the approach chosen was too simple to meet their needs or it was\n\"good enough\".\n\nMy Oberon-07 implementation is again very simple. Like in previous programs\nI still have an outer check to see if the read worked (i.e. \"In.Done = TRUE\"),\notherwise the conditional logic is the same as the Pascal implementation.\n\n~~~\n\nMODULE WordCount;\nIMPORT In, Out;\n\nPROCEDURE WordCount;\nCONST\n  NEWLINE = 10;\n  BLANK = 32;\n  TAB = 9;\n\nVAR\n  nw : INTEGER;\n  c : CHAR;\n  inword : BOOLEAN;\nBEGIN\n  nw := 0;\n  inword := FALSE;\n  REPEAT\n    In.Char(c);\n    IF In.Done THEN\n      IF ((ORD(c) = BLANK) OR (ORD(c) = NEWLINE) OR (ORD(c) = TAB)) THEN\n        inword := FALSE;\n      ELSIF (inword = FALSE) THEN\n        inword := TRUE;\n        nw := nw + 1;\n      END;\n    END;\n  UNTIL In.Done # TRUE;\n  Out.Int(nw, 1);\n  Out.Ln();\nEND WordCount;\n\nBEGIN\n  WordCount();\nEND WordCount.\n\n~~~\n\n## [1.5 Removing Tabs](https://archive.org/details/softwaretoolsinp00kern/page/20/mode/1up)\n\n~~~\n\nPROGRAM\n\n  detab convert tabs into blanks\n\nUSAGE\n\n  detab\n\nFUNCTION\n\n  detab copies its input to its output, expanding the horizontal\n  tabs to blanks along the way, so that the output is visually\n  the same as the input, but contains no tab characters. Tab stops\n  are assumed to be set every four columns (i.e. 1, 5, 9, ...), so\n  each tab character is replaced by from one to four blanks.\n\nEXAMPLE\n\n  Usaing \"->\" as a visible tab:\n\n  detab\n  ->col 1->2->34->rest\n      col 1   2   34  rest\n\nBUGS\n\n  detab is naive about backspaces, vertical motions, and\n  non-printing characters.\n\n~~~\n\nThe source code for \"detab\" can be found on\n[page 24](https://archive.org/details/softwaretoolsinp00kern/page/24/mode/1up)\nin the last section of chapter 1. **detab** removes\ntabs and replaces them with spaces. Rather than a simple \"tab\"\nreplaced with four spaces **detab** preserves a concept found on\ntypewriters called \"tab stops\". In 1981 typewrites were still widely\nused though word processing software would become common. Supporting the\n\"tab stop\" model means the program works with what office workers would\nexpect from older tools like the typewriter or even the computer's\nteletype machine. I think this shows an important aspect of writing\nprograms. Write the program for people, support existing common concepts\nthey will likely know.\n\nK & P implementation includes separate source files\nfor setting tab stops and checking a tab stop.  The Pascal K & P\nwrote for didn't support separate source files or program modules. Recent Pascal\nversions did support the concept of modularization (e.g. UCSD Pascal). Since\nand significant goal of K & P was portability they needed to come up\nwith a solution that worked on the \"standard\" Pascal compilers available on\nminicomputers and mainframes and not write their solution to a specific\nPascal system like UCSD Pascal (see Appendix, \"IMPLEMENTATION\nPRIMITIVES [page 315](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/315/mode/1up)).\nModularization facilitates code reuse and like information hiding is an\nimport software technique. Unfortunately the preprocessor approach doesn't\nsupport information hiding.\n\nTo facilitate code reuse the K & P book includes a preprocessor as part\nof the Pascal development tools (see [page 71](https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/71/mode/1up)\nfor implementation). The preprocessor written\nin Pascal was based on the early versions of the \"C\" preprocessor\nthey had available in the early UNIX systems. Not terribly Pascal\nlike but it worked and allowed the two files to be shared between\nthis program and one in the next chapter.\n\nOberon-07 of course benefits from all of Wirth's language improvements\nthat came after Pascal. Oberon-07 supports modules and as such\nthere is no need for a preprocessor.  Because of Oberon-07's module\nsupport I've implemented the Oberon version using two files\nrather than three. My main program file is \"Detab.Mod\",\nthe supporting library module is \"Tabs.Mod\". \"Tabs\" is where I\ndefine our tab stop data structure as well as the\nprocedures that operating on that data structure.\n\nLet's look at the first part, \"Detab.Mod\". This is the module\nthat forms the program and it features an module level \"BEGIN/END\" block.\nIn that block I call \"Detab();\" which implements the program's functionality.\nI import \"In\", \"Out\" as before but I also import \"Tabs\" which I will show next.\nLike my previous examples I validate the read was successful before proceeding\nwith the logic presented in the original Pascal and deciding\nwhat to write to standard output.\n\n~~~\n\nMODULE Detab;\n  IMPORT In, Out, Tabs;\n\nCONST\n  NEWLINE = 10;\n  TAB = 9;\n  BLANK = 32;\n\nPROCEDURE Detab;\nVAR\n  c : CHAR;\n  col : INTEGER;\n  tabstops : Tabs.TabType;\nBEGIN\n  Tabs.SetTabs(tabstops); (* set initial tab stops *)\n  col := 1;\n  REPEAT\n    In.Char(c);\n    IF In.Done THEN\n      IF (ORD(c) = TAB) THEN\n        REPEAT\n          Out.Char(CHR(BLANK));\n          col := col + 1;\n        UNTIL Tabs.TabPos(col, tabstops);\n      ELSIF (ORD(c) = NEWLINE) THEN\n        Out.Char(c);\n        col := 1;\n      ELSE\n        Out.Char(c);\n        col := col + 1;\n      END;\n    END;\n  UNTIL In.Done # TRUE;\nEND Detab;\n\nBEGIN\n  Detab();\nEND Detab.\n\n~~~\n\nOur second module is \"Tabs.Mod\". It provides the supporting procedures\nand definition of the our \"TabType\" data structure. For us this\nis the first time we write a module which \"exports\" procedures\nand type definitions. If you are new to Oberon, expected constants,\nvariables and procedures names have a trailing \"*\". Otherwise the\nOberon compiler will assume a local use only. This is a very\npowerful information hiding capability and what allows you to\nevolve a modules' internal implementation independently of the\nprograms that rely on it.\n\n~~~\n\nMODULE Tabs;\n\nCONST\n  MAXLINE = 1000; (* or whatever *)\n\nTYPE\n  TabType* = ARRAY MAXLINE OF BOOLEAN;\n\n(* TabPos -- return TRUE if col is a tab stop *)\nPROCEDURE TabPos*(col : INTEGER; VAR tabstops : TabType) : BOOLEAN;\n  VAR res : BOOLEAN;\nBEGIN\n  res := FALSE; (* Initialize our internal default return value *)\n  IF (col >= MAXLINE) THEN\n    res := TRUE;\n  ELSE\n    res := tabstops[col];\n  END;\n  RETURN res\nEND TabPos;\n\n(* SetTabs -- set initial tab stops *)\nPROCEDURE SetTabs*(VAR tabstops: TabType);\nCONST\n  TABSPACE = 4; (* 4 spaces per tab *)\nVAR\n  i : INTEGER;\nBEGIN\n  (* NOTE: Arrays in Oberon start at zero, we want to\n     stop at the last cell *)\n  FOR i := 0 TO (MAXLINE - 1) DO\n    tabstops[i] := ((i MOD TABSPACE) = 0);\n  END;\nEND SetTabs;\n\nEND Tabs.\n\n~~~\n\nNOTE: This module is used by \"Detab.Mod\" and \"Entab.Mod\"\nand provides for common type definitions and code reuse.\nWe exported `TabType`, `TabPos` and `SetTabs`. Everything else\nis private to this module.\n\n## In closing\n\nThis post briefly highlighted ports of the programs\npresented in Chapter 1 of \"Software Tools in Pascal\".\nBelow are links to my source files of the my\nimplementations inspired by the K & P book. Included\nin each Oberon module source after the module definition\nis transcribed text of the program documentation as well\nas transcribed text of the K & P Pascal implementations.\nEach file should compiler without modification using the\nOBNC compiler.  By default the OBNC compiler will use the\nmodule's name as the name of the executable version. I\nI have used mixed case module names, if you prefer lower\ncase executable names use the \"-o\" option with the OBNC\ncompiler.\n\n~~~\n\n    obnc -o copy CopyProg.Mod\n    obnc -o charcount CharCount.Mod\n    obnc -o linecount LineCount.Mod\n    obnc -o wordcount WordCount.Mod\n    obnc -o detab Detab.Mod\n\n~~~\n\nIf you happen to be using The [Oxford Oberon Compiler](http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler)\nyou need to rename the files ending in \".Mod\" to \".m\" \nand you can compiler with the following command.\n\n~~~\n    obc -07 -o copyprog CopyProg.m\n    obc -07 -o charcount CharCount.m\n    obc -07 -o linecount LineCount.m\n    obc -07 -o wordcount WordCount.m\n    obc -07 -o detab Tabs.m Detab.m\n~~~\n\nNote the line for compiling \"Detab\" with **obc**, your\nlocal modules need to become before the module calling them.\n\n\n+ [CopyProg](CopyProg.Mod)\n+ [CharCount](CharCount.Mod)\n+ [LineCount](LineCount.Mod)\n+ [WordCount](WordCount.Mod)\n+ [Detab](Detab.Mod)\n    + [Tabs](Tabs.Mod), this one we'll revisit in next installment.\n\n\n# Next\n\n+ [Filters](../../10/31/Filters.html)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-09-29",
        "keywords": [
          "Oberon",
          "Pascal",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 1,
        "series": "Software Tools",
        "title": "Software Tools, Getting Started"
      },
      "url": "posts/2020/09/29/Software-Tools-1.json"
    },
    {
      "content": "\n\nOberon to Markdown\n==================\n\nThis is the twelfth post in the [Mostly Oberon](https://rsdoiel.github.io/blog/2020/04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\nA nice feature of Oberon\n------------------------\n\nOberon source code has a very nice property in that anything\nafter the closing end statement is ignored by the compiler.\nThis makes it a nice place to write documentation, program\nnotes and other ideas.\n\nI've gotten in the habit of writing up program docs and\nnotes there. When I prep to make a web document I used to\ncopy the source file, doing a cut and paste to re-order\nthe module code to the bottom of the document. I'd follow\nthat with adding headers and code fences. Not hard but\ntedious. Of course if I changed the source code I'd also\nhave to do another cut and paste edit. This program,\n`ObnToMd.Mod` automates that process.\n\nProgram Documentation\n---------------------\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPROGRAM\n\n  ObnToMd\n\nFUNCTION\n\n  This is a simple program that reads Oberon modules\n  from standard in and re-renders that to standard output\n  such that it is suitable to process with Pandoc or other\n  text processing system.\n\nEXAMPLE\n\n  Read the source for this program and render a file\n  called \"blog-post.md\". Use Pandoc to render HTML.\n\n    ObnToMd <ObnToMd.Mod > blog-post.md\n    pandoc -s --metadata title=\"Blog Post\" \\\n        blog-post.md >blog-post.html\n\nBUGS\n\n  It uses a naive line analysis to identify the module\n  name and then the end of module statement. Might be\n  tripped up by comments containing the same strings.\n  The temporary file created is called \"o2m.tmp\" and\n  this filename could potentially conflict with another\n  file.\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\nSource code for **ObnToMd.Mod**\n-------------------------------\n\n~~~\n\n(* ObnToMd.Mod - an simple filter process for reading\nan Oberon-07 module source file and rendering a markdown\nfriendly output suitable for piping into Pandoc. The\nfilter reads from standard input and writes to standard\noutput and makes use of a temp file name o2m.tmp which\nit removes after successful rendering.\n\n@Author R. S. Doiel, <rsdoiel@gmail.com>\ncopyright (c) 2020, all rights reserved.\nReleased under the BSD 2-clause license\nSee: https://opensource.org/licenses/BSD-2-Clause\n*)\nMODULE ObnToMd;\n  IMPORT In, Out, Files, Strings;\n\nCONST\n  MAXLENGTH = 1024;\n  LF = CHR(10);\n\nVAR\n  endOfLine : ARRAY 2 OF CHAR;\n\n(*\n * Helper methods\n *)\nPROCEDURE GenTempName(prefix, suffix : ARRAY OF CHAR; VAR name : ARRAY OF CHAR);\nBEGIN\n  name := \"\";\n  Strings.Append(prefix, name);\n  Strings.Append(\".\", name);\n  Strings.Append(suffix, name);\nEND GenTempName;\n\nPROCEDURE GenTempFile(name : ARRAY OF CHAR; VAR r : Files.Rider; VAR f : Files.File);\nBEGIN\n  f := Files.New(name);\n  IF f = NIL THEN\n    Out.String(\"ERROR: can't create \");Out.String(name);Out.Ln();\n    ASSERT(FALSE);\n  END;\n  Files.Register(f);\n  Files.Set(r, f, 0);\nEND GenTempFile;\n\n\nPROCEDURE StartsWith(target, source : ARRAY OF CHAR) : BOOLEAN;\n  VAR res : BOOLEAN;\nBEGIN\n  IF Strings.Pos(target, source, 0) > -1 THEN\n    res := TRUE;\n  ELSE\n    res := FALSE;\n  END;\n  RETURN res\nEND StartsWith;\n\nPROCEDURE ClearString(VAR s : ARRAY OF CHAR);\n  VAR i : INTEGER;\nBEGIN\n  FOR i := 0 TO LEN(s) - 1 DO\n    s[i] := 0X;\n  END;\nEND ClearString;\n\n\nPROCEDURE ProcessModuleDef(VAR r : Files.Rider; VAR modName : ARRAY OF CHAR);\n  VAR\n    line, endStmt : ARRAY MAXLENGTH OF CHAR;\n    start, end : INTEGER;\nBEGIN\n  line := \"\";\n  endStmt := \"\";\n  modName := \"\";\n  (* Find the name of the module and calc the \"END {NAME}.\" statement *)\n  REPEAT\n    ClearString(line);\n    In.Line(line);\n    IF In.Done THEN\n      Files.WriteString(r, line); Files.WriteString(r, endOfLine);\n      (* When `MODULE {NAME};` is encountered extract the module name *)\n      IF StartsWith(\"MODULE \", line) THEN\n        start := 7;\n        end := Strings.Pos(\";\", line, 0);\n        IF (end > -1) & (end > start) THEN\n            Strings.Extract(line, start, end - start, modName);\n            endStmt := \"END \";\n            Strings.Append(modName, endStmt);\n            Strings.Append(\".\", endStmt);\n        END;\n      END;\n    END;\n  UNTIL (In.Done # TRUE) OR (endStmt # \"\");\n\n  (* When `END {NAME}.` is encountered  stop writing tmp file *)\n  REPEAT\n    In.Line(line);\n    IF In.Done THEN\n      Files.WriteString(r, line); Files.WriteString(r, endOfLine);\n    END;\n  UNTIL (In.Done # TRUE) OR StartsWith(endStmt, line);\nEND ProcessModuleDef;\n\nPROCEDURE WriteModuleDef(name : ARRAY OF CHAR; VAR r : Files.Rider; VAR f : Files.File);\n  VAR s : ARRAY MAXLENGTH OF CHAR; res : INTEGER;\nBEGIN\n  Files.Set(r, f, 0);\n  REPEAT\n    Files.ReadString(r, s);\n    IF r.eof # TRUE THEN\n      Out.String(s);\n    END;\n  UNTIL r.eof;\n  Files.Close(f);\n  Files.Delete(name, res);\nEND WriteModuleDef;\n\n\nPROCEDURE OberonToMarkdown();\nVAR\n  tmpName, modName, line : ARRAY MAXLENGTH OF CHAR;\n  f : Files.File;\n  r : Files.Rider;\n  i : INTEGER;\nBEGIN\n  tmpName := \"\"; modName := \"\";  line := \"\";\n  (* Open temp file *)\n  GenTempName(\"o2m\", \"tmp\", tmpName);\n  GenTempFile(tmpName, r, f);\n\n  (* Read the Oberon source from standard input echo the lines tmp file *)\n  ProcessModuleDef(r, modName);\n\n  (* Write remainder of file to standard out *)\n  REPEAT\n    In.Line(line);\n    IF In.Done THEN\n      Out.String(line);Out.Ln();\n    END;\n  UNTIL In.Done # TRUE;\n\n  (* Write two new lines *)\n  Out.Ln(); Out.Ln();\n  (* Write heading `Source code for {NAME}` *)\n  ClearString(line);\n  line := \"Source code for **\";\n  Strings.Append(modName, line);\n  Strings.Append(\".Mod**\", line);\n  Out.String(line); Out.Ln();\n  FOR i := 0 TO Strings.Length(line) - 1 DO\n    Out.String(\"-\");\n  END;\n  Out.Ln();\n  (* Write code fence *)\n  Out.Ln();Out.String(\"~~~\");Out.Ln();\n  (* Reset rider to top of tmp file\n     Write temp file to standard out\n     cleanup demp file *)\n  WriteModuleDef(tmpName, r, f);\n  (* Write code fence *)\n  Out.Ln();Out.String(\"~~~\");Out.Ln();\n  (* Write tailing line and exit procedure *)\n  Out.Ln();\nEND OberonToMarkdown;\n\nBEGIN\n  endOfLine[0] := LF;\n  endOfLine[1] := 0X;\n  OberonToMarkdown();\nEND ObnToMd.\n\n~~~\n\n### Next, Previous\n\n+ Next [Assembling Pages](../../10/19/Assemble-pages.html)\n+ Previous [Portable Oberon-07](../../08/15/Portable-Oberon-07.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-10-03",
        "keywords": [
          "Oberon",
          "portable",
          "markdown",
          "programming"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 12,
        "series": "Mostly Oberon",
        "title": "Oberon to Markdown"
      },
      "url": "posts/2020/10/03/Oberon-to-markdown.json"
    },
    {
      "content": "\n\nAssembling pages\n================\n\nThis is the thirteenth post in the [Mostly Oberon](https://rsdoiel.github.io/blog/2020/04/11/Mostly-Oberon.html) series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.\n\nPandoc and JSON\n---------------\n\nI use [Pandoc](https://pandoc.org) to process Markdown documents. I like to keep my\nfront matter in JSON rather than Pandoc's YAML. Fortunately Pandoc\ndoes support working with JSON as a metadata file include. Normally I would\nmanually split the JSON front matter and the rest of the markup into two\nseparate files, then process with Pandoc and other tooling like\n[LunrJS](https://lunrjs.com). [AssemblePage](AssemblePage.Mod) automates this\nprocess.\n\nExample shell usage:\n\n~~~\n\n   AssemblePage MyText.txt \\\n      metadata=document.json \\\n      document=document.md\n   pandoc --from markdown --to html \\\n      --metadata-file document.json \\\n      --standalone \\\n      document.md >MyText.html\n\n~~~\n\nSource code for **AssemblePage.Mod**\n------------------------------------\n\n~~~\n\nMODULE AssemblePage;\n  IMPORT Out, Strings, Files, Args := extArgs;\n\nVAR\n  srcName, metaName, docName : ARRAY 1024 OF CHAR;\n\n(* FrontMatter takes a \"read\" Rider, r, and a \"write\" Rider \"w\".\nIf the first character read by r is an opening curly bracket\n(the start of the front matter) it writes it out with w, until\nit finds a matching closing curly bracket or the file ends. *)\nPROCEDURE FrontMatter*(VAR r : Files.Rider; VAR w : Files.Rider);\n  VAR c : BYTE; cCnt : INTEGER;\nBEGIN\n  (* Scan for opening JSON front matter *)\n  cCnt := 0;\n  REPEAT\n    Files.Read(r, c);\n    IF r.eof = FALSE THEN\n      IF c = ORD(\"{\") THEN\n        cCnt := cCnt + 1;\n      ELSIF c = ORD(\"}\") THEN\n        cCnt := cCnt - 1;\n      END;\n      Files.Write(w, c);\n    END;\n  UNTIL (r.eof = TRUE) OR (cCnt = 0);\n  IF cCnt # 0 THEN\n    Out.String(\"ERROR: mis matched '{' and '}' in front matter\");\n    ASSERT(FALSE);\n  END;\nEND FrontMatter;\n\n(* CopyIO copies the characters from a \"read\" Rider to a \"write\" Rider *)\nPROCEDURE CopyIO*(VAR r : Files.Rider; VAR w: Files.Rider);\n  VAR c : BYTE;\nBEGIN\n  REPEAT\n    Files.Read(r, c);\n    IF r.eof = FALSE THEN\n      Files.Write(w, c);\n    END;\n  UNTIL r.eof = TRUE;\nEND CopyIO;\n\nPROCEDURE ProcessParameters(VAR sName, mName, dName : ARRAY OF CHAR);\n  VAR\n    arg : ARRAY 1024 OF CHAR;\n    i, res : INTEGER;\nBEGIN\n  mName := \"document.json\";\n  dName := \"document.txt\";\n  arg := \"\";\n  FOR i := 0 TO (Args.count - 1) DO\n    Args.Get(i, arg, res);\n    IF Strings.Pos(\"metadata=\", arg, 0) = 0 THEN\n      Strings.Extract(arg, 9, Strings.Length(arg), mName);\n    ELSIF Strings.Pos(\"document=\", arg, 0) = 0 THEN\n      Strings.Extract(arg, 9, Strings.Length(arg), dName);\n    ELSE\n      Strings.Extract(arg, 0, Strings.Length(arg), sName);\n    END;\n  END;\nEND ProcessParameters;\n\nPROCEDURE AssemblePage(srcName, metaName, docName : ARRAY OF CHAR);\nVAR\n  src, meta, doc : Files.File;\n  reader, writer : Files.Rider;\nBEGIN\n  src := Files.Old(srcName);\n  IF src # NIL THEN\n    Files.Set(reader, src, 0);\n    IF metaName # \"\" THEN\n      meta := Files.New(metaName);\n      Files.Register(meta);\n      Files.Set(writer, meta, 0);\n      FrontMatter(reader, writer);\n      Files.Close(meta);\n    END;\n    IF docName # \"\" THEN\n      doc := Files.New(docName);\n      Files.Register(doc);\n      Files.Set(writer, doc, 0);\n      CopyIO(reader, writer);\n      Files.Close(doc);\n    END;\n  ELSE\n    Out.String(\"ERROR: Could not read \");Out.String(srcName);Out.Ln();\n    ASSERT(FALSE);\n  END;\n  Files.Close(src);\nEND AssemblePage;\n\nBEGIN\n  ProcessParameters(srcName, metaName, docName);\n  AssemblePage(srcName, metaName, docName);\nEND AssemblePage.\n\n~~~\n\n### Next, Previous\n\n+ Next [Dates & Clock](../../11/27/Dates-and-Clock.html)\n+ Previous [Oberon To Markdown](../../10/03/Oberon-to-markdown.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-10-19",
        "keywords": [
          "Oberon-07",
          "portable",
          "markdown",
          "pandoc",
          "frontmatter"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 13,
        "series": "Mostly Oberon",
        "title": "Assembling Pages"
      },
      "url": "posts/2020/10/19/Assemble-pages.json"
    },
    {
      "content": "\n\nDates and Clock\n===============\n\nBy R. S. Doiel, 2020-11-27\n\nThe [Oakwood](http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines)\nguidelines specified a common set of modules for Oberon-2 for writing\nprograms outside of an Oberon System. A missing module from the Oakwood\nguidelines is modules for working with dates and the system clock.\nFortunately the A2 Oberon System[^1] provides a template for that\nfunctionality. In this article I am exploring implementing the\n[Dates](Dates.Mod) and [Clock](Clock.Mod) modules for Oberon-07. I\nalso plan to go beyond the A2 implementations and provide additional\nfunctionality such as parsing procedures and the ability to work with\neither the date or time related attributes separately in the\n`Dates.DateTime` record.\n\n[^1]: A2 information can be found in the [Oberon wikibook](https://en.wikibooks.org/wiki/Oberon#In_A2)\n\nDivergences\n-----------\n\nOne of the noticeable differences between Oberon-07 and Active Oberon\nis the types that functional procedures can return. We cannot return\nan Object in Oberon-07. This is not much of a handicap as we have\nvariable procedure parameters.  Likewise Active Oberon provides\na large variety of integer number types. In Oberon-07 we have only\nINTEGER. Where I've create new procedures I've used the Oberon idiom\nof read only input parameters followed by variable parameters with\nside effects and finally parameters for the target record or values\nto be updated.\n\n\nSimilarities\n------------\n\nIn spite of the divergence I have split the module into two.\nThe [Dates](Dates.html) module is the one you would include in your\nprogram, it provides a DateTime record type which holds the integer\nvalues for year, month, day, hour, minute and second. It provides the\nmeans of parsing a date or time string, comparison, difference and addition\nof dates.  The second module [Clock](Clock.html) provides a mechanism\nto retrieve the real time clock value from the host system and map the\nC based time object into our own DateTime record.  Clock is specific to\nOBNC method of interfacing to the C standard libraries of the host system.\nIf you were to use a different Oberon compiled such as the Oxford\nOberon Compiler you would need to re-implement Clock. Dates itself\nshould be system independent and work with Oberon-07 compilers generally.\n\nClock\n-----\n\nThe Clock module is built from a skeleton in Oberon-07 describing the\nsignatures of the procedure and an implementation in [C](Clock.c) that\nis built using the technique for discussed in my post\n[Combining Oberon-07 and C with OBNC](../../05/01/Combining-Oberon-and-C.html). In that article I outline Karl's three step process to create a\nmodule that will be an interface to C code.  In Step one I create\nthe Oberon module. Normally I'd leave all procedures empty and\ndevelop them in C. In this specific case I went ahead and wrote\nthe procedure called `Get` in Oberon and left the procedure `GetRtcTime`\nblank. This allowed OBNC to generate the C code for `Get` saving\nme some time and create the skeleton for `GetRtcTime` which does\nthe work interfacing with the system clock via C library calls.\n\nThe interface Oberon module looked like this:\n\n~~~{.oberon}\n\nMODULE Clock;\n\nPROCEDURE GetRtcTime*(VAR second, minute, hour, day, month, year : INTEGER);\nBEGIN\nEND GetRtcTime;\n\nPROCEDURE Get*(VAR time, date : INTEGER);\nVAR\n    second, minute, hour, day, month, year : INTEGER;\nBEGIN\n\tGetRtcTime(second, minute, hour, day, month, year);\n\ttime = ((hour * 4096) + (minute * 64)) + second;\n\tdate = ((year * 512) + (month * 32)) + day;\nEND Get;\n\nEND Clock.\n\n~~~\n\nI wrote the `Get` procedure code in Oberon-07 is the OBNC\ncompiler will render the Oberon as C during the\ncompilation process. I save myself writing some C code\nin by leveraging OBNC.\n\n\nStep two was to write [ClockTest.Mod](ClockTest.Mod) in Oberon-07.\n\n~~~{.oberon}\n\nMODULE ClockTest;\n\nIMPORT Tests, Chars, Clock; (* , Out; *)\n\nCONST\n    MAXSTR = Chars.MAXSTR;\n\nVAR\n    title : ARRAY MAXSTR OF CHAR;\n    success, errors : INTEGER;\n\nPROCEDURE TestGetRtcTime() : BOOLEAN;\nVAR second, minute, hour, day, month, year : INTEGER; \n    test, expected, result: BOOLEAN;\nBEGIN\n    test := TRUE;\n    second := 0; minute := 0; hour := 0;\n    day := 0; month := 0; year := 0;\n    expected := TRUE;\n    Clock.GetRtcTime(second, minute, hour, day, month, year);\n\n\n    result := (year > 1900);\n    Tests.ExpectedBool(expected, result, \n          \"year should be greater than 1900\", test);\n    result := (month >= 0) & (month <= 11);\n    Tests.ExpectedBool(expected, result,\n          \"month should be [0, 11]\", test);\n    result := (day >= 1) & (day <= 31);\n    Tests.ExpectedBool(expected, result,\n          \"day should be non-zero\", test);\n\n    result := (hour >= 0) & (hour <= 23);\n    Tests.ExpectedBool(expected, result,\n          \"hour should be [0, 23]\", test);\n    result := (minute >= 0) & (minute <= 59);\n    Tests.ExpectedBool(expected, result, \n          \"minute should be [0, 59]\", test);\n    result := (second >= 0) & (second <= 60);\n    Tests.ExpectedBool(expected, result,\n          \"second year should be [0,60]\", test);\n    RETURN test\nEND TestGetRtcTime;\n\nPROCEDURE TestGet() : BOOLEAN;\nVAR time, date : INTEGER; \n    test, expected, result : BOOLEAN;\nBEGIN\n    test := TRUE;\n    time := 0;\n    date := 0;\n    Clock.Get(time, date);\n    expected := TRUE;\n    result := (time > 0);\n    Tests.ExpectedBool(expected, result,\n        \"time should not be zero\", test);\n    result := (date > 0);\n    Tests.ExpectedBool(expected, result,\n        \"date should not be zero\", test);\n\n    RETURN test\nEND TestGet;\n\nBEGIN\n    Chars.Set(\"Clock module test\", title);\n    success := 0; errors := 0;\n    Tests.Test(TestGetRtcTime, success, errors);\n    Tests.Test(TestGet, success, errors);\n    Tests.Summarize(title, success, errors);\nEND ClockTest.\n\n~~~\n\nClockTest is a simple test module for [Clock.Mod](Clock.Mod).\nIt also serves the role when compiled with OBNC to create the\ntemplate C code for [Clock.c](Clock.c). Here's the steps we\ntake to generate `Clock.c` with OBNC:\n\n~~~{.shell}\n\nobnc ClockTest.Mod\nmv .obnc/Clock.c ./\nvi Clock.c\n\n~~~\n\nAfter compiling `.obnc/Clock.c` I then moved `.obnc/Clock.c`\nto my working directory. Filled in the C version of\n`GetRtcTime` function and modified my [Clock.Mod](Clock.Mod)\nto contain my empty procedure.\n\nThe finally version of Clock.c looks like (note how we need to\ninclude \"Clock.h\" in the head of the our C source file).\n\n~~~{.c}\n\n/*GENERATED BY OBNC 0.16.1*/\n\n#include \".obnc/Clock.h\"\n#include <obnc/OBNC.h>\n#include <time.h>\n\n#define OBERON_SOURCE_FILENAME \"Clock.Mod\"\n\nvoid Clock__GetRtcTime_(OBNC_INTEGER *second_, OBNC_INTEGER *minute_,\n     OBNC_INTEGER *hour_, OBNC_INTEGER *day_,\n     OBNC_INTEGER *month_, OBNC_INTEGER *year_)\n{\n    time_t now;\n    struct tm *time_info;\n    now = time(NULL);\n    time_info = localtime(&now);\n    *second_ = time_info->tm_sec;\n    *minute_ = time_info->tm_min;\n    *hour_ = time_info->tm_hour;\n    *day_ = time_info->tm_mday;\n    *month_ = time_info->tm_mon;\n    *year_ = (time_info->tm_year) + 1900;\n}\n\n\nvoid Clock__Get_(OBNC_INTEGER *time_, OBNC_INTEGER *date_)\n{\n\tOBNC_INTEGER second_, minute_, hour_, day_, month_, year_;\n\n\tClock__GetRtcTime_(&second_, &minute_, \n                       &hour_, &day_, &month_, &year_);\n\t(*time_) = ((hour_ * 4096) + (minute_ * 64)) + second_;\n\t(*date_) = ((year_ * 512) + (month_ * 32)) + day_;\n}\n\n\nvoid Clock__Init(void)\n{\n}\n\n~~~\n\nThe final version of Clock.Mod looks like\n\n~~~{.oberon}\n\nMODULE Clock;\n\nPROCEDURE GetRtcTime*(VAR second, minute, \n                      hour, day, month, year : INTEGER);\nBEGIN\nEND GetRtcTime;\n\nPROCEDURE Get*(VAR time, date : INTEGER);\nBEGIN\nEND Get;\n\nEND Clock.\n\n~~~\n\n\nStep three was to re-compile `ClockTest.Mod` and run the tests.\n\n~~~{.shell}\n\n    obnc ClockTest.Mod\n    ./ClockTest\n\n~~~\n\nDates\n-----\n\nThe dates module provides a rich variety of\nprocedures for working with dates. This includes parsing\ndate strings into `DateTime` records, testing strings for\nsupported date formats, setting dates or time in a `DateTime`\nrecord as well as comparison, difference and addition\n(both addition and subtraction) of dates. Tests for the Dates\nmodule is implemented in [DatesTest.Mod](DatesTest.Mod).\n\n~~~{.oberon}\n\nMODULE Dates;\nIMPORT Chars, Strings, Clock, Convert := extConvert;\n\nCONST\n    MAXSTR = Chars.MAXSTR;\n    SHORTSTR = Chars.SHORTSTR;\n\n    YYYYMMDD* = 1; (* YYYY-MM-DD format *)\n    MMDDYYYY* = 2; (* MM/DD/YYYY format *)\n    YYYYMMDDHHMMSS* = 3; (* YYYY-MM-DD HH:MM:SS format *)\n\nTYPE\n    DateTime* = RECORD\n        year*, month*, day*, hour*, minute*, second* : INTEGER\n    END;\n\nVAR\n    (* Month names, January = 0, December = 11 *)\n    Months*: ARRAY 23 OF ARRAY 10 OF CHAR;\n    (* Days of week, Monday = 0, Sunday = 6 *)\n    Days*: ARRAY 7 OF ARRAY 10 OF CHAR;\n    DaysInMonth: ARRAY 12 OF INTEGER;\n\n\n(* Set -- initialize a date record year, month and day values *)\nPROCEDURE Set*(year, month, day, hour, minute, second : INTEGER; \n               VAR dt: DateTime);\nBEGIN\n    dt.year := year;\n    dt.month := month;\n    dt.day := day;\n    dt.hour := hour;\n    dt.minute := minute;\n    dt.second := second;\nEND Set;\n\n(* SetDate -- set a Date record's year, month and day attributes *)\nPROCEDURE SetDate*(year, month, day : INTEGER; VAR dt: DateTime);\nBEGIN\n    dt.year := year;\n    dt.month := month;\n    dt.day := day;\nEND SetDate;\n\n(* SetTime -- set a Date record's hour, minute, second attributes *)\nPROCEDURE SetTime*(hour, minute, second : INTEGER; VAR dt: DateTime);\nBEGIN\n    dt.hour := hour;\n    dt.minute := minute;\n    dt.second := second;\nEND SetTime;\n\n(* Copy -- copy the values from one date record to another *)\nPROCEDURE Copy*(src : DateTime; VAR dest : DateTime);\nBEGIN\n    dest.year := src.year;\n    dest.month := src.month;\n    dest.day := src.day;\n    dest.hour := src.hour;\n    dest.minute := src.minute;\n    dest.second := src.second;\nEND Copy;\n\n(* ToChars -- converts a date record into an array of chars using\nthe format constant. Formats supported are YYYY-MM-DD HH:MM:SS\nor MM/DD/YYYY HH:MM:SS. *)\nPROCEDURE ToChars*(dt: DateTime; fmt : INTEGER;\n                   VAR src : ARRAY OF CHAR);\nVAR ok : BOOLEAN;\nBEGIN\n    Chars.Clear(src);\n    IF fmt = YYYYMMDD THEN\n        Chars.AppendInt(dt.year, 4, \"0\", src);\n        ok := Chars.AppendChar(\"-\", src);\n        Chars.AppendInt(dt.month, 2, \"0\", src);\n        ok := Chars.AppendChar(\"-\", src);\n        Chars.AppendInt(dt.day, 2, \"0\", src);\n    ELSIF fmt = MMDDYYYY THEN\n        Chars.AppendInt(dt.month, 2, \"0\", src);\n        ok := Chars.AppendChar(\"/\", src);\n        Chars.AppendInt(dt.day, 2, \"0\", src);\n        ok := Chars.AppendChar(\"/\", src);\n        Chars.AppendInt(dt.year, 4, \"0\", src);\n    ELSIF fmt = YYYYMMDDHHMMSS THEN\n        Chars.AppendInt(dt.year, 4, \"0\", src);\n        ok := Chars.AppendChar(\"-\", src);\n        Chars.AppendInt(dt.month, 2, \"0\", src);\n        ok := Chars.AppendChar(\"-\", src);\n        Chars.AppendInt(dt.day, 2, \"0\", src);\n        ok := Chars.AppendChar(\" \", src);\n        Chars.AppendInt(dt.hour, 2, \"0\", src);\n        ok := Chars.AppendChar(\":\", src);\n        Chars.AppendInt(dt.minute, 2, \"0\", src);\n        ok := Chars.AppendChar(\":\", src);\n        Chars.AppendInt(dt.second, 2, \"0\", src);\n    END;\nEND ToChars;\n\n(*\n * Date and Time functions very much inspired by A2 but\n * adapted for use in Oberon-07 and OBNC compiler.\n *)\n\n(* LeapYear -- returns TRUE if 'year' is a leap year *)\nPROCEDURE LeapYear*(year: INTEGER): BOOLEAN;\nBEGIN\n\tRETURN (year > 0) & (year MOD 4 = 0) & \n           (~(year MOD 100 = 0) OR (year MOD 400 = 0))\nEND LeapYear;\n\n(* NumOfDays -- number of days, returns the number of \ndays in that month *)\nPROCEDURE NumOfDays*(year, month: INTEGER): INTEGER;\nVAR result : INTEGER;\nBEGIN\n    result := 0;\n\tDEC(month);\n\tIF ((month >= 0) & (month < 12)) THEN\n\t    IF (month = 1) & LeapYear(year) THEN\n            result := DaysInMonth[1]+1;\n\t    ELSE\n            result := DaysInMonth[month];\n\t    END;\n    END;\n    RETURN result\nEND NumOfDays;\n\n(* IsValid -- checks if the attributes set in a \nDateTime record are valid *)\nPROCEDURE IsValid*(dt: DateTime): BOOLEAN;\nBEGIN\n\tRETURN ((dt.year > 0) & (dt.month > 0) &\n           (dt.month <= 12) & (dt.day > 0) &\n           (dt.day <= NumOfDays(dt.year, dt.month)) &\n           (dt.hour >= 0) & (dt.hour < 24) & (dt.minute >= 0) &\n           (dt.minute < 60) & (dt.second >= 0) & (dt.second < 60))\nEND IsValid;\n\n(* IsValidDate -- checks to see if a datetime record \nhas valid day, month and year attributes *)\nPROCEDURE IsValidDate*(dt: DateTime) : BOOLEAN;\nBEGIN\n\tRETURN (dt.year > 0) & (dt.month > 0) &\n           (dt.month <= 12) & (dt.day > 0) &\n           (dt.day <= NumOfDays(dt.year, dt.month))\nEND IsValidDate;\n\n(* IsValidTime -- checks if the hour, minute, second\nattributes set in a DateTime record are valid *)\nPROCEDURE IsValidTime*(dt: DateTime): BOOLEAN;\nBEGIN\n\tRETURN (dt.hour >= 0) & (dt.hour < 24) &\n           (dt.minute >= 0) & (dt.minute < 60) &\n           (dt.second >= 0) & (dt.second < 60)\nEND IsValidTime;\n\n\n(* OberonToDateTime -- convert an Oberon date/time \nto a DateTime structure *)\nPROCEDURE OberonToDateTime*(Date, Time: INTEGER; \n                            VAR dt : DateTime);\nBEGIN\n\tdt.second := Time MOD 64; Time := Time DIV 64;\n\tdt.minute := Time MOD 64; Time := Time DIV 64;\n\tdt.hour := Time MOD 24;\n\tdt.day := Date MOD 32; Date := Date DIV 32;\n\tdt.month := (Date MOD 16) + 1; Date := Date DIV 16;\n\tdt.year := Date;\nEND OberonToDateTime;\n\n(* DateTimeToOberon -- convert a DateTime structure\nto an Oberon date/time *)\nPROCEDURE DateTimeToOberon*(dt: DateTime;\n                            VAR date, time: INTEGER);\nBEGIN\n\tIF IsValid(dt) THEN\n\tdate := (dt.year)*512 + dt.month*32 + dt.day;\n\ttime := dt.hour*4096 + dt.minute*64 + dt.second\n    ELSE\n        date := 0;\n        time := 0;\n    END;\nEND DateTimeToOberon;\n\n(* Now -- returns the current date and time as a\nDateTime record. *)\nPROCEDURE Now*(VAR dt: DateTime);\nVAR d, t: INTEGER;\nBEGIN\n\tClock.Get(t, d);\n\tOberonToDateTime(d, t, dt);\nEND Now;\n\n\n(* WeekDate -- returns the ISO 8601 year number,\nweek number & week day (Monday=1, ....Sunday=7)\nAlgorithm is by Rick McCarty, \nhttp://personal.ecu.edu/mccartyr/ISOwdALG.txt\n*)\nPROCEDURE WeekDate*(dt: DateTime; \n                    VAR year, week, weekday: INTEGER);\nVAR doy, i, yy, c, g, jan1: INTEGER; leap: BOOLEAN;\nBEGIN\n\tIF IsValid(dt) THEN\n\t\tleap := LeapYear(dt.year);\n\t\tdoy := dt.day; i := 0;\n\t\tWHILE (i < (dt.month - 1)) DO\n            doy := doy + DaysInMonth[i];\n            INC(i);\n        END;\n\t\tIF leap & (dt.month > 2) THEN\n            INC(doy);\n        END;\n\t\tyy := (dt.year - 1) MOD 100;\n        c := (dt.year - 1) - yy;\n        g := (yy + yy) DIV 4;\n\t\tjan1 := 1 + (((((c DIV 100) MOD 4) * 5) + g) MOD 7);\n\n\t\tweekday := 1 + (((doy + (jan1 - 1)) - 1) MOD 7);\n        (* does doy fall in year-1 ? *)\n\t\tIF (doy <= (8 - jan1)) & (jan1 > 4) THEN \n\t\t\tyear := dt.year - 1;\n\t\t\tIF (jan1 = 5) OR ((jan1 = 6) & LeapYear(year)) THEN\n                week := 53;\n\t\t\tELSE\n                week := 52;\n\t\t\tEND;\n\t\tELSE\n\t\t\tIF leap THEN\n                i := 366;\n            ELSE\n                i := 365;\n            END;\n\t\t\tIF ((i - doy) < (4 - weekday)) THEN\n\t\t\t\tyear := dt.year + 1;\n\t\t\t\tweek := 1;\n\t\t\tELSE\n\t\t\t\tyear := dt.year;\n\t\t\t\ti := doy + (7-weekday) + (jan1-1);\n\t\t\t\tweek := i DIV 7;\n\t\t\t\tIF (jan1 > 4) THEN\n                    DEC(week);\n                END;\n\t\t\tEND;\n\t\tEND;\n\tELSE\n\t\tyear := -1; week := -1; weekday := -1;\n\tEND;\nEND WeekDate;\n\n(* Equal -- compare to date records to see if they \nare equal values *)\nPROCEDURE Equal*(t1, t2: DateTime) : BOOLEAN;\nBEGIN\n\tRETURN ((t1.second = t2.second) &\n            (t1.minute = t2.minute) & (t1.hour = t2.hour) &\n            (t1.day = t2.day) & (t1.month = t2.month) &\n            (t1.year = t2.year))\nEND Equal;\n\n(* compare -- used in Compare only for comparing\nspecific values, returning an appropriate -1, 0, 1 *)\nPROCEDURE compare(t1, t2 : INTEGER) : INTEGER;\nVAR result : INTEGER;\nBEGIN\n\tIF (t1 < t2) THEN\n        result := -1;\n\tELSIF (t1 > t2) THEN\n        result := 1;\n\tELSE\n        result := 0;\n\tEND;\n\tRETURN result\nEND compare;\n\n(* Compare -- returns -1 if (t1 < t2), \n0 if (t1 = t2) or 1 if (t1 >  t2) *)\nPROCEDURE Compare*(t1, t2: DateTime) : INTEGER;\nVAR result : INTEGER;\nBEGIN\n\tresult := compare(t1.year, t2.year);\n\tIF (result = 0) THEN\n\t\tresult := compare(t1.month, t2.month);\n\t\tIF (result = 0) THEN\n\t\t\tresult := compare(t1.day, t2.day);\n\t\t\tIF (result = 0) THEN\n\t\t\t\tresult := compare(t1.hour, t2.hour);\n\t\t\t\tIF (result = 0) THEN\n\t\t\t\t\tresult := compare(t1.minute, t2.minute);\n\t\t\t\t\tIF (result = 0) THEN\n\t\t\t\t\t\tresult := compare(t1.second, t2.second);\n\t\t\t\t\tEND;\n\t\t\t\tEND;\n\t\t\tEND;\n\t\tEND;\n\tEND;\n\tRETURN result\nEND Compare;\n\n(* CompareDate -- compare day, month and year\nvalues only *)\nPROCEDURE CompareDate*(t1, t2: DateTime) : INTEGER;\nVAR result : INTEGER;\nBEGIN\n\tresult := compare(t1.year, t2.year);\n\tIF (result = 0) THEN\n\t\tresult := compare(t1.month, t2.month);\n\t\tIF (result = 0) THEN\n\t\t\tresult := compare(t1.day, t2.day);\n\t\tEND;\n\tEND;\n\tRETURN result\nEND CompareDate;\n\n(* CompareTime -- compare second, minute and\nhour values only *)\nPROCEDURE CompareTime*(t1, t2: DateTime) : INTEGER;\nVAR result : INTEGER;\nBEGIN\n\tresult := compare(t1.hour, t2.hour);\n\tIF (result = 0) THEN\n\t\tresult := compare(t1.minute, t2.minute);\n\t\tIF (result = 0) THEN\n\t\t\tresult := compare(t1.second, t2.second);\n\t\tEND;\n\tEND;\n\tRETURN result\nEND CompareTime;\n\n\n\n(* TimeDifferences -- returns the absolute time\ndifference between\nt1 and t2.\n\nNote that leap seconds are not counted,\nsee http://www.eecis.udel.edu/~mills/leap.html *)\nPROCEDURE TimeDifference*(t1, t2: DateTime;\n              VAR days, hours, minutes, seconds : INTEGER);\nCONST \n    SecondsPerMinute = 60; \n    SecondsPerHour = 3600; \n    SecondsPerDay = 86400;\nVAR start, end: DateTime; year, month, second : INTEGER;\nBEGIN\n\tIF (Compare(t1, t2) = -1) THEN\n        start := t1;\n        end := t2;\n    ELSE\n        start := t2;\n        end := t1;\n    END;\n\tIF (start.year = end.year) & (start.month = end.month) &\n       (start.day = end.day) THEN\n\t\tsecond := end.second - start.second + \n                  ((end.minute - start.minute) * SecondsPerMinute) +\n                  ((end.hour - start.hour) * SecondsPerHour);\n\t\tdays := 0;\n        hours := 0;\n        minutes := 0;\n\tELSE\n\t\t(* use start date/time as reference point *)\n\t\t(* seconds until end of the start.day *)\n\t\tsecond := (SecondsPerDay - start.second) -\n                  (start.minute * SecondsPerMinute) -\n                  (start.hour * SecondsPerHour);\n\t\tIF (start.year = end.year) &\n           (start.month = end.month) THEN\n\t\t\t(* days between start.day and end.day *)\n\t\t\tdays := (end.day - start.day) - 1;\n\t\tELSE\n\t\t\t(* days until start.month ends excluding start.day *)\n\t\t\tdays := NumOfDays(start.year, start.month) - start.day;\n\t\t\tIF (start.year = end.year) THEN\n\t\t\t\t(* months between start.month and end.month *)\n\t\t\t\tFOR month := start.month + 1 TO end.month - 1 DO\n\t\t\t\t\tdays := days + NumOfDays(start.year, month);\n\t\t\t\tEND;\n\t\t\tELSE\n\t\t\t\t(* days until start.year ends (excluding start.month) *)\n\t\t\t\tFOR month := start.month + 1 TO 12 DO\n\t\t\t\t\tdays := days + NumOfDays(start.year, month);\n\t\t\t\tEND;\n                (* days between start.years and end.year *)\n\t\t\t\tFOR year := start.year + 1 TO end.year - 1 DO\n\t\t\t\t\tIF LeapYear(year) THEN days := days + 366; \n                    ELSE days := days + 365; END;\n\t\t\t\tEND;\n                (* days until we reach end.month in end.year *)\n\t\t\t\tFOR month := 1 TO end.month - 1 DO\n\t\t\t\t\tdays := days + NumOfDays(end.year, month);\n\t\t\t\tEND;\n\t\t\tEND;\n\t\t\t(* days in end.month until reaching end.day excluding end.day *)\n\t\t\tdays := (days + end.day) - 1;\n\t\tEND;\n\t\t(* seconds in end.day *)\n\t\tsecond := second + end.second +\n                  (end.minute * SecondsPerMinute) +\n                  (end.hour * SecondsPerHour);\n\tEND;\n\tdays := days + (second DIV SecondsPerDay); \n    second := (second MOD SecondsPerDay);\n\thours := (second DIV SecondsPerHour); \n    second := (second MOD SecondsPerHour);\n\tminutes := (second DIV SecondsPerMinute);\n    second := (second MOD SecondsPerMinute);\n\tseconds := second;\nEND TimeDifference;\n\n(* AddYear -- Add/Subtract a number of years to/from date *)\nPROCEDURE AddYears*(VAR dt: DateTime; years : INTEGER);\nBEGIN\n\tASSERT(IsValid(dt));\n\tdt.year := dt.year + years;\n\tASSERT(IsValid(dt));\nEND AddYears;\n\n(* AddMonths -- Add/Subtract a number of months to/from date.\nThis will adjust date.year if necessary *)\nPROCEDURE AddMonths*(VAR dt: DateTime; months : INTEGER);\nVAR years : INTEGER;\nBEGIN\n\tASSERT(IsValid(dt));\n\tyears := months DIV 12;\n\tdt.month := dt.month + (months MOD 12);\n\tIF (dt.month > 12) THEN\n\t\tdt.month := dt.month - 12;\n\t\tINC(years);\n\tELSIF (dt.month < 1) THEN\n\t\tdt.month := dt.month + 12;\n\t\tDEC(years);\n\tEND;\n\tIF (years # 0) THEN AddYears(dt, years); END;\n\tASSERT(IsValid(dt));\nEND AddMonths;\n\n(* AddDays --  Add/Subtract a number of days to/from date.\nThis will adjust date.month and date.year if necessary *)\nPROCEDURE AddDays*(VAR dt: DateTime; days : INTEGER);\nVAR nofDaysLeft : INTEGER;\nBEGIN\n\tASSERT(IsValid(dt));\n\tIF (days > 0) THEN\n\t\tWHILE (days > 0) DO\n\t\t\tnofDaysLeft := NumOfDays(dt.year, dt.month) - dt.day;\n\t\t\tIF (days > nofDaysLeft) THEN\n\t\t\t\tdt.day := 1;\n\t\t\t\tAddMonths(dt, 1);\n                (* -1 because we consume the first day \n                    of the next month *)\n\t\t\t\tdays := days - nofDaysLeft - 1;\n\t\t\tELSE\n\t\t\t\tdt.day := dt.day + days;\n\t\t\t\tdays := 0;\n\t\t\tEND;\n\t\tEND;\n\tELSIF (days < 0) THEN\n\t\tdays := -days;\n\t\tWHILE (days > 0) DO\n\t\t\tnofDaysLeft := dt.day - 1;\n\t\t\tIF (days > nofDaysLeft) THEN\n                (* otherwise, dt could become an invalid \n                   date if the previous month has less \n                   days than dt.day *)\n\t\t\t\tdt.day := 1; \n\t\t\t\tAddMonths(dt, -1);\n\t\t\t\tdt.day := NumOfDays(dt.year, dt.month);\n                (* -1 because we consume the last day \n                   of the previous month *)\n\t\t\t\tdays := days - nofDaysLeft - 1;\n\t\t\tELSE\n\t\t\t\tdt.day := dt.day - days;\n\t\t\t\tdays := 0;\n\t\t\tEND;\n\t\tEND;\n\tEND;\n\tASSERT(IsValid(dt));\nEND AddDays;\n\n(* AddHours -- Add/Subtract a number of hours to/from date.\nThis will adjust date.day, date.month and date.year if necessary *)\nPROCEDURE AddHours*(VAR dt: DateTime; hours : INTEGER);\nVAR days : INTEGER;\nBEGIN\n\tASSERT(IsValid(dt));\n\tdt.hour := dt.hour + hours;\n\tdays := dt.hour DIV 24;\n\tdt.hour := dt.hour MOD 24;\n\tIF (dt.hour < 0) THEN\n\t\tdt.hour := dt.hour + 24;\n\t\tDEC(days);\n\tEND;\n\tIF (days # 0) THEN AddDays(dt, days); END;\n\tASSERT(IsValid(dt));\nEND AddHours;\n\n(* AddMinutes -- Add/Subtract a number of minutes to/from date.\nThis will adjust date.hour, date.day, date.month and date.year\nif necessary *)\nPROCEDURE AddMinutes*(VAR dt: DateTime; minutes : INTEGER);\nVAR hours : INTEGER;\nBEGIN\n\tASSERT(IsValid(dt));\n\tdt.minute := dt.minute + minutes;\n\thours := dt.minute DIV 60;\n\tdt.minute := dt.minute MOD 60;\n\tIF (dt.minute < 0) THEN\n\t\tdt.minute := dt.minute + 60;\n\t\tDEC(hours);\n\tEND;\n\tIF (hours # 0) THEN AddHours(dt, hours); END;\n\tASSERT(IsValid(dt));\nEND AddMinutes;\n\n(* AddSeconds -- Add/Subtract a number of seconds to/from date.\nThis will adjust date.minute, date.hour, date.day, date.month and\ndate.year if necessary *)\nPROCEDURE AddSeconds*(VAR dt: DateTime; seconds : INTEGER);\nVAR minutes : INTEGER;\nBEGIN\n\tASSERT(IsValid(dt));\n\tdt.second := dt.second + seconds;\n\tminutes := dt.second DIV 60;\n\tdt.second := dt.second MOD 60;\n\tIF (dt.second < 0) THEN\n\t\tdt.second := dt.second + 60;\n\t\tDEC(minutes);\n\tEND;\n\tIF (minutes # 0) THEN AddMinutes(dt, minutes); END;\n\tASSERT(IsValid(dt));\nEND AddSeconds;\n\n\n(* IsDateString -- return TRUE if the ARRAY OF CHAR is 10 characters\nlong and is either in the form of YYYY-MM-DD or MM/DD/YYYY where\nY, M and D are digits.\nNOTE: is DOES NOT check the ranges of the digits. *)\nPROCEDURE IsDateString*(inline : ARRAY OF CHAR) : BOOLEAN;\nVAR\n    test : BOOLEAN; i, pos : INTEGER;\n    src : ARRAY MAXSTR OF CHAR;\nBEGIN\n    Chars.Set(inline, src);\n    Chars.TrimSpace(src);\n    test := FALSE;\n    IF Strings.Length(src) = 10 THEN\n        pos := Strings.Pos(\"-\", src, 0);\n        IF pos > 0 THEN\n            IF (src[4] = \"-\") & (src[7] = \"-\") THEN\n                test := TRUE;\n                FOR i := 0 TO 9 DO\n                    IF (i # 4) & (i # 7) THEN\n                       IF Chars.IsDigit(src[i]) = FALSE THEN\n                           test := FALSE;\n                       END;\n                    END;\n                END;\n            ELSE\n                test := FALSE;\n            END;\n        END;\n        pos := Strings.Pos(\"/\", src, 0);\n        IF pos > 0 THEN\n            IF (src[2] = \"/\") & (src[5] = \"/\") THEN\n                test := TRUE;\n                FOR i := 0 TO 9 DO\n                    IF (i # 2) & (i # 5) THEN\n                        IF Chars.IsDigit(src[i]) = FALSE THEN\n                            test := FALSE;\n                        END;\n                    END;\n                END;\n            ELSE\n                test := FALSE;\n            END;\n        END;\n    END;\n    RETURN test\nEND IsDateString;\n\n(* IsTimeString -- return TRUE if the ARRAY OF CHAR has 4 to 8\ncharacters in the form of H:MM, HH:MM, HH:MM:SS where H, M and S\nare digits. *)\nPROCEDURE IsTimeString*(inline : ARRAY OF CHAR) : BOOLEAN;\nVAR\n    test : BOOLEAN;\n    l : INTEGER;\n    src : ARRAY MAXSTR OF CHAR;\nBEGIN\n    Chars.Set(inline, src);\n    Chars.TrimSpace(src);\n    (* remove any trailing am/pm suffixes *)\n    IF Chars.EndsWith(\"m\", src) THEN\n        IF Chars.EndsWith(\"am\", src) THEN\n            Chars.TrimSuffix(\"am\", src);\n        ELSE\n            Chars.TrimSuffix(\"pm\", src);\n        END;\n        Chars.TrimSpace(src);\n    ELSIF Chars.EndsWith(\"M\", src) THEN\n        Chars.TrimSuffix(\"AM\", src);\n        Chars.TrimSuffix(\"PM\", src);\n        Chars.TrimSpace(src);\n    ELSIF Chars.EndsWith(\"p\", src) THEN\n        Chars.TrimSuffix(\"p\", src);\n        Chars.TrimSpace(src);\n    ELSIF Chars.EndsWith(\"P\", src) THEN\n        Chars.TrimSuffix(\"P\", src);\n        Chars.TrimSpace(src);\n    ELSIF Chars.EndsWith(\"a\", src) THEN\n        Chars.TrimSuffix(\"a\", src);\n        Chars.TrimSpace(src);\n    ELSIF Chars.EndsWith(\"A\", src) THEN\n        Chars.TrimSuffix(\"A\", src);\n        Chars.TrimSpace(src);\n    END;\n    Strings.Extract(src, 0, 8, src);\n    test := FALSE;\n    l := Strings.Length(src);\n    IF (l = 4) THEN\n        IF Chars.IsDigit(src[0]) & (src[1] = \":\") &\n            Chars.IsDigit(src[2]) & Chars.IsDigit(src[3]) THEN\n            test := TRUE;\n        ELSE\n            test := FALSE;\n        END;\n    ELSIF (l = 5) THEN\n        IF Chars.IsDigit(src[0]) & Chars.IsDigit(src[1]) &\n            (src[2] = \":\") &\n            Chars.IsDigit(src[3]) & Chars.IsDigit(src[4]) THEN\n            test := TRUE;\n        ELSE\n            test := FALSE;\n        END;\n    ELSIF (l = 8) THEN\n        IF Chars.IsDigit(src[0]) & Chars.IsDigit(src[1]) &\n            (src[2] = \":\") &\n            Chars.IsDigit(src[3]) & Chars.IsDigit(src[4]) &\n            (src[5] = \":\") &\n            Chars.IsDigit(src[6]) & Chars.IsDigit(src[7]) THEN\n            test := TRUE;\n        ELSE\n            test := FALSE;\n        END;\n    ELSE\n        test := FALSE;\n    END;\n    RETURN test\nEND IsTimeString;\n\n(* ParseDate -- parses a date string in YYYY-MM-DD or\nMM/DD/YYYY format. *)\nPROCEDURE ParseDate*(inline : ARRAY OF CHAR;\n                     VAR year, month, day : INTEGER) : BOOLEAN;\nVAR src, tmp : ARRAY MAXSTR OF CHAR; ok, b : BOOLEAN;\nBEGIN\n    Chars.Set(inline, src);\n    Chars.Clear(tmp);\n    ok := FALSE;\n\tIF IsDateString(src) THEN\n        (* LIMITATION: Need to allow for more than 4 digit years! *)\n        IF (src[2] = \"/\") & (src[5] = \"/\") THEN\n            ok := TRUE;\n            Strings.Extract(src, 0, 2, tmp);\n            Convert.StringToInt(tmp, month, b);\n            ok := ok & b;\n            Strings.Extract(src, 4, 2, tmp);\n            Convert.StringToInt(tmp, day, b);\n            ok := ok & b;\n            Strings.Extract(src, 6, 4, tmp);\n            Convert.StringToInt(tmp, year, b);\n            ok := ok & b;\n        ELSIF (src[4] = \"-\") & (src[7] = \"-\") THEN\n            ok := TRUE;\n            Strings.Extract(src, 0, 4, tmp);\n            Convert.StringToInt(tmp, year, b);\n            ok := ok & b;\n            Strings.Extract(src, 5, 2, tmp);\n            Convert.StringToInt(tmp, month, b);\n            ok := ok & b;\n            Strings.Extract(src, 8, 2, tmp);\n            Convert.StringToInt(tmp, day, b);\n            ok := ok & b;\n        ELSE\n            ok := FALSE;\n        END;\n    END;\n    RETURN ok\nEND ParseDate;\n\n(* ParseTime -- procedure for parsing time strings into hour,\nminute, second. Returns TRUE on successful parse, FALSE otherwise *)\nPROCEDURE ParseTime*(inline : ARRAY OF CHAR;\n                     VAR hour, minute, second : INTEGER) : BOOLEAN;\nVAR src, tmp : ARRAY MAXSTR OF CHAR;\n    ok : BOOLEAN; cur, pos, l : INTEGER;\nBEGIN\n    Chars.Set(inline, src);\n    Chars.Clear(tmp);\n\tIF IsTimeString(src) THEN\n        ok := TRUE;\n        cur := 0; pos := 0;\n        pos := Strings.Pos(\":\", src, cur);\n        IF pos > 0 THEN\n        (* Get Hour *)\n            Strings.Extract(src, cur, pos - cur, tmp);\n            Convert.StringToInt(tmp, hour, ok);\n            IF ok THEN\n                (* Get Minute *)\n                cur := pos + 1;\n                Strings.Extract(src, cur, 2, tmp);\n                Convert.StringToInt(tmp, minute, ok);\n                IF ok THEN\n                    (* Get second, optional, default to zero *)\n                    pos := Strings.Pos(\":\", src, cur);\n                    IF pos > 0 THEN\n                        cur := pos + 1;\n                        Strings.Extract(src, cur, 2, tmp);\n                        Convert.StringToInt(tmp, second, ok);\n                        cur := cur + 2;\n                    ELSE\n                        second := 0;\n                    END;\n                    (* Get AM/PM, optional, adjust hour if PM *)\n                    l := Strings.Length(src);\n                    WHILE (cur < l) & Chars.IsSpace(src[cur]) DO\n                        cur := cur + 1;\n                    END;\n                    Strings.Extract(src, cur, 2, tmp);\n                    Chars.TrimSpace(tmp);\n                    IF Chars.Equal(tmp, \"PM\") OR Chars.Equal(tmp, \"pm\") THEN\n                        hour := hour + 12;\n                    END;\n                ELSE\n                    ok := FALSE;\n                END;\n            END;\n        ELSE\n            ok := FALSE;\n        END;\n    ELSE\n        ok := FALSE;\n    END;\n    IF ok THEN\n        ok := ((hour >= 0) & (hour <= 23)) &\n            ((minute >= 0) & (minute <= 59)) &\n                ((second >= 0) & (second <= 59));\n    END;\n    RETURN ok\nEND ParseTime;\n\n\n(* Parse accepts a date array of chars in either dates, times\nor dates and times separate by spaces. Date formats supported\ninclude YYYY-MM-DD, MM/DD/YYYY. Time formats include\nH:MM, HH:MM, H:MM:SS, HH:MM:SS with 'a', 'am', 'p', 'pm'\nsuffixes.  Dates and times can also be accepted as JSON\nexpressions with the individual time compontents are specified\nas attributes, e.g. {\"year\": 1998, \"month\": 12, \"day\": 10,\n\"hour\": 11, \"minute\": 4, \"second\": 3}.\nParse returns TRUE on successful parse, FALSE otherwise.\n\nBUG: Assumes a 4 digit year.\n*)\nPROCEDURE Parse*(inline : ARRAY OF CHAR; VAR dt: DateTime) : BOOLEAN;\nVAR src, ds, ts, tmp : ARRAY SHORTSTR OF CHAR; ok, okDate, okTime : BOOLEAN;\n    pos, year, month, day, hour, minute, second : INTEGER;\nBEGIN\n    dt.year := 0;\n    dt.month := 0;\n    dt.day := 0;\n    dt.hour := 0;\n    dt.minute := 0;\n    dt.second := 0;\n    Chars.Clear(tmp);\n    Chars.Set(inline, src);\n    Chars.TrimSpace(src);\n    (* Split into Date and Time components *)\n    pos := Strings.Pos(\" \", src, 0);\n    IF pos >= 0 THEN\n        Strings.Extract(src, 0, pos, ds);\n        pos := pos + 1;\n        Strings.Extract(src, pos, Strings.Length(src) - pos, ts);\n    ELSE\n        Chars.Set(src, ds);\n        Chars.Set(src, ts);\n    END;\n    ok := FALSE;\n    IF IsDateString(ds) THEN\n        ok := TRUE;\n        okDate := ParseDate(ds, year, month, day);\n        SetDate(year, month, day, dt);\n        ok := ok & okDate;\n    END;\n    IF IsTimeString(ts) THEN\n        ok := ok OR okDate;\n        okTime := ParseTime(ts, hour, minute, second);\n        SetTime(hour, minute, second, dt);\n        ok := ok & okTime;\n    END;\n    RETURN ok\nEND Parse;\n\nBEGIN\n    Chars.Set(\"January\", Months[0]);\n    Chars.Set(\"February\", Months[1]);\n    Chars.Set(\"March\", Months[2]);\n    Chars.Set(\"April\", Months[3]);\n    Chars.Set(\"May\", Months[4]);\n    Chars.Set(\"June\", Months[5]);\n    Chars.Set(\"July\", Months[6]);\n    Chars.Set(\"August\", Months[7]);\n    Chars.Set(\"September\", Months[8]);\n    Chars.Set(\"October\", Months[9]);\n    Chars.Set(\"November\", Months[10]);\n    Chars.Set(\"December\", Months[11]);\n\n    Chars.Set(\"Sunday\", Days[0]);\n    Chars.Set(\"Monday\", Days[1]);\n    Chars.Set(\"Tuesday\", Days[2]);\n    Chars.Set(\"Wednesday\", Days[3]);\n    Chars.Set(\"Thursday\", Days[4]);\n    Chars.Set(\"Friday\", Days[5]);\n    Chars.Set(\"Saturday\", Days[6]);\n\n    DaysInMonth[0] := 31; (* January *)\n    DaysInMonth[1] := 28; (* February *)\n    DaysInMonth[2] := 31; (* March *)\n    DaysInMonth[3] := 30; (* April *)\n    DaysInMonth[4] := 31; (* May *)\n    DaysInMonth[5] := 30; (* June *)\n    DaysInMonth[6] := 31; (* July *)\n    DaysInMonth[7] := 31; (* August *)\n    DaysInMonth[8] := 30; (* September *)\n    DaysInMonth[9] := 31; (* October *)\n    DaysInMonth[10] := 30; (* November *)\n    DaysInMonth[11] := 31; (* December *)\n\nEND Dates.\n\n~~~\n\nPostscript: In this article I included a reference to the module\n**[Chars](Chars.html)**. This is a non-standard module I wrote\nfor Oberon-07. Here is a link to [Chars](Chars.Mod). RSD, 2021-05-06\n\n### Next, Previous\n\n+ Next [Beyond Oakwood, Modules and Aliases](/blog/2021/05/16/Beyond-Oakwood-Modules-and-Aliases.html)\n+ Previous [Assemble Pages](/blog/2020/10/19/Assemble-pages.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-11-27",
        "keywords": [
          "Oberon-07",
          "C-shared",
          "obnc"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 14,
        "series": "Mostly Oberon",
        "title": "Dates & Clock"
      },
      "url": "posts/2020/11/27/Dates-and-Clock.json"
    },
    {
      "content": "\n\nSetting up a RetroFlag GPi Case\n===============================\n\nBy R. S. Doiel, 2020-12-24\n\nThese are my notes for setting up a RetroFlag GPi case using Recalbox\ndistribution for retro gaming.\n\n+ RetroFlag GPi Case Kit (including a Raspberry Pi Zero W and blank SD Card)\n+ A computer to setup the SD Card  and the Raspberry Pi Imager v1.5\n\nWe will be installing [Recalbox](https://www.recalbox.com/ \"the all-in-one retro gaming console\")\nv7.7.x for Raspberry Pi Zero W and GPi case.  Recalbox which is a Retro\nGaming Linux distribution.\n\nSteps\n=====\n\nPreparing the 32 GiB SD Card\n---------------------------\n\n1. Download the appropriate Raspberry Pi Imager 1.5 from \n   https://www.raspberrypi.org/software/ for your system\n2. Install and launch the Raspberry Pi Imager\n3. Click \"Operating System\"\n  a. Select \"Emulation and game OS\"\n  b. Select \"Recalbox\"\n  c. Select \"Recalbox 7.1.1-Reloaded (Pi 0/1/GPi Case)\"\n4. Click \"SD Card\" \", then select the bank 32 GiB SD Card\n5. Click \"Write\"\n6. You will be asked remove the SD Card when done, do so and and exit \n   Raspberry Pi Imager\n\nNOTE: The current release of Recalbox (7.7.1) doesn't require patching\nwith \"GPI_Case_patch.zip\" or installing the shutdown scripts as suggested\non the RetroFlag website. Applying the patches will prevent the GPi\nfrom booting. The website instructions appear to be for an earlier release\nof Recalbox.\n\n\nInstalling the Raspberry Pi Zero W in the GPi Case\n--------------------------------------------------\n\nThe RetroFlag comes with instructions to install the Raspberry Pi Zero W\nin the case. I found the pictorial instructions confusing. Doing a search\nfor \"RetroFlag GPi Case Setup\" yielded a link to [Howchoo's YouTube\nvideo](https://www.youtube.com/watch?v=NyJUlNifN1I&feature=youtu.be \"RetroFlag GPi CASE Setup and Usage\"),  This video also talks about setting up Retro Pi software,\nGPi case patches. Skip these. The instructions are now for software that\nis out of date (the video dates back to 2019). \n\nNOTE: Howchoo describes installing RetroPie not Recalbox. Don't install a\n\"wpa_supplicant.conf\" file or \"ssh\" file on the SD Card as suggested.\nIt is not needed and will cause problems.\n\nThe GPi case looks very much like a Game Boy. It includes a \"Game Pack\"\ntype module which will hold our Raspberry Pi once installed. I found the\nassembly instructions confusing but searching YouTube for \"RetroFlag GPi\nCase Setup\" listed several videos which describe the process of putting\nthe case together as well as how to install RetroPie or\nRecalbox Linux Distributions.\n\nBooting the Pi Zero W with the SD Card\n--------------------------------------\n\n1. Make sure the GPi Zero Case **IS NOT CONNECTED TO POWER**\n  a. the switch the case off\n  b. Disconnect the barrel to USB cable from a power source\n2. Remove the \"game pack\" element where you've installed the Raspberry Pi Zero W\n3. Insert the SD Card into the SD Card slot under the soft cover on the side of\n   the Game Pack case\n4. Re-insert \"Game Pack\" into side of the GPi case\n5. Plug the barrel USB cable into a USB Power supply , \n6. Turn the power switch to \"ON\" on the top of the GPi case\n7. Wait patiently, it's going to take several minutes to boot the first time\n\n\n\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2020-12-24",
        "keywords": [
          "raspberry pi",
          "retro games",
          "case"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "RetroFlag GPi Case Setup"
      },
      "url": "posts/2020/12/24/gpi-case-setup.json"
    },
    {
      "content": "\nETH Oberon System 3 on VirtualBox 6.1\n=====================================\n\nBy R. S. Doiel, 2021-03-17\n\nIn this post I am walking through installing Native Oberon 2.3.7\n(aka ETH Oberon System 3) on a virtual machine running under\nVirtualBox 6.1. It is a follow up to my 2019 post \n[FreeDOS to Oberon System 3](/blog/2019/07/28/freedos-to-oberon-system-3.html \"Link to old blog post for bringing up Oberon System 3 in VirtualBox 6.0 using FreeDOS 1.2\"). To facilitate the install I will first prepare\nmy virtual machine as a FreeDOS 1.2 box. This simplifies getting the\nvirtual machines' hard disk partitioned and formatted correctly.\nWhen Native Oberon was released back in 1990's most Intel flavored\nmachines shipped with some sort Microsoft OS on them.  I believe\nthat is why the tools and instructions for Native Oberon assume\nyou're installing over or along side a DOS partition.\n\nBuilding our machine\n--------------------\n\nRequirements\n------------\n\n1. Install VirtualBox 6.1 installed on your host computer.\n2. Download and install a minimal FreeDOS 1.2 as a virtual machine\n3. Downloaded a copy of Native Oberon 2.3.7 alpha from SourceForge\n3. Familiarized yourself Oberon's Text User Interface\n4. Boot your FreeDOS virtual machine using the Oberon0.Dsk downloaded\nas part of NativeOberon_2.3.7.tar.gz\n5. Mount \"Oberon0.Dsk\" and start installing Native Oberon\n\nBefore you boot \"Oberon0.Dsk\" on your virtual machine make sure\nyou've looked at some online Oberon documentation. This is important.\nOberon is very different from macOS, Windows, Linux, DOS, CP/M or\nUnix. It is easy to read the instructions and miss important details \nlike how you use the three button mouse, particularly the selections\nand execute actions of text instructions.\n\nVirtual Machine Setup\n---------------------\n\nVirtualBox 6.1 can be obtained from [virtualbox.org](https://www.virtualbox.org/).  This involves downloading the installer for your particular host\noperating system (e.g. Linux, macOS or Windows) and follow the instructions\non the VirtualBox website to complete the installation.\n\nOnce VirtualBox is installed, launch VirtualBox.\n\nClick the \"New\" button and name your machine (e.g. \"Native Oberon 2.3.7 Alpha\") and choose type of \"Other\" and version \"DOS\". Click continue. I accepted\nthe default memory size of 32 MB. This is plenty for Oberon.  I clicked on create disk and accepted the default VDI (VirtualBox Disk Image). Press continue. I think accepted \"Dynamically allocated\", press continue. I chose a \"disk size\" of 100.00 MB. Oberon System is tiny. Press create button.\n\nMake sure your new machine is highlight on the left side of the VirtualBox\nmanagement panel. Click on Settings button, it looks like a gear towards\nthe top. Click \"Display\" on the model dialog and bump the Video Memory\nup to 128 MB. I also clicked Enable 3D Acceleration (though I don't think\nOberon uses this).  Before clicking OK click on the Network icon in the \nmodal dialog box. Change \"NAT\" to \"Bridged Adapter\". Now click \"OK\" to\nclose the modal dialog box. \n\nYour VirtualBox is now ready, before pressing \"Start\" we need\nto install FreeDOS 1.2.\n\nMake a FreeDOS 1.2 machine\n---------------------------\n\nDownload the [FD12CD.iso](https://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/distributions/1.2/FD12CD.iso) file from the \n[FreeDOS project](https://freedos.org/download).\n\n\"Insert\" the \"FD12CD.ISO\" file into our VirtualBox 6.1\nCD-ROM drive. Go to the VirtualBox management panel. \nIn the area that summarizes storage click the word \"Empty\"\nin the line with \"[Optical Drive]\". Find the \"FD12CD.ISO\"\nyou downloaded and select it.\n\nNow press the green \"Start\" arrow in the VirtualBox management\npanel. This should start your virtual machine and it will boot\nusing the CD-ROM drive.\n\nThis will display a welcome screen with installation options.\nPress your \"tab\" key once. This should cause a boot string to be\ndisplayed. Type a space and then type the word \"raw\" (without quotes).\nPress enter. Next select the language you want to install with\n(e.g. English). Choose \"Yes - Continue with installation\" on the\nnext prompt. You should then be given a dialog box that\nindicates \"Drive C: does not appear to be partitioned.\", select\n\"Yes - Partition drive C:\". Then that completes press\n\"Yes - Please reboot now\". \n\nThis will cause the machine to reboot and you will be faced with\nthe \"Welcome to FreeDOS 1.2\" screen once again. Press the \"tab\"\nAdd a space and type \"raw\" to the boot string as before.\nSelect the language again then select \"Yes - Continue with \ninstallation\". The screen should now say something like\n\"Drive C: does not appear to be formatted\", select \n\"Yes - Please erase and format drive C:\".\n\nWhen done it'll gather some info on the system and ask you\nwhich keyboard you're using. Pick yours (e.g. \"US English (Default)\").\nIt will then give you a choice of what to install. Since we're\ngoing to overwrite this when we install Oberon just select\nthe base package, then select \"Yes - Please install FreeDOS 1.2\"\n\nBefore selecting \"Yes - Please reboot now\" when the install is\nfinished you want to \"eject\" your FD12CD.ISO from the virtual\nCD-ROM drive.  Switch back to your VirtualBox management panel.\nClick the text that says \"FD12CD.iso\" and select \"remove disk\nfrom virtual drive\" in the popup menu. Switch back to your\nVirtual machine and select \"Yes - Please reboot now\"\n\nIf all goes well the machine will boot into FreeDOS 1.2. When\nyou see the \"C:>\" prompt type \"shutdown\" (without the quotes)\nand press enter. We're now ready to start installing Native\nOberon 2.3.7.\n\n\nNative Oberon 2.3.7\n-------------------\n\nNative Oberon used to be hosted at ETH where Oberon and the Oberon\nSystem was first developed as a research and instructional project.\nUnfortunately this seems to no longer be supported by ETH. Prof. Wirth\nhas long been retired now and they no longer choose to use such a \nuseful language or Operating System. \n\nSourceForge has a mirror of the original sources and some of the\nremaining community has put at a \"new\" release of 2.3.7 Alpha \nbringing Native Oberon a little closer to the present. It's this\nversion we'll use. You can read more at the [SourceForge](https://sourceforge.net/projects/nativeoberon/) as well as at the [Oberon Wikibook](https://en.wikibooks.org/wiki/Oberon). ETH also still maintains an email\nlist for Oberon and it is active. It can be found at\nhttps://lists.inf.ethz.ch/mailman/listinfo/oberon. I recommend\nbrowsing the archives of the Email list if you run into problems.\nI've found very helpful information there and the people on the\nlist seem happy to answer a novices question.\n\nWe are going to be downloading files from the Native Oberon Project's\nFiles page at SourceForge.\n\n> https://sourceforge.net/projects/nativeoberon/files/nativeoberon/\n\nIn the Files page download the instructions \n[NativeOberonInstall.pdf](https://sourceforge.net/projects/nativeoberon/files/NativeOberonInstall.pdf/download) \nor or the text version. This document by Pieter Muller (May 1999) explains\nthe installation process. It is good for its overview though I found\nthe actual process simpler than what was described for May 1999. \n\nOn the Files page you'll also see a green button to \"Download Latest Version\", NativeOberon_2.3.7.tar.gz. Click the button and download it.\n\nThe NativeOberon_2.3.7.tar.gz contains the files we'll need to run\nNativeOberon on our VirtualBox. Ungzip and untar the file into\na location that is convenient for you. I put mine\nin `src/NativeOberon-2.3.7` and I had downloaded the file into my\nhome directory's \"Downloads\" folder. \n\n```shell\n    mkdir -p src/NativeOberon-2.3.7\n    cd src/NativeObeorn-2.3.7\n    tar zxvf ~/Downloads/NativeOberon_2.3.7.tar.gz\n```\n\nYou now have the software ready to proceed in installing the system\nin VirtualBox.\n\nNativeOberon in a VirtualBox\n----------------------------\n\nGo back to your VirtualBox management panel. We need to place\nhe boot disk image in the virtual floppy drive. In the files\nwe unpacked (i.e. ungzip and untar) there is a file named\n\"Oberon0.Dsk\".  We want to mount that in the virtual floppy drive.\nClick on the word \"Empty\" next to \"Floppy Device 0:\" in the management\npanel. You are then given a modal dialog box and we want to select \n\"Choose a disk file\". You can then find the files you save and \nselect \"Oberon0.Dsk\". \n\nBooting with Oberon0.Dsk\n------------------------\n\nWe can now click \"Start\" button at the top of the VirtualBox management\npanel. This will boot the virtual machine using \"Oberon0.Dsk\". Oberon\nitself loads completely into memory. \n\nYou now have a running Oberon System but we need to install it\non the virtual hard drive. Fortunately our running system comes with\nbuilt in instructions.  It is here that people how haven't \nused Oberon before are going to run into trouble.\n\nOberon System uses all three buttons of a three button mouse. On\nmost mice I've encountered to day there are two buttons and a\nscroll wheel. The scroll wheel is click able and functions like\nthe middle button on an Oberon mouse.\n\nThe left mount button sets the pointer, the middle button (our\nscroll wheel if your mouse is like mine) is used to execute\ncommands and the right mouse button is used to select text.\nIn our installation instructions displayed on our virtual \nmachine we generally be middle clicking the blue colored text. \n\nIn Native Oberon all text is potentially actionable.  Unlike in\nUnix where you type a command press enter then have to retype\n(or use the command history) to execute the next command we're\ngoing to click on the text and sometimes select text to execute\ncommands.  Before we proceed I highly recommend readying\nand trying a tutorial out before attempting to install Oberon\non your virtual hard drive. There is an [Oberon System 3 - Main Tutorial](https://web.archive.org/web/20171226183816/http://www.ethoberon.ethz.ch/ethoberon/tutorial/) available at the Internet Archive's Wayback machine.\n\nInstalling to our Virtual Hard disk\n----------------------------------\n\nAlong the right side (in the system track) is the text \"Edit.Open Introduction.Text\". Click with your middle button (scroll wheel on my\nmouse) and this will open the text in the \"Edit\" track on the left\nside.  Read this text if you haven't before. Scrolling through\nthe text is a little different than the scroll bars on macOS, Windows,\nX Windows. They are on the left side and the middle mouse button\nsets the scroll position. The left button pages down, the right\npages up.  You can close the \"Introduction.Text\" windows by \nmiddle clicking \"System.Close\" in the upper menu bar.\n\nReview step 1.\n--------------\n\nWe need to configure the hard drive by middle clicking on\n\"Config.Desk Standard ATA/EIDE\"[^1]. In the console viewer above\nyou should see something like\n\n[^1]: This blue text makes it clear the command is actionable, like a link in the web browser. But the actual text is the command not the color.\n\n```\nDisk: Standard ATA/EIDE\nStatic BootLinker for OM Object Files / prk\n linking Native.Bin 255388\n```\n\nReview step 2.\n--------------\n\nMiddle click on \"Edit.Open InstallFiles.Tool\".  A \"Tool\" file\nis like a text file but usually contains instructions and\na sorta menu or recipe of commands.  In fact our instructions\nin the lower viewer of the system track is a \"Tool\" file called\n\"Install.Tool\".  Using \"Edit.Open\" to open the tool or text file\nopens a viewer on the left track, the edit track. If you had\nclicked on \"System.Open Install.Tool\" it would open a viewer\non the right, or systems track. In either track by default\nthe viewers will tile (not overlap).  If you want to close\na view you can click on \"System.Close\" in the viewer's menu\nbar. Now open our InstallFiles.Tool in the edit track.\n\nInstallFiles.Tool\n-----------------\n\nWe now are going to prepare our virtual hard drive. Like\nour \"Install.Tool\" text we have a series of instructions\nwhich commands we can click on (the ones in blue).\n\nMiddle click on \"Partitions.Show ~\". This will open a pain\nshowing the partition information. You should see something\nlike\n\n```\nDisk: Diskette0, GetSize: no media, removable\n\nDisk: IDE0, 99MB, VBOX HARDDISK\nIDE0#00        99MB  --- (Whole disk)\nIDE0#01        99MB  --- (Free)\n\nDisk: IDE2, GetSize: no media, removable, VBOX CD-ROM\n```\n\nThis tells us we have three drives in our VirtualBox\nvisible to Oberon.  The first is the floppy drive.\nIt shows \"no media\". That might seem odd but when you\nread the \"Oberon0.Dsk\" it read that into memory and the\nwhole OS is not running in memory, not from disk! While\nthe disk is still \"in the drive\" as far as VirtualBox\nis concerned it isn't \"mounted\" from the point of view of\nthe operating system.\n\nThe second disk section describes our virtual hard drive.\nThe third describes the virtual CD-ROM drive.\n\nWe're interested in using the disk \"IDE0\" with the\ndevice number of \"01\", we express that as \"IDE0#01\". \n\nIn the \"Partitions.Text\" viewer where we see the\npartitions information we can type the command\ndescribed in \"InstallFiles.Tool\"\n\n```\nPartitions.ChangeType IDE0#01 6 76 ~\n```\n\nWe then middle mouse click on line we just type. This\nshould produce output in the \"System.Log\" view in the\nupper right of the screen that looks like\n\n```\nIDE0#01 changed to type 76\n```\n\nI had to do a modified version of step 3 of \"InstallFiles.Tool\"\nchoosing option \"b\".\n\nIn the output of \"Partitions.show ~\" (i.e. the Partitions.Text\nviewer) want to middle click on the \"I\" of \"IDE0#01\".\nThen right mouse button select \"IDE0#01\". \n\nFrom 3a in the \"InstallFiles.Tool\" viewer middle mouse button\nclick on \"Partitions.Format ↑\". This should result in \nthe \"System.Log\" viewer showing \n\n```\nIDE0#01 format successful\n```\n\nAfter formatting the drive I was able to complete step 3b by\nmiddle clicking the commands as provided in the \"InstallFiles.Tool\"\n\n> NOTE: you may need to scroll that window to see all of step 3\n\nMiddle click on \"Partitions.UpdateBootFile ↑\" \nThe \"Systems.Log\" viewer should show\n\n```\nIDE#00 update successful\n```\n\nMiddle click on \"FilesSystem.Mount DST AosFS ↑\" in 3b. The\n\"System.Log\" viewer should show\n\n```\nDST: mounted\n```\n\nWe are ready for Step 4. This command does the brunt of the\nwork of coping things over. The command \"Configuration.DoCommands\"\ntake a list of Oberon commands and executes them one after the\nother. Middle Mouse click on \"Configuration.DoCommands\".\nThe \"System.Log\" viewer will show many messages that are\na result of each command taken. Make sure there are no errors.\nThe last series of commands renamed files so you should see\nsomething like\n\n```\nSystem.RenameFiles\nDST:Rel.Obeorn.Text => DST:Oberon.Text renaming\nDST:Rel.Network.Tool => DST:Network.Tool renaming\nDST:Rel.DOS.Tool => DST:DOS.Tool renaming\n```\n\nFor step 5 of \"InstallFiles.Tool\" we can close our \"InstallFiles.Tool\"\nviewer by middle clicking on \"System.Close\" in the menu bar. You can\nalso close the \"Partitions.Text\" viewer using its menu bar and\nmiddle clicking \"System.Close\".\n\nRight now we've formatted our hard drive and copied a bunch of \nfiles too it. We still need to configuration our system before\nit is self hosting.\n\nIn the \"Install.Tool\" viewer we want to open our \"Configure.Tool\".\nMiddle click on the \"Edit.Open Configure.Tool\".\n\nConfiguring our Oberon System\n-------------------------------\n\nThe configuration tool breaks configuration into a series of\nparts. First part is configure the display in Part two\nwe make the hard disk bootable.\n\nTo configure out display we want to middle click on the blue text in\n\"Config.DetectVesa (BIOS cal might hang some systems!)\".\nYou will be presented with a list of screen resolutions. I middle\nclicked the blue text in \"Config.Vesa 00000147H 1600 * 1200 * 32\".\nIn the \"System.Log\" viewer this showed\n\n```\nVesa mode 00000147H\n```\n\n> NOTE: You will likely need to scroll down the page using the scroll bar\n\nIn part two we need to decide how we want to boot Oberon. In our case\nI recommend Option 2, boot Oberon directly (non-FAT hosted). Middle\nclick the blue text \"Config.BootParition menu ~\".\nThe \"System.Log\" viewer should output\n\n```\nIDE0#01 config written\n```\n\nMiddle click the blue text \"Partitions.Show ~\". Like in \n\"InstallFiles.Tool\" this will open a new \"Partitions.Text\" \nviewer with content like\n\n```\nDisk: Diskette0, GetSize: no media, removable\n\nDisk: IDE0, 99MB, VBOX HARDDISK\nIDE0#00       99MB  --- (Whole disk)\nIDE0#01       99MB   76 * Native Oberon, Aos\n\nDisk: IDE2, GetSize: no media, removable, VBOX CD-ROM\n```\n\nUsing your right mouse button select \"IDE0#01\" then in the\n\"Configure.Tool\" viewer middle click the blue text\n\"Partitions.Activate ↑\". The \"System.Log\" viewer should\nshow\n\n```\nIDE0#01 already active\n```\n\nWe don't have a partition to deactivate so we can skip the last\nstep of option 2. This is a good place to \"eject\" our \nfloppy disk \"Oberon0.Dsk\" before we \"System.Reboot\".\n\nTo eject the disk click on \"Oberon0.Dsk\" in the VirtualBox\nmanager panel. The should then change the text to \"Empty\".\n\nFinally we're ready to move to the last step in \"Configure.Tool\".\nScroll down and find \"System.Reboot\". \nMiddle click on the blue text \"System.Reboot\". At this point\nthe virtualbox should reboot from the virtual hard drive.\nThis reboot will take a little longer than the floppy boot\nand the screen size of the virtualbox will be large based on the\nsettings you picked early. You have a minimal working Oberon\nSystem 3. Now to install some more programs and flesh the system out.\n\nInstall some programs\n---------------------\n\nFirst we need to get the zip files provided in \nNativeOberon_2.3.7.tar.gz on to the hard drive.  \nHistorically these were done via 1.44 MB floppy disks.\nWe're going to make it easier. Native Oberon 2.3.7 can\nread an ISO formatted CD-ROM. \n\nMaking our virtual CD-ROM\n-------------------------\n\nUnder Ubuntu 20.04.2 LTS machine creating a ISO image\nis one command. Below is I am going to create an ISO \nimage of the directory \"NativeOberon-2.3.7\"\nand save the image as \"NativeOberon-2.3.7.iso\".\n\n```shell\n    mkisofs -J --iso-level 3 \\\n        -o NativeOberon-2.3.7.iso NativeOberon-2.3.7\n```\n\nThe `-J` says to use the Joliet extensions, the `--iso-level`\nsets the level of ISO support, in this case to 3. See\nthe manpage for `mkisofs` for details.\n\nOn macOS this involves two commands. First use\nthe \"Disk Utility\" to create an image of the folder\nwhere you unpacked NativeOberon_2.3.7.tar.gz.\nThis will result in a \".dmg\" or disk image file common\non macOS.  Next we need to convert this to an ISO\nformatted image file.  For that we use a command line\nmacOS tool called `hdiutil` to convert the disk\nimage to an ISO format. In the process you will create\nthe ISO file but it will have the extension of \".cdr\".\nYou can rename (i.e. mv) that file so it has a \".iso\"\nextension. This is suitable to mount in VirtualBox's \nvirtual CD-ROM drive.\n\n```shell\n    hdiutil convert NativeOberon-2.3.7.dmg -format UDTO -o NativeOberon-2.3.7.iso\n    mv NativeOberon-2.3.7.iso.cdr NativeOberon-2.3.7.iso\n```\n\nGo to the VirtualBox 6.1 management panel and mount the\nISO image file you created. Now we're ready to return\nto our Native Oberon virtual machine.\n\nInstalling from an ISO CD-ROM\n-----------------------------\n\nI suggest create the following as it's own tool text.\nBut if you want you can also type in the commands and\nexecute one by one.\n\n```\nThese are the instructions from installing the Native\nOberon 2.3.7 zip archive files. Steps:\n\n1. See what the CD-ROM mount point by reviewing the partitions\n\n    Paritions.Show ~\n\nOn my virtual machine the second disk is IDE2 and that\nis where we'll find the CD-ROM.\n\n2. Mount the ISO image as CD\n\n    FileSystem.Mount CD ISOFS IDE2 ~\n\n3. Check to see what files are on the CD-ROM\n\n    System.Directory CD:* ~\n\n4. Copy the files from the CD-ROM to the harddisk\n\n    System.CopyFiles\n        CD:Apps1.zip => Apps1.zip\n        CD:Apps2.zip => Apps2.zip\n        CD:Docu.zip => Docu.zip\n        CD:Gadgets.zip => Gadgets.zip\n        CD:Pr3Fonts.zip => Pr3Fonts.zip\n        CD:Source1.zip => Source1.zip\n        CD:Source2.zip => Source2.zip\n        CD:Source3.zip => Source3.zip\n        ~\n\n5. Unzip all our archives using the ZipTool.\n\n    ZipTool.ExtractAll \\o \\p SYS:\n        Gadgets.zip Docu.zip Apps1.zip Apps2.zip\n        Pr3Fonts.zip Pr6Fonts.zip\n        Source1.zip Source2.zip Source3.zip\n        ~\n\n```\n\nYou should now have a full installed Native Oberon 2.3.7\nsystem running under VirtualBox 6.1. Enjoy your explorations.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-03-17",
        "keywords": [
          "FreeDOS 1.2",
          "VirtualBox 6.1",
          "Oberon System 3",
          "Native Oberon"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "ETH Oberon System 3 on VirtualBox 6.1"
      },
      "url": "posts/2021/03/17/NativeOberon-VirtualBox.json"
    },
    {
      "content": "\n\nA2 Oberon on VirtualBox 6.1\n===========================\n\nBy R. S. Doiel, 2021-04-02\n\nThis is a short article documenting how I install A2 Oberon\nin VirtualBox using the [FreeDOS 1.2](https://freedos.org),\nthe A2 [ISO](https://sourceforge.net/projects/a2oberon/files/) cd image and [VirtualBox 6.1](https://virtualbox.org).\n\nBasic Approach\n--------------\n\n1. Download the ISO images for FreeDOS and A2\n2. Create a new Virtual Machine\n3. Install FreeDOS 1.2 (Base install) in the virtual machine\n4. Install A2 from the ISO image over the FreeDOS installation\n\nFrom working with Native Oberon 2.3.7 I've found it very helpful\nto have a FreeDOS 1.2. installed in the Virtual machine first. \nI suspect the reason I have had better luck taking this approach\nis based on assumptions about the virtual hard disk being setup\nwith an existing known formatted, boot-able partition. In essence\nmaking our Virtualbox look like a fresh out of the box vintage PC.\n\nDownload the ISO Images for FreeDOS and A2\n------------------------------------------\n\nYou'll find FreeDOS 1.2 installation ISO image at \n[FreeDos.org](http://freedos.org/download/). Download it\nwhere you can easily find it from the VirtualBox manager.\n\nYou'll find the A2 Oberon ISO image at [SourceForge](https://sourceforge.net/projects/a2oberon/files/) in the A2 Files section. There is a green download\nbutton you can click and it'll take you to a downloads page and download\nthe ISO.  Once again move it to where you can find it from \nthe VirtualBox manager easily.\n\n\nCreate a new Virtual Machine\n----------------------------\n\nFire up VirtualBox.  Click the \"New\" icon. Given your machine\na descriptive name and set the Type to \"Other\" and version to \"DOS\".\nClick Next.\n\nOn the Memory Size panel select the memory size you want. I picked\n2048 MB. A2 like other Oberon are frugal in resource consumption.\nClick Next.\n\nOn the Hard Disk panel I accepted the default \"Create a virtual hard disk now\"\nand clicked \"Create\" button at the bottom of the panel.\n\nI accepted the default \"VDI (VirtualBox Disk Image)\" and clicked\nNext.\n\nI accepted \"Dynamically allocated\" and clicked Next.\n\nI accepted the default name and 500 MB disk size and clicked\nCreate.\n\nThis returned me to the main VirtualBox manager panel. I click on \nthe \"Settings\" icon. This opens the Settings panel. I Clicked on the\n\"Display\" label in the left side of the panel. On the \"Screen\" tab\nI increased the Video Memory from 6 MB to 128 MB.  I also checked\nthe \"Enable 3D Acceleration\" box.\n\nNext I clicked  \"Network\" label in the left side of the panel.\nI changed the Attached to from \"NAT\" to \"Bridged Adapter\"\nbefore clicking \"OK\". This should return you to the manager panel.\n\nScroll down the description of your virtual machine so that the\n\"Storage\" section is visible. You should see \"IDE Secondary Device 0: \n[Optical Drive] Empty\". Click the the words \"Optical Drive\".\nYou be given a context menu, click on \"Choose a Disk file\". Navigate\nto where you saved the FressDOS ISO (e.g. FD12CD.iso).\nClick Open. This should return you to the manager panel and you\nshould see the \"FD12CD.iso\" file listed.\n\nInstall FreeDOS 1.2\n-------------------\n\nClick the \"Start\" button.  This should boot the machine. By\ndefault the search order for booting is floppy drive,\nCD-ROM drive then hard disk.  Since we have the FD12CD.iso\nmounted in the cd ROM drive it'll boot using it.\n\nWhen you see the \"Welcome\" screen press the tab key.\nYou should see a line describing the image it'll boot.  Click\ninto the Virtual machine's window and press the space bar\nthen type \"raw\" (without the quotes). Press the enter key.\n\nThis should return you to the install process, select your\nlanguage (e.g. English for me). The select \"Yes - Continue with the\ninstallations\". On the next screen select \"Yes - Partition drive C:\".\nThen select \"Yes - Please reboot now\". This will reboot the\nmachine and bring you back to the Welcome page. Once again\npress the tab key, press the space bar and type in \"raw\"\n(without the quotes).\n\nAs before select your language and select \"Yes - Continue with\nthe installation\". This time you should see the option \n\"Yes - Please erase and format drive C:\", select it. \nAfter formatting it ask you to select your keyboard type.\nIt will then give you the option of installing base or full\ninstallations (with our without source).  I suggest only\nselecting \"Base packages only\".  \n\nOn the next screen select \"Yes - Please install FreeDOS 1.2\".\nAfter it finishes you can select \"Yes - Please reboot now\".\nWhen the machine reboots you'll see the welcome screen again\nbut rather than press tab, select \"Boot system from hard disk\".\nPress enter to select the extended memory manager and you\nshould now be at the DOS \"C:>\" prompt.\n\nSwitch back to the VirtualBox manager panel and click on\n\"Optical Drive\" and click \"Remove disk from virtual drive\".\n\nInstalling A2 Oberon\n--------------------\n\nWe now should have a Virtual Machine ready to receive A2.\nClick the \"Optical Drive\" again and select the A2 ISO\nimage you downloaded from SourceForge previously.\nYour optical drive should show the full filename of\nthe ISO image, e.g. \"A2_Rev-6498_serial-trace.iso\"\nWe can now click the \"Start\" icon in the manager panel.\n\nA2 comes up running like a \"live CD\".  It's the full A2\nso you can play around with it if you want but we're going\nto install it on our virtual hard drive. At the bottom of the\nA2 desktop you should see a panel of buttons. Click the button\nlabeled \"System\". This will change the panel buttons below it.\nIn the lower panel you should see \"Installer\", click it. This\nwill bring up a \"Welcome to Oberon\" installer window. You will\nsee two presentations of drives. The upper one will be the hard\ndrive where we want to install A2 and the lower one is the \nvirtual CD ROM we're running. Click on the bar for the hard disk.\nBefore click the drive bar was red. After clicking it was yellow.\nThe text label above the var says, \"IDE0 (VBOX HARD DISK), Size \n500 MB, Open count 0\".\n\nIn the lower part of the panel click \"Quickinstall\", then\nanswer Yes to the model dialog that pops up. After a few moments \nA2 should finish installing itself on the virtual hard disk.  The lower\npanel's buttons will include one labeled \"Done\", press it. This\nwill close the installer window.\n\nAt the bottom of the desktop you should still see the System\npanel buttons. There is a red one labeled \"Shutdown\". Press it.\n\nThe virtual machine's screen should go black. On my machine\nI press the right control key (the host key) to release my\nmouse and keyboard from the virtual machine. Close the window\nand when it select \"Power of the machine\" in when VirtualBox\nprompts how to shut it down.\n\nLike with the FD12CD.iso we want to unmount our A2 installation\nCD ROM. Click on the \"Optical Drive\" in the manager panel\nand choose \"Remove disk from virtual Drive\". \n\nYou can now start the machine again and start exploring A2.\nI recommend looking at the [Oberon Wikibook](https://en.wikibooks.org/wiki/Oberon#A2_and_UnixAOS)\n for details about how to use A2 and ideas of what to explore.\n\nOne nice feature of A2 is it includes a full \"NativeOberon\"\nor ETH Oberon as an A2 Application.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-04-02",
        "keywords": [
          "FreeDOS 1.2",
          "VirtualBox 6.1",
          "A2 Oberon"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "A2 Oberon on VirtualBox 6.1"
      },
      "url": "posts/2021/04/02/A2-Oberon-on-VirtualBox-6.1.json"
    },
    {
      "content": "\nUpdating Schema in SQLite3\n==========================\n\nBy R. S. Doiel, 2020-04-16\n\n[SQLite3](https://sqlite.org/docs.html) is a handy little\ndatabase as single file tool.  You can interact with the file\nthrough largely standard SQL commands and embed it easily into\napplications via the C libraries that the project supports.\nIt is also available from various popular scripting languages\nlike Python, PHP, and Lua. One of the things I occasionally\nneed to do and always seems to forget it how to is modify a\ntable schema where I need to remove a column[^1]. So here are\nsome of the basics do I can quickly find them later and avoid\nreading various articles tutorials because the search engines\ndoesn't return the page in the SQLite documentation.\n\n[^1]: The SQL `ALTER TABLE table_name DROP COLUMN column_name` does not work in SQLite3\n\nIn the next sections I'll be modeling a simple person object\nwith a id, uname, display_name, role and updated fields.\n\nCreating a person table\n-----------------------\n\n\n```sql\n\nCREATE TABLE IF NOT EXISTS \"person\" \n        (\"id\" INTEGER NOT NULL PRIMARY KEY, \n        \"uname\" VARCHAR(255) NOT NULL, \n        \"role\" VARCHAR(255) NOT NULL, \n        \"display_name\" VARCHAR(255) NOT NULL, \n        \"updated\" INTEGER NOT NULL);\n\n```\n\nAdding a column\n---------------\n\nWe will create a *junk* column which we will remove later.\n\n```sql\n\n.schema person\nALTER TABLE person ADD COLUMN junk VARCHAR(255) NOT NULL;\n.schema person\n\n```\n\nDropping a column\n-----------------\n\nTo drop a column in SQLite you need to actually create\na new table, migrate the data into it then drop the old table\nand finally rename it. It is best to wrap this in a transaction.\n\n```sql\n\nBEGIN TRANSACTION;\n    CREATE TABLE IF NOT EXISTS \"person_new\" \n           (\"id\" INTEGER NOT NULL PRIMARY KEY, \n           \"uname\" VARCHAR(255) NOT NULL, \n           \"role\" VARCHAR(255) NOT NULL, \n           \"display_name\" VARCHAR(255) NOT NULL, \n           \"updated\" INTEGER NOT NULL);\n    INSERT INTO person_new\n           SELECT id, uname, role, display_name, updated\n           FROM person;\n    DROP TABLE person;\n    ALTER TABLE person_new RENAME TO person;\nCOMMIT;\n\n```\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-04-16",
        "keywords": [
          "SQLite",
          "SQL",
          "database"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 1,
        "series": "SQL Reflections",
        "title": "Updating Schema in SQLite3"
      },
      "url": "posts/2021/04/16/Updating-Schema-in-SQLite3.json"
    },
    {
      "content": "\nOfront on Raspberry Pi OS\n=========================\n\nBy R. S. Doiel, 2021-04-25\n\nThis post is about getting Ofront[^1] up and running on Raspberry Pi OS[^2].\nOfront provides a Oberon-2 to C transpiler as well as a Oberon V4[^3]\ndevelopment environment. There are additional clever tools like `ocat`\nthat are helpful working with the differences in text file formats between\nOberon System 3, V4 and POSIX. The V4 implementation sits nicely on top of\nPOSIX with minimal compromises that distract from the Oberon experience.\n\n[^1]: Ofront was developed by Joseph Templ, see http://www.software-templ.com/ \n\n[^2]: see https://www.raspberrypi.org/software/ (a 32 bit Debian based Linux for both i386 and ARM)\n\n[^3]: see https://ssw.jku.at/Research/Projects/Oberon.html\n\n\nAn Initial Impression\n---------------------\n\nI first heard of running Ofront/V4 via the ETH Oberon Mail list[^4].\nWhat caught my eye is the reference to running on Raspberry Pi. Prof. Templ \nprovides two flavors of Ofront. One targets the Raspberry Pi OS on ARM\nhardware the second Linux on i386. The Raspberry Pi OS for Intel is an\ni386 variant. I downloaded the tar file, unpacked it and immediately ran\nthe \"oberon.bash\" script provided eager to see a V4 environment. It\nrenders but the fonts rendered terribly slowly. I should have read the\ndocumentation first!  Prof. Templ provides man pages for the tools that\ncome with Ofront including the oberon application. Reading the\nman page for oberon quickly addresses the point of slow font rendering.\nIt also discusses how to convert Oberon fonts to X Windows bitmap fonts.\nIf you use the X Window fonts the V4 environment is very snappy. It does\nrequire that X Windows knows where to find the fonts used in V4. That is\ndone by appending the V4 converted fonts to the X Window font map. I had\ninstalled the Ofront system in my home directory so the command was\n\n```bash\nxset +fp $HOME/ofront_1.4/fonts\n```\n\nRunning \"oberon.bash\" after that immediately improved things. Since I didn't\nneed the Oberon fonts outside of V4 I added the `xset` command to the\n\"oberon.bash\" script just before it invokes the `oberon` command.\n\n[^4]: See Hans Klaver's message: http://lists.inf.ethz.ch/pipermail/oberon/2021/015514.html \n\n\nGoals in my setup\n-----------------\n\nI had three goals in wanting to play with Ofront and running the V4\nOberon.\n\n1. I wanted to work in an Oberon System environment\n2. I need a system meets my vision requirements (e.g. larger font size)\n3. I wanted to understand the Linz/V4 variation in Oberon's evolution\n\nOfront address all three once you get the X Window side setup correctly.\n\nSetting up Ofront and V4\n------------------------\n\nFirst we need to boot up a Raspberry Pi OS device (or an i386 Linux with X11).\nWe need to retrieve the software from Joseph Templ's [software-templ.com](https://software-templ.com).\nTwo 1.4 versions are available precompiled. The first is for ARM running\nRaspberry Pi OS and the second is for generic Linux i386 with X11. I initially\ntested this on an old laptop where running the i386 version of Raspberry Pi OS. \n\nWhat we need\n------------\n\nThe following software is usually already installed on your \nRaspberry Pi OS.\n\n+ curl to download the files[^5]\n+ gunzip to uncompressed the archive file\n+ tar to unpack the archive file\n\n[^5]: If not try `sudo apt install curl` from the command line\n\nWhat we do\n----------\n\n1. Download the appropriate tar file\n    a. ARM: http://www.software-templ.com/shareware/ofront-1.4_raspbian-Pi3.tar.gz\n    b. Intel i386: http://www.software-templ.com/shareware/ofront-1.4_linux-386-3.2.tar.gz\n2. Make sure we can read the compressed archive file\n3. Gunzip and untar the file\n\nHere's the commands I used for the Raspberry Pi hardware.\n\n```bash\n    curl -O http://www.software-templ.com/shareware/ofront-1.4_raspbian-Pi3.tar.gz\n    tar ztvf ofront-1.4_raspbian-Pi3.tar.gz\n    tar zxvf ofront-1.4_raspbian-Pi3.tar.gz\n```\n\nHere's the commands I used for Raspberry Pi OS on Intel\n\n```bash\n    curl -O http://www.software-templ.com/shareware/ofront-1.4_linux-386-3.2.tar.gz\n    tar ztvf ofront-1.4_linux-386-3.2.tar.gz\n    tar zxvf ofront-1.4_linux-386-3.2.tar.gz\n```\n\nAt this point there should be an `ofront_1.4` directory\nwhere you gunziped and untared the archive file. At this point\nyou can test to make sure everything runs by doing the following\n(remember the font rendering with be very slow).\n\n```\n    cd ofront_1.4\n    ./oberon.bash\n```\n\nYou can exit the V4 environment by closing the window or typing\n`System.Quit ~` in an Oberon viewer and middle clicking with your\nmouse[^6].\n\n[^6]: Oberon Systems expect a three button mouse, with a two button mouse you hold the alt key and press the left button. Note that command in Oberon are case sensitive.\n\nThe reason the system is so slow is that X is having to write bitmaps\na pixel at a time in the window holding our Oberon System. What we\nwant X to do is render an X Window font.  Joseph as provided us with\nthe Oberon fonts already converted for X! We just need to let the\nX Window system know where to look.\n\nWhat we need\n------------\n\n+ an editor for editing `oberon.bash`\n\nWhat we'll do\n-------------\n\n1. Exit the running Oberon System using `System.Quit ~` or just close the window\n2. Edit `oberon.bash` to speed up font rendering\n3. Try `oberon.bash` again and see the speed bump\n\nWith your favorite editor add the `xset` line before the `oberon`\ncommand is invoked. My \"oberon.bash\" looks like this.\n\n```\n#!/bin/bash\n\nif [ -z \"$OFRONT_HOME\" ]; then\n  export OFRONT_HOME=.\n  echo \"OFRONT_HOME set to .\"\nfi\nexport OBERON=.:$OFRONT_HOME/V4_ofront:$OFRONT_HOME/V4:$OFRONT_HOME/fonts\nexport LD_LIBRARY_PATH=.:$OFRONT_HOME/lib\nexport PATH=.:$OFRONT_HOME/bin:$PATH\nxset +fp $HOME/ofront_1.4/fonts\n$OFRONT_HOME/bin/oberon -f ./V4/Big.Map -u 8000 -c $* &\n```\n\nThe `xset` command adds the provided X fonts to X Window. This\nresults in a huge speedup of rendering. I also add the options\nfor using the largest font sizes via a font map file, \"V4/Big.Map\"\nand set the display units to 8000. Your vision or monitor may\nnot need this so you want to only add the line to include the\nX fonts needed by Oberon.\n\nNow re-launch Oberon using the updated \"oberon.bash\" and\nsee the improvement.\n\n```\n    vi oberon.bash\n    ./oberon.bash\n```\n\nYou now have a functioning V4 Oberon System to play with and\nexplore.\n\nThere are some additional POSIX environment setup you can\nadd to improve the integration with your Linux setup. These\nare covered in the man pages for the tools that come with Ofront.\nAdditional information is also provided in the Oberon Texts\nand Tools files in the V4 environment. All are worth reading.\n\n\nWhat does this setup provide?\n-----------------------------\n\nAt the point we have V4 available we have a rich development\nand text environment. One which I feel is conducive to both\nwriting in general and programming specifically. You are running\nunder an adapted Oberon System so there are somethings to consider.\n\nThe Oberon V4 file system does support punctuation characters aside\nfrom periods and slashes.  So when I tried to edit a file with hyphens\nin the name Oberon assumed the filename stopped at the first hyphens.\nThe Oberon file systems are typically case sensitive so this can\nbe worked around with letter case. Of course I could modify the V4\nsystem to allow for more letters too. That's the nice thing about\nhaving the source code.\n\nThe second issue if file format.  In Oberon we can embed fonts\nand coloring and that is treated as normal text. End of line\ncharacters are represented as a carriage return. In POSIX environments\nwe have \"plain text\" without specific font directives and we use\na line feed to terminate lines. Fortunately Prof. Templ provided\na program called `ocat`[^7] that makes short work of converting an\nOberon text into a POSIX friendly format. On the Oberon side of things\nit's also easy because Oberon will treat an ASCII file as a text we\nonly need to convert the line endings and in the Ofront implementation\nof V4 it handles the differences in line endings behind the scenes.\n\nIf you create or store a file in the Oberon environment it'll become\nOberon text. If you need to have a plain text version use `ocat`.\nIf you only read POSIX files in the Oberon environment then they remain\nplain text files but V4 takes care of translating the POSIX line ending\nto ones that are displayed nicely in Oberon.\n\n\n[^7]: In the `ofront_1.4` directory run `man man1/ocat.1` to find out more\n\nWhat to explore next?\n---------------------\n\nNow that we have a fast running V4 system we have some choices\nfor development. Joseph Templ has adapted the display for X\nand also the file system so the files are visible from the Unix\nshell.  This is a powerful arrangement. This supports both Oberon\ndevelopment and the use of Oberon language for the development of\nPOSIX friendly programs.  The Ofront collection provides the\n`ofront` an Oberon-2 to C translator, `ocl` is a tool that will\ncombine `ofront` with your C compiler and linker to produce\nprograms and libraries for Linux. There is also `ocat` for\nconverting Oberon texts to POSIX plain text and `showdef` for\nshowing module definitions.  Finally Ofront provides the\n`oberon` command so we have an Oberon System available as a\ndevelopment environment.\n\nOne thing I recommend exploring is Jospeh Templ's GitHub repository.\nThe makefile provided with the GitHub version assuming an existing\ninstallation of ofront. Since we have one we can compile our own copy\nfrom scratch. If you're running i386 you'll want to look at\n`V4_ofront/linix386` for Pi hardware take a look at `V4_ofront/raspbian`.\n\nHere's how I generated a new version on my Pi hardware.\n\n```\n    git clone https://github.com/jtempl/ofront\n    cd ofront/V4_ofront/raspbian\n    make\n    ./oberon.bash\n```\n\nThere is a note in the README of that directory about finding\n`libX11.so` but I did not need the symbolic link suggested. Since the\nfont path was previously adjusted for the original version I downloaded\nfrom Templ's website I didn't need to add the fonts again. If I fork\nTempl's version or GitHub I will probably update the \"oberon.bash\"\nfile included to check to see if the X fonts are available and if not\nadd them via `xset`. That's on a someday maybe list, for now I am\ncontent exploring the system as is.\n\n\nSomeday, Maybe\n--------------\n\nThings that come to mind after initial exploration include--\n\n- Figure out how to make Atkinson-Hyperlegible[^8] available to V4\n- Replace the X11 integration with SDL 2 integration and run under macOS or Windows\n- Exploring porting V4 to run natively Raspberry Pi via Clang cross compilers\n\nNot sure I'll get the time or have the energy to do these things but\nthey are certainly seem feasible with Ofront as it stands now.\n\n[^8]: See https://brailleinstitute.org/freefont\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-04-25",
        "keywords": [
          "Oberon",
          "Raspberry Pi OS",
          "Ofront",
          "Mostly Oberon",
          "V4",
          "Linz"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Ofront on Raspberry Pi OS"
      },
      "url": "posts/2021/04/25/Ofront-on-Rasberry-Pi-OS.json"
    },
    {
      "content": "\nBeyond Oakwood, Modules and Aliases\n===================================\n\nBy R. S. Doiel, 2021-05-16\n\nOakwood is the name used to refer to an early Oberon language\nstandardization effort in the late 20th century.  It's the name\nof a hotel where compiler developers and the creators of Oberon\nand the Oberon System met to discuss compatibility. The lasting\ninfluence on the 21st century Oberon-07 language can be seen\nin the standard set of modules shipped with POSIX based Oberon-07\ncompilers like\n[OBNC](https://miasap.se/obnc/), [Vishap Oberon Compiler](https://github.com/vishaps/voc) and the \n[Oxford Oberon Compiler](http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler).\n\nThe Oakwood guidelines described a minimum expectation for\na standard set of modules to be shipped with compilers.\nThe modules themselves are minimalist in implementation.\nMinimalism can assist in easing the learning curve\nand encouraging a deeper understanding of how things work.\n\nThe Oberon-07 language is smaller than the original Oberon language\nand the many dialects that followed.  I think of Oberon-07 as the\ndistillation of all previous innovation.  It embodies the\nspirit of \"Simple but not simpler than necessary\". Minimalism is\na fit description of the adaptions of the Oakwood modules for \nOberon-07 in the POSIX environment.\n\n\nWhen simple is too simple\n-------------------------\n\nSometimes I want more than the minimalist module.  A good example\nis standard [Strings](https://miasap.se/obnc/obncdoc/basic/Strings.def.html)\nmodule.  Thankfully you can augment the standard modules with your own.\nIf you are creative you can even create a drop in replacement.\nThis is what I wound up doing with my \"Chars\" module.\n\nIn the spirit of \"Simple but no simpler\" I originally kept Chars \nvery minimal. I only implemented what I missed most from Strings.\nI got down to a handful of functions for testing characters,\ntesting prefixes and suffixes as well as trim procedures. It was\nall I included in `Chars` was until recently.\n\nOver the last couple of weeks I have been reviewing my own Oberon-07\ncode in my personal projects.  I came to understand that\nin my quest for minimalism I had fallen for \"too simple\".\nThis was evidenced by two observations.  Everywhere I had used\nthe `Strings` module I also included `Chars`. It was boiler plate.\nThe IMPORT sequence was invariably a form of --\n\n~~~\n    IMPORT Strings, Chars, ....\n~~~\n\nOn top of that I found it distracting to see `Chars.*` and `Strings.*`\ncomingled and operating on the same data. If felt sub optimal. It\nfelt baroque. That got me thinking.\n\n> What if Chars included the functionality of Strings?\n\nI see two advantages to merging Chars and Strings. First I\nonly need to include one module instead of two. The second\nis my code becomes more readable. I think that is because\nexpanding Strings to include new procedures and constants allows\nfor both the familiar and for evolution. The problem is renaming\n`Chars.Mod` to `Strings.Mod` implies I'm supplying the standard\n`Strings` module. Fortunately Oberon provides a mechanism for\nsolving this problem. The solution Oberon provides is to allow\nmodule names to be aliased.  Look at my new import statement.\n\n~~~\n    IMPORT Strings := Chars, ...\n~~~\n\nIt is still minimal but at the same time shows `Chars` is going\nto be referenced as `Strings`. By implication `Chars` provides\nthe functionality `Strings` but is not the same as `Strings`.\nMy code reads nicely.  I don't loose the provenance of what\nis being referred to by `Strings` because it is clearly \nprovided in the IMPORT statement.\n\nIn my new [implementation](Chars.Mod) I support all the standard\nprocedures you'd find in an Oakwood compliant `Strings`.  I've\nincluded additional additional constants and functional procedures\nlike `StartsWith()` and `EndsWith()` and a complement of trim\nprocedures like `TrimLeft()`, `TrimRight()`, `Trim()`.\n`TrimPrefix()`, and `TrimSuffix()`.\n\nHere's how `Chars` definition stacks up as rendered by the\nobncdoc tool.\n\n```\n(* Chars.Mod - A module for working with CHAR and \n   ARRAY OF CHAR data types.\n\nCopyright (C) 2020, 2021 R. S. Doiel <rsdoiel@gmail.com>\nThis Source Code Form is subject to the terms of the\nMozilla PublicLicense, v. 2.0. If a copy of the MPL was\nnot distributed with thisfile, You can obtain one at\nhttp://mozilla.org/MPL/2.0/. *)\nDEFINITION Chars;\n\n(*\nChars.Mod provides a modern set of procedures for working\nwith CHAR and ARRAY OF CHAR. It is a drop in replacement\nfor the Oakwood definition \nStrings module.\n\nExample:\n\n    IMPORT Strings := Chars;\n\nYou now have a Strings compatible Chars module plus all the Chars\nextra accessible through the module alias of Strings. *)\n\nCONST\n  (* MAXSTR is exported so we can use a common\n     max string size easily *)\n  MAXSTR = 1024;\n  (* Character constants *)\n  EOT = 0X;\n  TAB = 9X;\n  LF  = 10X;\n  FF  = 11X;\n  CR  = 13X;\n  SPACE = \" \";\n  DASH  = \"-\";\n  LODASH = \"_\";\n  CARET = \"^\";\n  TILDE = \"~\";\n  QUOTE = 34X;\n\n  (* Constants commonly used characters to quote things.  *)\n  QUOT   = 34X;\n  AMP    = \"&\";\n  APOS   = \"'\";\n  LPAR   = \")\";\n  RPAR   = \"(\";\n  AST    = \"*\";\n  LT     = \"<\";\n  EQUALS = \"=\";\n  GT     = \">\";\n  LBRACK = \"[\";\n  RBRACK = \"]\";\n  LBRACE = \"}\";\n  RBRACE = \"{\";\n\nVAR\n  (* common cutsets, ideally these would be constants *)\n  spaces : ARRAY 6 OF CHAR;\n  punctuation : ARRAY 33 OF CHAR;\n\n(* InRange -- given a character to check and an inclusive range of\n    characters in the ASCII character set. Compare the ordinal values\n    for inclusively. Return TRUE if in range FALSE otherwise. *)\nPROCEDURE InRange(c, lower, upper : CHAR) : BOOLEAN;\n\n(* InCharList checks if character c is in list of chars *)\nPROCEDURE InCharList(c : CHAR; list : ARRAY OF CHAR) : BOOLEAN;\n\n(* IsUpper return true if the character is an upper case letter *)\nPROCEDURE IsUpper(c : CHAR) : BOOLEAN;\n\n(* IsLower return true if the character is a lower case letter *)\nPROCEDURE IsLower(c : CHAR) : BOOLEAN;\n\n(* IsDigit return true if the character in the range of \"0\" to \"9\" *)\nPROCEDURE IsDigit(c : CHAR) : BOOLEAN;\n\n(* IsAlpha return true is character is either upper or lower case letter *)\nPROCEDURE IsAlpha(c : CHAR) : BOOLEAN;\n\n(* IsAlphaNum return true is IsAlpha or IsDigit *)\nPROCEDURE IsAlphaNum (c : CHAR) : BOOLEAN;\n\n(* IsSpace returns TRUE if the char is a space, tab, carriage return or line feed *)\nPROCEDURE IsSpace(c : CHAR) : BOOLEAN;\n\n(* IsPunctuation returns TRUE if the char is a non-alpha non-numeral *)\nPROCEDURE IsPunctuation(c : CHAR) : BOOLEAN;\n\n(* Length returns the length of an ARRAY OF CHAR from zero to first\n    0X encountered. [Oakwood compatible] *)\nPROCEDURE Length(source : ARRAY OF CHAR) : INTEGER;\n\n(* Insert inserts a source ARRAY OF CHAR into a destination \n    ARRAY OF CHAR maintaining a trailing 0X and truncating if\n    necessary [Oakwood compatible] *)\nPROCEDURE Insert(source : ARRAY OF CHAR; pos : INTEGER; VAR dest : ARRAY OF CHAR);\n\n(* AppendChar - this copies the char and appends it to\n    the destination. Returns FALSE if append fails. *)\nPROCEDURE AppendChar(c : CHAR; VAR dest : ARRAY OF CHAR) : BOOLEAN;\n\n(* Append - copy the contents of source ARRAY OF CHAR to end of\n    dest ARRAY OF CHAR. [Oakwood complatible] *)\nPROCEDURE Append(source : ARRAY OF CHAR; VAR dest : ARRAY OF CHAR);\n\n(* Delete removes n number of characters starting at pos in an\n    ARRAY OF CHAR. [Oakwood complatible] *)\nPROCEDURE Delete(VAR source : ARRAY OF CHAR; pos, n : INTEGER);\n\n(* Replace replaces the characters starting at pos with the\n    source ARRAY OF CHAR overwriting the characters in dest\n    ARRAY OF CHAR. Replace will enforce a terminating 0X as\n    needed. [Oakwood compatible] *)\nPROCEDURE Replace(source : ARRAY OF CHAR; pos : INTEGER; VAR dest : ARRAY OF CHAR);\n\n(* Extract copies out a substring from an ARRAY OF CHAR into a dest\n    ARRAY OF CHAR starting at pos and for n characters\n    [Oakwood compatible] *)\nPROCEDURE Extract(source : ARRAY OF CHAR; pos, n : INTEGER; VAR dest : ARRAY OF CHAR);\n\n(* Pos returns the position of the first occurrence of a pattern\n    ARRAY OF CHAR starting at pos in a source ARRAY OF CHAR. If\n    pattern is not found then it returns -1 *)\nPROCEDURE Pos(pattern, source : ARRAY OF CHAR; pos : INTEGER) : INTEGER;\n\n(* Cap replaces each lower case letter within source by an uppercase one *)\nPROCEDURE Cap(VAR source : ARRAY OF CHAR);\n\n(* Equal - compares two ARRAY OF CHAR and returns TRUE\n    if the characters match up to the end of string,\n    FALSE otherwise. *)\nPROCEDURE Equal(a : ARRAY OF CHAR; b : ARRAY OF CHAR) : BOOLEAN;\n\n(* StartsWith - check to see of a prefix starts an ARRAY OF CHAR *)\nPROCEDURE StartsWith(prefix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR) : BOOLEAN;\n\n(* EndsWith - check to see of a prefix starts an ARRAY OF CHAR *)\nPROCEDURE EndsWith(suffix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR) : BOOLEAN;\n\n(* Clear - resets all cells of an ARRAY OF CHAR to 0X *)\nPROCEDURE Clear(VAR a : ARRAY OF CHAR);\n\n(* Shift returns the first character of an ARRAY OF CHAR and shifts the\n    remaining elements left appending an extra 0X if necessary *)\nPROCEDURE Shift(VAR source : ARRAY OF CHAR) : CHAR;\n\n(* Pop returns the last non-OX element of an ARRAY OF CHAR replacing\n    it with an OX *)\nPROCEDURE Pop(VAR source : ARRAY OF CHAR) : CHAR;\n\n(* TrimLeft - remove the leading characters in cutset\n    from an ARRAY OF CHAR *)\nPROCEDURE TrimLeft(cutset : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimRight - remove tailing characters in cutset from\n    an ARRAY OF CHAR *)\nPROCEDURE TrimRight(cutset : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* Trim - remove leading and trailing characters in cutset\n    from an ARRAY OF CHAR *)\nPROCEDURE Trim(cutset : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimLeftSpace - remove leading spaces from an ARRAY OF CHAR *)\nPROCEDURE TrimLeftSpace(VAR source : ARRAY OF CHAR);\n\n(* TrimRightSpace - remove the trailing spaces from an ARRAY OF CHAR *)\nPROCEDURE TrimRightSpace(VAR source : ARRAY OF CHAR);\n\n(* TrimSpace - remove leading and trailing space CHARS from an \n    ARRAY OF CHAR *)\nPROCEDURE TrimSpace(VAR source : ARRAY OF CHAR);\n\n(* TrimPrefix - remove a prefix ARRAY OF CHAR from a target \n    ARRAY OF CHAR *)\nPROCEDURE TrimPrefix(prefix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimSuffix - remove a suffix ARRAY OF CHAR from a target\n    ARRAY OF CHAR *)\nPROCEDURE TrimSuffix(suffix : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\n(* TrimString - remove cutString from beginning and end of ARRAY OF CHAR *)\nPROCEDURE TrimString(cutString : ARRAY OF CHAR; VAR source : ARRAY OF CHAR);\n\nEND Chars.\n```\n\nMy new `Chars` module has proven to be both more readable\nand more focused in my projects. I get all the functionality\nof `Strings` and the additional functionality I need in my own\nprojects. This improved the focus in my other modules and I think\nmaintained the spirit of \"Simple but not simpler\".\n\n+ [Chars.Mod](Chars.Mod)\n\nUPDATE: The current version of my `Chars` module can be found in \nmy [Artemis](https://github.com/rsdoiel/Artemis) repository. The\nrepository includes additional code and modules suitable to working\nwith Oberon-07 in a POSIX envinronment.\n\n### Next, Previous\n\n+ Next [Combining Oberon-07 with C using Obc-3](/blog/2021/06/14/Combining-Oberon-07-with-C-using-Obc-3.html)\n+ Prev [Dates & Clocks](/blog/2020/11/27/Dates-and-Clock.html)\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-05-16",
        "keywords": [
          "Oberon",
          "Modules",
          "Oakwood",
          "Strings",
          "Chars"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 18,
        "title": "Beyond Oakwood, Modules and Aliases"
      },
      "url": "posts/2021/05/16/Beyond-Oakwood-Modules-and-Aliases.json"
    },
    {
      "content": "\n\nCombing Oberon-07 with C using Obc-3\n===================================\n\nBy R. S. Doiel, 2021-06-14\n\nThis post explores integrating C code with an Oberon-07 module use\nMike Spivey's Obc-3 Oberon Compiler.  Last year I wrote a similar post\nfor Karl Landström's [OBNC](/blog/2020/05/01/Combining-Oberon-and-C.html).\nThis goal of this post is to document how I created a version of Karl's\nExtension Library that would work with Mike's Obc-3 compiler.\nIf you want to take a shortcut you can see the results on GitHub\nin my [obc-3-libext](https://github.com/rsdoiel/obc-3-libext) repository.\n\nFrom my time with OBNC I've come to rely on three modules from Karl's\nextension library. When trying to port some of my code to use with\nMike's compiler. That's where I ran into a problem with that dependency.\nKarl's modules aren't available. I needed an [extArgs](http://miasap.se/obnc/obncdoc/ext/extArgs.def.html),\nan [extEnv](http://miasap.se/obnc/obncdoc/ext/extEnv.def.html) and\n[extConvert](http://miasap.se/obnc/obncdoc/ext/extConvert.def.html).\n\nMike's own modules that ship with Obc-3 cover allot of common ground\nwith Karl's. They are organized differently. The trivial solution is\nto implement wrapping modules using Mike's modules for implementation.\nThat takes case of extArgs and extEnv.\n\nThe module extConvert is in a another category. Mike's `Conv` module is\nsignificantly minimalist. To solve that case I've create C code to perform\nthe needed tasks based on Karl's examples and used Mike's share library\ncompilation instructions to make it available inside his run time.\n\nBackground material\n-------------------\n\n- [Obc-3 website](https://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler)\n    - [Installing Obc-3](https://spivey.oriel.ox.ac.uk/corner/Installing_OBC_release_3.1)\n    - [Adding primitives to Obc-3](https://spivey.oriel.ox.ac.uk/corner/How_to_add_primitives_to_OBC), this is how you extend Obc-3 with C\n    - [Obc-3.1 Manual](https://spivey.oriel.ox.ac.uk/wiki/images-corner/c/ce/Obcman-3.1.pdf)\n- [Obc-3 at GitHub](http://github.com/Spivoxity/obc-3)\n\n\nDifferences: OBNC and Obc-3\n---------------------------\n\nThe OBNC compiler written by Karl takes the approach of translating\nOberon-07 code to C and then calling the C tool chain to convert that\ninto a   executable.  Karl's compiler is largely written in C\nwith some parts written in Oberon.\n\nMike's takes a different approach. His compiler uses a run time JIT\nand is written mostly in OCaml with some C parts and shell scripting.\nWhen you compile an Oberon program (either Oberon-2 or Oberon-07) using\nMike's compiler you get a bunch of \"*.k\" files that the object code\nfor Mike's thunder virtual machine and JIT.  This can in turn be used\nto create a executable.\n\nFor implementing Oberon procedures in C Karl's expects an empty\nprocedure body. e.g.\n\n```oberon\nPROCEDURE DoMyThing();\nBEGIN\nEND DoMyThing;\n```\n\nWhile Mike has added a \"IS\" phrase to the procedure signature to\nindicate what the C implementation is known as. There is no procedure\nbody in Mike's implementation and the parameters need to map\ndirectly into a C data type.\n\n```oberon\nPROCEDURE DoMyThing() IS \"do_my_thing\";\n```\n\nOf course both compilers have completely different command line options\nand when you're integrating C shared libraries in Mike's you need to\ncall your local CC (e.g. GCC, clang) to create a share library file.\nMike has extended Oberon-07 SYSTEM to include `SYSTEM.LOADLIB()` which\ntakes a string containing the path to the compiler shared library.\n\nIn Karl's own Oberon-07 modules he uses the `.obn` file extension but\nalso accepts `.Mod`.  In Mike's he uses `.m` and also accepts `.Mod`.\nIn this article I will be using `.m` as that simplified the recipe\nof building and integrating the shared C libraries.\n\n\nSimilarities of OBNC and Obc-3\n------------------------------\n\nBoth compilers provide for compiling Oberon-07 code, Mike's requires\nthe `-07` option to be used to switch from Oberon-2. Both offer the\nability to extend reach into the host POSIX system by wrapping\nC shared libraries. Both run on a wide variety of POSIX systems and\nyou can read the source code at your leisure. This last bit is\nimportant.\n\nArgs, extArgs and extEnv.\n-------------------------\n\nMike provides two features in his Args module. The first is access\nto the command line arguments of the compiled program. The\nsecond feature is to provide access to the host environment variables.\nIn Karl's implementation he separates Mikes `Args.GetEvn()` into\na module called `extEnv`. Here's Mike's module definition looks like ---\n\n```oberon\nDEFINITION Args;\n\nVAR argc* : INTEGER; (* this is equavilent to extArgs.count *)\n\nPROCEDURE GetArg*(n: INTEGER; VAR s: ARRAY OF CHAR);\n\nPROCEDURE GetEnv*(name: ARRAY OF CHAR; VAR s: ARRAY OF CHAR);\n\nEND Args.\n```\n\nMy implementation of Karl's `extArgs` needs to look like ---\n\n```oberon\nDEFINITION extArgs;\n\nVAR count*: INTEGER; (* this is the same as Args.argc *)\n\nPROCEDURE Get*(n: INTEGER; VAR arg: ARRAY OF CHAR; VAR res: INTEGER);\n\nEND extArgs.\n```\n\nThis leaves us with a very simple module mimicking Karl's.\n\n```oberon\nMODULE extArgs;\n\nIMPORT Args;\n\nVAR\n  count*: INTEGER;\n\nPROCEDURE Get*(n: INTEGER; VAR arg: ARRAY OF CHAR; VAR res: INTEGER);\nBEGIN\n  Args.GetArg(n + 1, arg);  res := 0;\nEND Get;\n\nBEGIN\n  count := Args.argc - 1;\nEND extArgs.\n```\n\nNOTE: In Mike's approach the zero-th arg is the program name.\nIn Karl's the zero-th arg is the first argument after the program\nname. To get Karl's behavior with Mike's `GetArg()` I need to\nadjust the offsets.\n\nSo far so good. How about implementing Karl's `extEnv`?\n\nWe've already seen Mike's Args so he doesn't have a matching\ndefinition.  Karl's `extEnv` looks like\n\n```oberon\nDEFINITION extEnv;\n\nPROCEDURE Get*(name: ARRAY OF CHAR; VAR value: ARRAY OF CHAR; VAR res: INTEGER);\n\nEND extEnv.\n```\n\nAnd again a simple mapping of features and you have\n\n```oberon\nMODULE extEnv;\n\nIMPORT Args, Strings;\n\nPROCEDURE Get*(name : ARRAY OF CHAR; VAR value : ARRAY OF CHAR; VAR res : INTEGER);\n  VAR i, l1, l2 : INTEGER; val : ARRAY 512 OF CHAR;\nBEGIN\n  l1 := LEN(value) - 1; (* Allow for trailing 0X *)\n  Args.GetEnv(name, val);\n  l2 := Strings.Length(val);\n  IF l2 <= l1 THEN\n    res := 0;\n  ELSE\n    res := l2 - l1;\n  END;\n  i := 0;\n  WHILE (i < l2) & (val[i] # 0X) DO\n      value[i] := val[i];\n      INC(i);\n  END;\n  value[i] := 0X;\nEND Get;\n\nEND extEnv.\n```\n\nextConvert requires more work\n-----------------------------\n\nMike provides a module called `Conv.m` for converting numbers\nto strings.  It is a little minimal for my current purpose.\nThat is easy enough to solve as Mike, like Karl provides a means\nof extending Oberon code with C.  That means I need to write\n`extConvert` as both `extConvert.m` (the Oberon-07 part) and\n`extConvert.c` (the C part).\n\nHere's Karl's definition\n\n```oberon\nDEFINITION extConvert;\n\nPROCEDURE IntToString*(i: INTEGER; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n\nPROCEDURE RealToString*(x: REAL; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n\nPROCEDURE StringToInt*(s: ARRAY OF CHAR; VAR i: INTEGER; VAR done: BOOLEAN);\n\nPROCEDURE StringToReal*(s: ARRAY OF CHAR; VAR x: REAL; VAR done: BOOLEAN);\n\nEND extConvert.\n```\n\nI have implement my `extConvert` as a hybrid of Oberon-07 and calls\nto a C shared library I will create called `extConvert.c`.\n\nThe Oberon file (i.e. extConvert.m)\n\n```oberon\nMODULE extConvert;\n\nIMPORT SYSTEM;\n\nPROCEDURE IntToString*(i: INTEGER; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n  VAR l : INTEGER;\nBEGIN\n  l := LEN(s); done := TRUE;\n  IntToString0(i, s, l);\nEND IntToString;\n\nPROCEDURE IntToString0(i : INTEGER; VAR s : ARRAY OF CHAR; l : INTEGER) IS \"conv_int_to_string\";\n\nPROCEDURE RealToString*(x: REAL; VAR s: ARRAY OF CHAR; VAR done: BOOLEAN);\n  VAR l : INTEGER;\nBEGIN\n  l := LEN(s);\n  RealToString0(x, s, l);\nEND RealToString;\n\nPROCEDURE RealToString0(x: REAL; VAR s: ARRAY OF CHAR; l : INTEGER) IS \"conv_real_to_string\";\n\nPROCEDURE StringToInt*(s: ARRAY OF CHAR; VAR i: INTEGER; VAR done: BOOLEAN);\nBEGIN\n  done := TRUE;\n  StringToInt0(s, i);\nEND StringToInt;\n\nPROCEDURE StringToInt0(s : ARRAY OF CHAR; VAR i : INTEGER) IS \"conv_string_to_int\";\n\nPROCEDURE StringToReal*(s: ARRAY OF CHAR; VAR x: REAL; VAR done: BOOLEAN);\nBEGIN\n  done := TRUE;\n  StringToReal0(s, x);\nEND StringToReal;\n\nPROCEDURE StringToReal0(s: ARRAY OF CHAR; VAR x : REAL) IS \"conv_string_to_real\";\n\nBEGIN\n  SYSTEM.LOADLIB(\"./extConvert.so\");\nEND extConvert.\n```\n\nIf you review Mike's module code you'll see I have followed a similar pattern. Before calling out to C I take care of what house keeping I can in Oberon, then I call a \"0\" version of the function implemented in C. The C implementation are not exported only the wrapping Oberon procedures are.\n\nNotice how the initialization block calls `SYSTEM.LOADLIB(\"./extConvert.so\");` this loads the C shared library so that the Oberon module can call out it it.\n\nThe C code in `extConvert.c` looks very traditional without the macros\nyou'd see in OBNC's implementation. Here's what the C code look like.\n\n```C\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid conv_int_to_string(int i, char *s, int l) {\n  snprintf(s, l, \"%d\", i);\n}\n\nvoid conv_real_to_string(float r, char *s, int l) {\n  snprintf(s, l, \"%f\", r);\n}\n\nvoid conv_real_to_exp_string(float r, char *s, int l) {\n  snprintf(s, l, \"%e\", r);\n}\n\nvoid conv_string_to_int(char *s, int *i) {\n    *i = atoi(s);\n}\n\nvoid conv_string_to_real(char *s, float *r) {\n    *r = atof(s);\n}\n```\n\nThe dance to compile the module and C shared library is very different\nbetween OBNC and Obc-3.  With Obc-3 we compile and skip linking\nthe wrapping Oberon module `extConvert.m`. We compile using CC\nour C shared library. We can then put it all together to test\neverything out in `ConvertTest.m`.\n\n```shell\nobc -07 -c extConvert.m\ngcc -fPIC -shared extConvert.c -o extConvert.so\n```\n\nOur test code program looks like.\n\n```oberon\nMODULE ConvertTest;\n\nIMPORT T := Tests, Convert := extConvert;\n\nVAR ts : T.TestSet;\n\nPROCEDURE TestIntConvs() : BOOLEAN;\n  VAR test, ok : BOOLEAN;\n      expectI, gotI : INTEGER;\n      expectS, gotS : ARRAY 128 OF CHAR;\nBEGIN test := TRUE;\n  gotS[0] := 0X; gotI := 0;\n  expectI := 101;\n  expectS := \"101\";\n\n  Convert.StringToInt(expectS, gotI, ok);\n  T.ExpectedBool(TRUE, ok, \"StringToInt('101', gotI, ok) true\", test);\n  T.ExpectedInt(expectI, gotI, \"StringToInt('101', gotI, ok)\", test);\n\n  Convert.IntToString(expectI, gotS, ok);\n  T.ExpectedBool(TRUE, ok, \"IntToString(101, gotS, ok) true\", test);\n  T.ExpectedString(expectS, gotS, \"IntToString(101, gotS, ok)\", test);\n\n  RETURN test\nEND TestIntConvs;\n\nPROCEDURE TestRealConvs() : BOOLEAN;\n  VAR test, ok : BOOLEAN;\n      expectR, gotR : REAL;\n      expectS, gotS : ARRAY 128 OF CHAR;\nBEGIN test := TRUE;\n  gotR := 0.0; gotS[0] := 0X;\n  expectR := 3.1459;\n  expectS := \"3.145900\";\n\n  Convert.StringToReal(expectS, gotR, ok);\n  T.ExpectedBool(TRUE, ok, \"StringToReal('3.1459', gotR, ok) true\", test);\n  T.ExpectedReal(expectR, gotR, \"StringToReal('3.1459', gotR, ok)\", test);\n\n  Convert.RealToString(expectR, gotS, ok);\n  T.ExpectedBool(TRUE, ok, \"RealToString(3.1459, gotS; ok) true\", test);\n  T.ExpectedString(expectS, gotS, \"RealToString(3.1459, gotS, ok)\", test);\n\n  RETURN test\nEND TestRealConvs;\n\nBEGIN\n  T.Init(ts, \"extConvert\");\n  T.Add(ts, TestIntConvs);\n  T.Add(ts, TestRealConvs);\n  ASSERT(T.Run(ts));\nEND ConvertTest.\n```\n\nWe compile and run our test program use the following commands\n(NOTE: Using Obc-3 you list all the dependent modules to possibly\nbe compiled one the command line along with your program module).\n\n```shell\nobc -07 -o converttest extConvert.m Tests.m ConvertTest.m\n./converttest\n```\n\nSource code for these modules is available on GitHub at\n[github.com/rsdoiel/obc-3-libest](https://github.com/rsdoiel/obc-3-libext)\n\n\nNext & Previous\n---------------\n\n- Next [Revisiting Files](../../11/22/Revisiting-Files.html)\n- Previous [Beyond Oakwood, Modules and Aliases](../../05/16/Beyond-Oakwood-Modules-and-Aliases.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-06-14",
        "keywords": [
          "Oberon",
          "Obc-3",
          "C",
          "extArgs",
          "extEnv",
          "extConvert"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 19,
        "title": "Combining Oberon-07 with C using Obc-3"
      },
      "url": "posts/2021/06/14/Combining-Oberon-07-with-C-using-Obc-3.json"
    },
    {
      "content": "\nRevisiting Files\n================\n\nBy R. S. Doiel, 2021-11-22\n\nIn October I had an Email exchange with Algojack regarding a buggy example in [Oberon-07 and the file system](../../../2020/05/09/Oberon-07-and-the-filesystem.html). The serious bug was extraneous non-printable characters appearing a plain text file containing the string \"Hello World\". The trouble with the example was a result of my misreading the Oakwood guidelines and how **Files.WriteString()** is required to work. The **Files.WriteString()** procedure is supposed to write every element of a string to a file. This __includes the trailing Null character__. The problem for me is **Files.WriteString()** litters plain text files with tailing nulls. What I should have done was write my own **WriteString()** and **WriteLn()**. The program [HelloworldFile](./HelloworldFile.Mod) below is a more appropriate solution to writing strings and line endings than relying directly on **Files**. In a future post I will explorer making this more generalized in a revised \"Fmt\" module.\n\n~~~\nMODULE HelloworldFile;\n\nIMPORT Files, Strings;\n\nCONST OberonEOL = 1; UnixEOL = 2; WindowsEOL = 3;\n\nVAR\n  (* holds the eol marker type to use in WriteLn() *)\n  eolType : INTEGER;\n  (* Define a file handle *)\n    f : Files.File;\n  (* Define a file rider *)\n    r : Files.Rider;\n\nPROCEDURE WriteLn(VAR r : Files.Rider);\nBEGIN\n  IF eolType = WindowsEOL THEN\n    (* A DOS/Windows style line ending, LFCR *)\n    Files.Write(r, 13);\n    Files.Write(r, 10);\n  ELSIF eolType = UnixEOL THEN\n     (* Linux/macOS style line ending, LF *)\n     Files.Write(r, 10);\n  ELSE\n    (* Oberon, RISC OS style line ending, CR *)\n    Files.Write(r, 13);\n  END;\nEND WriteLn;\n\nPROCEDURE WriteString(VAR r : Files.Rider; s : ARRAY OF CHAR);\n  VAR i : INTEGER;\nBEGIN\n  i := 0;\n  WHILE i < Strings.Length(s) DO\n    Files.Write(r, ORD(s[i]));\n    INC(i);\n  END;\nEND WriteString;\n\nBEGIN\n  (* Set the desired eol type to use *)\n  eolType := UnixEOL;\n  (* Create our file, New returns a file handle *)\n  f := Files.New(\"helloworld.txt\"); ASSERT(f # NIL);\n  (* Register our file with the file system *)\n  Files.Register(f);\n  (* Set the position of the rider to the beginning *)\n  Files.Set(r, f, 0);\n  (* Use the rider to write out \"Hello World!\" followed by a end of line *)\n  WriteString(r, \"Hello World!\");\n  WriteLn(r);\n  (* Close our modified file *)\n  Files.Close(f);\nEND HelloworldFile.\n~~~\n\nI have two new procedures \"WriteString\" and \"WriteLn\". These mimic the parameters found in the Files module. The module body is a bit longer.\n\nCompare this to a simple example of \"Hello World\" using the **Out** module.\n\n~~~\nMODULE HelloWorld;\n\nIMPORT Out;\n\nBEGIN\n  Out.String(\"Hello World\");\n  Out.Ln;\nEND HelloWorld.\n~~~\n\nLook at the difference is in the module body. I need to setup our file and rider as well as pick the type of line ending to use in \"WriteLn\". The procedures doing the actual work look very similar, \"String\" versus \"WriteString\" and \"Ln\" versus \"WriteLn\".  \n\n\nLine ends vary between operating systems. Unix-like systems usually use a line feed. DOS/Windows systems use a carriage return and line feed. Oberon Systems use only a carriage return. If we're going to the trouble of re-creating our \"WriteString\" and \"WriteLn\" procedures it also makes sense to handle the different line ending options.  In this case I've chosen to use an INTEGER variable global to the module called \"eolType\". I have a small set of constants to indicate which line ending is needed. In \"WriteLn\" I use that value as a guide to which line ending to use with the rider writing to the file.\n\nThe reason I chose this approach is because I want my writing procedures to use the same procedure signatures as the \"Files\" module. In a future post I will explore type conversion and a revised implementation of my \"Fmt\" module focusing on working with plain text files.\n\nAside from our file setup and picking an appropriate end of line marker the shape of the two programs look very similar.\n\nReferences and resources\n------------------------\n\nYou can see a definition of the [Files](https://miasap.se/obnc/obncdoc/basic/Files.def.html \"My example module definition is based on the on Karl created in OBNC\") at Karl Landström's documentation for his compiler along with the definitions for [In](https://miasap.se/obnc/obncdoc/basic/In.def.html) and [Out](https://miasap.se/obnc/obncdoc/basic/Out.def.html).\n\n\nNext & Previous\n---------------\n\n- Next [Portable Conversions (Integers)](../../11/26/Portable-Conversions-Integers.html)\n- Prev [Combining Oberon-07 with C using Obc-3](../../06/14/Combining-Oberon-07-with-C-using-Obc-3.html)\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-11-12",
        "keywords": [
          "Oberon",
          "Files",
          "plain text"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 20,
        "title": "Revisiting Files"
      },
      "url": "posts/2021/11/22/Revisiting-Files.json"
    },
    {
      "content": "\nPortable conversions (Integers)\n===============================\n\nBy R. S. Doiel, 2021-11-26\n\nAn area in working with Oberon-07 on a POSIX machine that has proven problematic is type conversion. In particular converting to and from INTEGER or REAL and ASCII.  None of the three compilers I am exploring provide a common way of handling this. I've explored relying on C libraries but that approach has it's own set of problems.  I've become convinced a better approach is a pure Oberon-07 library that handles type conversion with a minimum of assumptions about the implementation details of the Oberon compiler or hardware. I'm calling my conversion module \"Types\". The name is short and descriptive and seems an appropriate name for a module consisting of type conversion tests and transformations.  My initial implementation will focusing on converting integers to and from ASCII.\n\nINTEGER to ASCII and back again\n-------------------------------\n\nI don't want to rely on the representation of the INTEGER value in the compiler or at the machine level. That has lead me to think in terms of an INTEGER as a signed whole number. \n\nThe simplest case of converting to/from ASCII is the digits from zero to nine (inclusive). Going from an INTEGER to an ASCII CHAR is just looking up the offset of the character representing the \"digit\". Like wise going from ASCII CHAR to a INTEGER is a matter of mapping in the reverse direction.  Let's call these procedures `DigitToChar` and  `CharToDigit*`.\n\nSince INTEGER can be larger than zero through nine and CHAR can hold non-digits I'm going to add two additional procedures for validating inputs -- `IsIntDigit` and `IsCharDigit`. Both return TRUE if valid, FALSE if not.\n\nFor numbers larger than one digit I can use decimal right shift to extract the ones column value or a left shift to reverse the process.  Let's called these `IntShiftRight` and `IntShiftLeft`.  For shift right it'd be good to capture the ones column being lost. For shift left it would be good to be able to shift in a desired digit. That way you could shift/unshift to retrieve to extract and put back values.\n\nA draft definition for \"Types\" should look something like this.\n\n~~~\nDEFINITION Types;\n\n(* Check if an integer is a single digit, i.e. from 0 through 9 returns\n   TRUE, otherwise FALSE *)\nPROCEDURE IsIntDigit(x : INTEGER) : BOOLEAN;\n\n(* Check if a CHAR is \"0\" through \"9\" and return TRUE, otherwise FALSE *)\nPROCEDURE IsCharDigit(ch : CHAR) : BOOLEAN;\n\n(* Convert digit 0 through 9 into an ASCII CHAR \"0\" through \"9\",\n   ok is TRUE if conversion successful, FALSE otherwise *)\nPROCEDURE DigitToChar(x : INTEGER; VAR ch : CHAR; VAR ok : BOOLEAN);\n\n(* Convert a CHAR \"0\" through \"9\" into a digit 0 through 9, ok\n   is TRUE is conversion successful, FALSE otherwise *)\nPROCEDURE CharToDigit(ch : CHAR; VAR x : INTEGER; VAR ok : BOOLEAN);\n\n(* Shift an integer to the right (i.e. x * 0.1) set \"r\" to the\n   value shifted out (ones column lost) and return the shifted value.\n   E.g.  x becomes 12, r becomes 3.\n\n       x := IntShiftRight(123, r);\n   \n *)\nPROCEDURE IntShiftRight(x : INTEGER; VAR r : INTEGER) : INTEGER;\n\n(* Shift an integer to the left (i.e. x * 10) adding the value y\n   after the shift.\n\n   E.g. x before 123\n\n       x := IntShiftRight(12, 3);\n\n *)\nPROCEDURE IntShiftLeft(x, y : INTEGER) : INTEGER;\n\n(* INTEGER to ASCII *)\nPROCEDURE Itoa(src : INTEGER; VAR value : ARRAY OF CHAR; VAR ok : BOOLEAN);\n\n(* ASCII to INTEGER *)\nPROCEDURE Atoi(src : ARRAY OF CHAR; VAR value : INTEGER; VAR ok : BOOLEAN);\n\nEND Types.\n~~~\n\n\nNOTE: Oberon-07 provides us the ORD and CHR built as part of the\nlanguage.  These are for working with the encoding and decoding\nvalues as integers. This is not the same thing as the meaning\nof \"0\" versus the value of 0.  Getting to and from the encoding\nto the meaning of the presentation can be done with some simple\narithmetic.\n\nPutting it all together\n-----------------------\n\n~~~\n(* DigitToChar converts an INTEGER less than to a character. E.g.\n   0 should return \"0\", 3 returns \"3\", 0 returns \"9\" *)\nPROCEDURE DigitToChar*(i : INTEGER) : CHAR;\nBEGIN\n  RETURN (CHR(ORD(\"0\") + i))\nEND DigitToChar;\n\n(* CharToDigit converts a single \"Digit\" character to an INTEGER value.\n   E.g. \"0\" returns 0, \"3\" returns 3, \"9\" returns 9. *)\nPROCEDURE CharToDigit(ch : CHAR) : INTEGER;\nBEGIN\n  RETURN (ORD(ch) - ORD(\"0\"))\nEND CharToDigit;\n~~~\n\nThis implementation is naive. It assumes the ranges of the input values\nwas already checked. In practice this is going to encourage bugs.\n\nIn a language like Go or Python you can return multiple values (in\nPython you can return a tuple). In Oberon-07 I could use a\nRECORD type to do that but that feels a little too baroque. Oberon-07\nlike Oberon-2, Oberon, Modula and Pascal does support \"VAR\" parameters. \nWith a slight modification to our procedure signatures I can support\neasy assertions about the conversion. Let's create two functional\nprocedures `IsIntDigit()` and `IsCharDigit()` then update our\n`DigitToChar()` and `CharToDigit()` with an a  \"VAR ok : BOOLEAN\"\nparameter.\n\n~~~\n(* IsIntDigit returns TRUE is the integer value is zero through nine *)\nPROCEDURE IsIntDigit(i : INTEGER) : BOOLEAN;\nBEGIN \n  RETURN ((i >= 0) & (i <= 9))\nEND IsIntDigit;\n\n(* IsCharDigit returns TRUE if character is zero through nine. *)\nPROCEDURE IsCharDigit(ch : CHAR) : BOOLEAN;\nBEGIN\n  RETURN ((ch >= \"0\") & (ch <= \"9\"))\nEND IsCharDigit;\n\n(* DigitToChar converts an INTEGER less than to a character. E.g.\n   0 should return \"0\", 3 returns \"3\", 0 returns \"9\" *)\nPROCEDURE DigitToChar*(i : INTEGER; VAR ok : BOOLEAN) : CHAR;\nBEGIN\n  ok := IsIntDigit(i);\n  RETURN (CHR(ORD(\"0\") + i))\nEND DigitToChar;\n\n(* CharToDigit converts a single \"Digit\" character to an INTEGER value.\n   E.g. \"0\" returns 0, \"3\" returns 3, \"9\" returns 9. *)\nPROCEDURE CharToDigit(ch : CHAR; VAR ok : BOOLEAN) : INTEGER;\nBEGIN\n  ok := IsCharDigit(ch);\n  RETURN (ORD(ch) - ORD(\"0\"))\nEND CharToDigit;\n~~~\n\nWhat about values are greater nine? Here we can take advantage\nof our integer shift procedures.  `IntShiftRight` will move the\nINTEGER value right reducing it's magnitude (i.e. x * 0.1). It\nalso captures the ones column lost in the shift.  Repeatedly calling\n`IntShiftRight` will let us peal off the ones columns until the\nvalue \"x\" is zero. `IntShiftLeft` shifts the integer to the\nleft meaning it raises it a magnitude (i.e. x * 10). `IntShiftLeft`\nalso rakes a value to shift in on the right side of the number.\nIn this way we can shift in a zero and get `x * 10` or shift in\nanother digit and get `(x * 10) + y`. This means you can use\n`IntShiftRight` and recover an `IntShiftLeft`.\n\n~~~\n\n(* IntShiftRight converts the input integer to a real, multiplies by 0.1\n   and converts by to an integer. The value in the ones column is record\n   in the VAR parameter r.  E.g. IntShiftRight(123) return 12, r is set to 3. *)\nPROCEDURE IntShiftRight*(x : INTEGER; VAR r : INTEGER) : INTEGER;\n  VAR i : INTEGER; isNeg : BOOLEAN;\nBEGIN\n  isNeg := (x < 0);\n  i := FLOOR(FLT(ABS(x)) * 0.1);\n  r := ABS(x) - (i * 10);\n  IF isNeg THEN\n    i := i * (-1);\n  END;\n  RETURN i\nEND IntShiftRight;\n\n(* IntShiftLeft multiples input value by 10 and adds y. E.g. IntShiftLeft(123, 4) return 1234 *)\nPROCEDURE IntShiftLeft*(x, y : INTEGER) : INTEGER;\n  VAR i : INTEGER; isNeg : BOOLEAN;\nBEGIN\n  isNeg := (x < 0);\n  i := (ABS(x) * 10) + y;\n  IF isNeg THEN\n    i := i * (-1);\n  END;\n  RETURN i\nEND IntShiftLeft;\n\n~~~\n\nI have what I need for implementing `Itoa` (integer to ASCII).\n\n\n~~~\n\n(* Itoa converts an INTEGER to an ASCII string setting ok BOOLEAN to\n   TRUE if value ARRAY OF CHAR holds the full integer, FALSE if\n   value was too small to hold the integer value.  *)\nPROCEDURE Itoa*(x : INTEGER; VAR value : ARRAY OF CHAR; ok : BOOLEAN);\n  VAR i, j, k, l, minL : INTEGER; tmp : ARRAY BUFSIZE OF CHAR; isNeg : BOOLEAN;\nBEGIN\n  i := 0; j := 0; k := 0; l := LEN(value); isNeg := (x < 0);\n  IF isNeg THEN\n    (* minimum string length for value is 3, negative sign, digit and 0X *)\n    minL := 3;\n  ELSE \n    (* minimum string length for value is 2, one digit and 0X *)\n    minL := 2; \n  END;\n  ok := (l >= minL) & (LEN(value) >= LEN(tmp));\n  IF ok THEN\n    IF IsIntDigit(ABS(x)) THEN\n      IF isNeg THEN\n         value[i] := \"-\"; INC(i);\n      END;\n      value[i] := DigitToChar(ABS(x), ok); INC(i); value[i] := 0X;\n    ELSE\n      x := ABS(x); (* We need to work with the absolute value of x *)\n      i := 0; tmp[i] := 0X;\n      WHILE (x >= 10) & ok DO\n        (* extract the ones columns *)\n        x := IntShiftRight(x, k); (* a holds the shifted value, \n                                     \"k\" holds the ones column \n                                     value shifted out. *)\n        (* write append k to our temp array holding values in\n           reverse number magnitude *)\n        tmp[i] := DigitToChar(k, ok); INC(i); tmp[i] := 0X;\n      END;\n      (* We now can convert the remaining \"ones\" column. *)\n      tmp[i] := DigitToChar(x, ok); INC(i); tmp[i] := 0X;\n      IF ok THEN\n        (* now reverse the order of tmp string append each\n           character to value *)\n        i := 0; j := Strings.Length(tmp) - 2;\n        IF isNeg THEN\n          value[i] := \"-\"; INC(i);\n        END;\n        j := Strings.Length(tmp) - 1;\n        WHILE (j > -1) DO\n          value[i]:= tmp[j]; \n          INC(i); DEC(j);\n          value[i] := 0X;\n        END;\n        value[i] := 0X;\n      END;\n    END; \n  ELSE\n    ok := FALSE;\n  END;\nEND Itoa;\n\n~~~\n\nIntegers in Oberon are signed. So I've chosen to capture the sign in the `isNeg` variable. This lets me work with the absolute value for the actual conversion.  One failing in this implementation is I don't detect an overflow.  Also notice that I am accumulating the individual column values in reverse order (lowest magnitude first).  That is what I need a temporary buffer. I can then copy the values in reverse order into the VAR ARRAY OF CHAR. Finally I also maintain the ok BOOLEAN to track if anything went wrong.\n\nWhen moving from an ASCII representation I can simplified the code by having a local (to the module) procedure for generating magnitudes.\n\nGoing the other way I can simplify my `Atoi` if I have an local to the module \"magnitude\" procedure.\n\n~~~\n\n(* magnitude takes x and multiplies it be 10^y, If y is positive zeros\n   are appended to the right side (i.e. multiplied by 10). If y is\n   negative then the result is shifted left (i.e.. multiplied by\n   0.1 via IntShiftRight().).  The digit(s) shift to the fractional\n   side of the decimal are ignored. *)\nPROCEDURE magnitude(x, y : INTEGER) : INTEGER;\n  VAR z, w : INTEGER;\nBEGIN\n  z := 1;\n  IF y >= 0 THEN\n    WHILE y > 0 DO\n      z := IntShiftLeft(z, 0);\n      DEC(y);\n    END;\n  ELSE\n    WHILE y < 0 DO\n      x := IntShiftRight(x, w);\n      INC(y);\n    END;\n  END;\n  RETURN (x * z)\nEND magnitude;\n\n~~~\n\nAnd with that I can put together my `Atoi` (ASCII to integer) procedure.  I'll need to add some sanity checks as well.\n\n~~~\n\n(* Atoi converts an ASCII string to a signed integer value\n   setting the ok BOOLEAN to TRUE on success and FALSE on error. *)\nPROCEDURE Atoi*(source : ARRAY OF CHAR; VAR value : INTEGER; VAR ok : BOOLEAN);\n  VAR i, l, a, m: INTEGER; isNeg : BOOLEAN;\nBEGIN\n  (* \"i\" is the current CHAR position we're analyzing, \"l\" is the\n     length of our string, \"a\" holds the accumulated value,\n     \"m\" holds the current magnitude we're working with *)\n  i := 0; l := Strings.Length(source);\n  a := 0; m := l - 1; isNeg := FALSE; ok := TRUE;\n  (* Validate magnitude and sign behavior *)\n  IF (l > 0) & (source[0] = \"-\") THEN\n    INC(i); DEC(m);\n    isNeg := TRUE;\n  ELSIF (l > 0) & (source[0] = \"+\") THEN\n    INC(i); DEC(m);\n  END;\n\n  (* The accumulator should always hold a positive integer, if the\n     sign flips we have overflow, ok should be set to FALSE *)\n  ok := TRUE;\n  WHILE (i < l) & ok DO\n    a := a + magnitude(CharToDigit(source[i], ok), m);\n    IF a < 0 THEN\n      ok := FALSE; (* we have an overflow condition *)\n    END;\n    DEC(m);\n    INC(i);\n  END;\n  IF ok THEN\n    IF (i = l) THEN\n      IF isNeg THEN\n        value := a * (-1);\n      ELSE\n        value := a;\n      END;\n    END;\n  END;\nEND Atoi;\n\n~~~\n\nHere's an example using the procedures.\n\nConverting an integer 1234 to an string \"1234\".\n\n~~~\n\n   x := 1234; s := \"\"; ok := FALSE;\n   Types.Itoa(x, s, ok);\n   IF ok THEN \n     Out.String(s); Out.String(\" = \");\n     Out.Int(x,1);Out.Ln;\n   ELSE\n     Out.String(\"Something went wrong\");Out.Ln;\n   END;\n\n~~~\n\nConverting a string \"56789\" to integer 56789.\n\n~~~\n\n   x := 0; src := \"56789\"; ok := FALSE;\n   Types.Atoi(src, x, ok);\n   IF ok THEN \n     Out.Int(x,1); Out.String(\" = \"); Out.String(s); \n     Out.Ln;\n   ELSE\n     Out.String(\"Something went wrong\");Out.Ln;\n   END;\n\n~~~\n\n\nReferences and resources\n------------------------\n\nImplementations for modules for this article are linked here [Types](./Types.Mod), [TypesTest](./TypesTest.Mod) and [Tests](./Tests.Mod). \n\nExpanded versions of the `Types` module will be available as part of Artemis Project -- [github.com/rsdoiel/Artemis](https://github.com/rsdoiel/Artemis).\n\nPrevious\n--------\n\n- [Revisiting Files](../../11/22/Revisiting-Files.html)\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-11-26",
        "keywords": [
          "Oberon",
          "Modules",
          "Types",
          "conversion"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 21,
        "title": "Portable Conversions (Integers)"
      },
      "url": "posts/2021/11/26/Portable-Conversions-Integers.json"
    },
    {
      "content": "\nSetting up FreeDOS 1.3rc4 with Qemu\n-----------------------------------\n\nBy R. S. Doiel, 2021-11-27\n\nIn this article I'm going explore setting up FreeDOS with Qemu\non my venerable Dell 4319 running Raspberry Pi Desktop OS (Debian\nGNU/Linux).  First step is to download FreeDOS \"Live CD\" in the\n1.3 RC4 release. See http://freedos.org/download/ for that.\n\nInstalling Qemu\n---------------\n\nI needed to install Qemu in my laptop. It runs the Raspberry Pi\nDesktop OS (i.e. Debian with Raspberry Pi UI). I choose to install\nthe \"qemu-system\" package since I will likely use qemu for other\nthings besides FreeDOS. The qemu-system package contains all the\nvarious systems I might want to emulate in other projects as well\nas several qemu utilities that are handy.  Here's the full sequence\nof `apt` commands I ran (NOTE: these included making sure my laptop\nwas up to date before I installed qemu-system).\n\n~~~\nsudo apt update\nsudo apt upgrade\nsudo apt install qemu-system\n~~~\n\nNow that I had the software available it was time to figure out\nhow to actually knit things together and run FreeDOS.\n\n\nObtaining FreeDOS 1.3rc4\n------------------------\n\nBefore I get started I create a folder in my home directory\nfor running everything. You can name it what you want\nbut I called mine `FreeDOS_13` and changed into that folder\nfor the work in this article.\n\n~~~\nmkdir FreeDOS_13\ncd FreeDOS_13\n~~~\n\nI initially tried the CD images but ran into odd problems with\nqemu (possibly due to my lack of experience with qemu).\nAfter looking at that various options the USB Full release\nseemed like a good choice. It comes both as an image you can\n\"burn\" to your USB drive both also as a \"vmdk\" file used with\nemulators.\n\n~~~\ncurl -L -O https://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/distributions/1.3/previews/1.3-rc4/FD13-FullUSB.zip\nunzip FD13-FullUSB.zip\n~~~\n\nAt this point you should see the FreeDOS \"vmdk\" file, and \"img\" file and readme files if you list the directory out. I'm going to use the \"vmdk\" file to install FreeDOS on my virtual harddrive freedos.img.\n\n~~~\nls -l \n~~~\n\nPrepping my virtual machine\n---------------------------\n\nA virtual machine is not just a CPU and some random\naccess memory. A machine can include storage devices. For\nthe retro \"DOS\" experience you might looking virtual devices\nfor a \"harddrive\", \"floppy drive\" and \"CD-ROM drive\". \nQemu provides a tool called `qemu-img` for creating \nthese types of virtual devices.\n\nThe basic command is `qemu-img` using the \"create\" option with\nsome parameters.  The parameter are filename and size (see\n`man qemu-img` for gory details). I am calling my virtual\nharddrive \"freedos.img\".  With `qemu-img` the size can be\nspecified with a suffix like \"K\" for kilobytes,  \"M\" for\nmegabytes and \"G\" for gigabytes. DOS is a minimal requirements\na small (by today's standards) 750 megabyte harddrive seems\nappropriate.\n\n~~~\nqemu-img create freedos.img 750M\n~~~\n\nFor my purposes I need a harddrive so I stopped there. You\ncan always create other drives and then restart your virtual\nmachine with the appropriate options.\n\nBring up my FreeDOS box\n-----------------------\n\nNow I was ready to boot from installation media and install\nFreeDOS 1.3rc4 on my virtual harddrive.  For that I\nuse a \"qemu\" command for the system I want to emulate.\nI picked `qemu-system-i386` (see can see\nthe gory details of that command using `man qemu-system-i386`).\nTo install FreeDOS I'm going to boot from the vmdk file \nprovided for the purpose of installation. I then use the FreeDOS\ninstaller to make my freedos.img file bootable with all the\nDOS software I want to play with.\n\n~~~\nqemu-system-i386 \\\n   -m 8 \\\n   -boot menu=on,strict=on \\\n   -hda freedos.img \\\n   -hdb FD13FULL.vmdk\n~~~\n\nAt this point you should see the machine start to boot, press Esc\nwhen prompted and select the second hard drive to boot from (that's\nour vmdk drive).  The drive is then treated like the CD-ROM, follow\nthe programs instructions for installation. You will need to reboot\nseveral times during the process. Until your full installation is\ncomplete you'll need to select the second harddrive as the boot drive\nand continue the installation.\n\nThe first time I successfully installed FreeDOS 1.3rc4 I just installed\nthe plain dos. When I re-did the process I install everything. It\nfills up my 750M virtual harddrive but rc4 includes development tools\nlike a C compiler.  That I think made it worth it.\n\nHere's a Bash script you can use to build your FreeDOS machine.\n\n~~~\n#!/bin/bash\n\nif [ ! -f freedos.img ]; then\n  echo \"Creating fresh Harddisk as drive C:\"\n  qemu-img create freedos.img 750M\nfi\necho \"Booting machine using FD13FULL.vmdk for installation\"\nqemu-system-i386 \\\n    -m 8 \\\n    -boot menu=on,strict=on \\\n    -hda freedos.img \\\n    -hdb FD13FULL.vmdk\n~~~\n\nAnd here is one for running it.\n\n~~~\n#!/bin/bash\n\necho \"Booting machine using freedos.img as drive C:\"\nqemu-system-i386 \\\n    -m 8 \\\n    -boot menu=on,strict=on \\\n    -hda freedos.img\n~~~\n\nNext step, explore FreeDOS and see what I can build.\n\nPutting everything together\n---------------------------\n\nBelow is a [script](run-freedos-1.3rc4.bash) I developed automating either building or running your FreeDOS setup.\n\n~~~\n#!/bin/bash\n\nif [ ! -f FD13FULL.vmdk ]; then\n    if [ ! -f FD13-FullUSB.zip ]; then\n      echo \"Missing FD13FULL.vmdk, downloading FD13-FullUSB.zip\"\n      curl -L -O https://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/distributions/1.3/previews/1.3-rc4/FD13-FullUSB.zip\n    fi\n    echo \"Unzipping FD13-FullUSB.zip\"\n    unzip FD13-FullUSB.zip\nfi\n\nif [ ! -f freedos.img ]; then\n  echo \"Creating fresh Harddisk as drive C:\"\n  qemu-img create freedos.img 750M\n  echo \"Booting machine using FD13FULL.vmdk as drive C:\"\n  echo \"Installing FreeDOS on drive D:\"\n  qemu-system-i386 \\\n      -name FreeDOS \\\n      -machine pc \\\n      -m 32 \\\n      -boot order=c \\\n      -hda FD13FULL.vmdk \\\n      -hdb freedos.img \\\n      -parallel none \\\n      -vga cirrus \\\n      -display gtk\nelse\n  echo \"Booting machine using freedos.img on drive C:\"\n  qemu-system-i386 \\\n      -name FreeDOS \\\n      -machine pc \\\n      -m 32 \\\n      -boot menu=on,strict=on \\\n      -hda freedos.img \\\n      -parallel none \\\n      -vga cirrus \\\n      -display gtk\nfi\n~~~\n\n\nReference material\n------------------\n\nMy inspiration for this was the description of manual install in\nthe FreeDOS book section of the website, [Manual Install](https://www.freedos.org/books/get-started/june14-manual-install.html).\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-11-27",
        "keywords": [
          "FreeDOS",
          "Qemu"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Setting up FreeDOS 1.3rc4 with Qemu"
      },
      "url": "posts/2021/11/27/FreeDOS-1.3rc4-with-Qemu.json"
    },
    {
      "content": "\nNotes on setting up a Mid-2010 Mac Mini\n=======================================\n\nBy R. S. Doiel, 2021-12-18\n\nI acquired a Mid 2010 Mac Mini. It was in good condition but lacked an OS on the hard drive.  I used a previously purchased copy of Mac OS X Snow Leopard to get an OS up and running on the bare hardware. Then it was a longer effort to get the machine into a state with the software I wanted to use on it. My goal was Mac OS X High Sierra, Xcode 10.1 and Mac Ports. The process was straight forward but very time consuming but I think worth it.  I wound up with a nice machine for experimenting with and writing blog posts.\n\nThe setup process was as follows:\n\n1. Install macOS Snow Leopard on the bare disk of the Mac Mini\n2. Install macOS El Capitan on the Mac Mini after manually downloading it from Apple's support site\n3. Run updates indicated by El Capitan\n4. Install macOS High Sierra on the Mac Mini after manually downloading it from the Apple's support site\n5. Run updates indicated by High Sierra \n6. Manually download and install Xcode 10.1 command line tools \n7. Check and run some updates again\n8. Finally install Mac Ports\n\nThe OS installs took about 45 minutes to 90 minutes each. Installing Xcode took about 45 minutes to an hour. Installing Mac Ports was fast as was installing software via Mac Ports.\n\nReference material\n------------------\n\n- Apple support pages that I found helpful\n    - [How to get old versions of macOS](https://support.apple.com/en-us/HT211683)\n    - [How to create a bootable installer for macOS](https://support.apple.com/en-us/HT201372)\n    - [macOS High Sierra - Technical Specifications](https://support.apple.com/kb/SP765?locale=en_US)\n- Wikipedia page on [Xcode](https://en.wikipedia.org/wiki/Xcode) is how I sorta out what version of Xcode I needed to install\n- Links to old macOS and Xcode\n    - Download [Mac OS X El El Capitan](http://updates-http.cdn-apple.com/2019/cert/061-41424-20191024-218af9ec-cf50-4516-9011-228c78eda3d2/InstallMacOSX.dmg)\n    - Download [Mac OX X High Sierra](https://apps.apple.com/us/app/macos-high-sierra/id1246284741?mt=12)\n    - Download [Xcode 10.1](https://developer.apple.com/download/all/?q=xcode), Scroll down the list until you want it.\n        - [Command Line Tools (macOS 10.13) for Xcode 10.1](https://download.developer.apple.com/Developer_Tools/Command_Line_Tools_macOS_10.13_for_Xcode_10.1/Command_Line_Tools_macOS_10.13_for_Xcode_10.1.dmg)\n        - NOTE: There are two version available, you want the version for macOS 10.13 (High Sierra) NOT Mac OS 10.14.\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2021, R. S. Doiel",
        "date": "2021-12-18",
        "keywords": [
          "macOS",
          "High Sierra",
          "Mac Mini"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Notes on setting up a Mid-2010 Mac Mini"
      },
      "url": "posts/2021/12/18/Notes-on-setting-up-a-2010-Mac-Mini.json"
    },
    {
      "content": "\n\nInstalling Golang from Source on RPi-OS for arm64\n==========================================\n\nBy R. S. Doiel, 2022-02-18\n\nThis are my quick notes on installing Golang from source on the Raspberry Pi OS 64 bit.\n\n1. Get a working compiler\n\ta. go to https://go.dev/dl/ and download go1.17.7.linux-arm64.tar.gz\n\tb. untar the tarball in your home directory (it'll unpack to $HOME/go)\n\tc. `cd go/src` and `make.bash`\n2. Move go directory to go1.17\n3. Clone go from GitHub\n4. Compile with the downloaded compiler\n\ta. `cd go/src`\n\tb. `env GOROOT_BOOTSTRAP=$HOME/go1.17 ./make.bash`\n\tc. Make sure `$HOME/go/bin` is in the path\n\td. `go version`\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2022, R. S. Doiel",
        "date": "2022-02-18",
        "keywords": [
          "raspberry pi",
          "Raspberry Pi OS",
          "arm64"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 1,
        "series": "Raspberry Pi",
        "title": "Installing Golang from source on RPi-OS for arm64"
      },
      "url": "posts/2022/02/18/Installing-Go-from-Source-RPiOS-arm64.json"
    },
    {
      "content": "\nArtemis Project Status, 2022\n============================\n\nIt's been a while since I wrote an Oberon-07 post and even longer since I've worked on Artemis. Am I done with Oberon-07 and abandoning Artemis?  No. Life happens and free time to just hasn't been available. I don't know when that will change.\n\nWhat's the path forward?\n------------------------\n\nSince I plan to continue working Artemis I need to find a way forward in much less available time. Time to understand some of my constraints. \n\n1. I work on a variety of machines, OBNC is the only compiler I've consistently been able to use across all my machines\n2. Porting between compilers takes energy and time, and those compilers don't work across all my machines\n3. When I write Oberon-07 code I quickly hit a wall for the things I want to do, this is what original inspired Artemis, so there is still a need for a collection of modules\n4. Oberon/Oberon-07 on Wirth RISC virtual machine is not sufficient for my development needs\n5. A2, while very impressive, isn't working for me either (mostly because I need to work on ARM CPUs)\n\nThese constraints imply Artemis is currently too broadly scoped. I think I need to focus on what works in OBNC for now. Once I have a clear set of modules then I can revisit portability to other compilers.\n\nWhat modules do I think I need? If I look at my person projects I tend to work allot with text, often structured text (e.g. XML, JSON, CSV). I also tend to be working with network services. Occasionally I need to interact with database (e.g. SQLite3, MySQL, Postgres).  Artemis should provide modules to make it easy to write code in Oberon-07 that works in those areas. Some of that I can do by wrapping existing C libraries. Some I can simply write from scratch in Oberon-07 (e.g. a JSON encoder/decoder). That's going to me my focus as my hobby time becomes available and then.\n\n\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "copyright": "copyright (c) 2022, R. S. Doiel",
        "date": "2022-07-27",
        "keywords": [
          "Oberon",
          "Oberon-07",
          "Artemis"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "number": 22,
        "series": "Mostly Oberon",
        "title": "Artemis Project Status, 2022"
      },
      "url": "posts/2022/07/27/Artemis-Status-Summer-2022.json"
    },
    {
      "content": "\nTurbo Oberon, the dream\n=======================\n\nby R. S. Doiel, 2022-07-30\n\nSometimes I have odd dreams and that was true last night through early this morning. The dream was set in the future. I was already retired. It was a dream about \"Turbo Oberon\".\n\n\"Turbo Oberon\" was an Oberon language. The language compiler was named \"TO\" in my dream. A module's file extension was \".tom\", in honor of Tom Lopez (Meatball Fulton) of ZBS. There were allot of ZBS references in the dream.\n\n\"TO\" was very much a language in the Oberon-07 tradition with minor extensions when it came to bringing in modules. It allowed for a multi path search for module names. You could also express a Module import as a string allowing providing paths to the imported module.\n\nCompilation was similar to Go. Cross compilation was available out of the box by setting a few environment variables. I remember answering questions about the language and its evolution. I remember mentioning in the conversation about how I thought Go felling into the trap of complexity like Rust or C/C++ before it. The turning point for Go was generics. Complexity was the siren song to be resisted in \"Turbo Oberon\". Complexity is seductive to language designers and implementers. I was only an implementer.\n\nEvolution wise \"TO\" was built initially on the Go tool chain. As a result it featured easily cross-compiled binaries and had a rich standard set of Modules like Go but also included portable libraries for implementing graphic user interfaces. \"Turbo Oberon\" evolved as a conversation between Go and the clean simplicity of Oberon-07. Two example applications \"shipped\" with the \"TO\" compiler. They were an Oberon like Operating System (stand alone and hosted) and a Turbo Pascal like IDE. The IDE was called \"toe\" for Turbo Oberon Editor. I don't remember the name of the OS implementation but it might have been \"toos\". I remember \"TO\" caused problems for search engines and catalog systems.\n\nI remember remarking in the dream that programming in \"Turbo Oberon\" was a little like returning to my roots when I first learned to program in Turbo Pascal. Except I could run my programs regardless of the operating system or CPU architecture. \"\"TO\" compiler supported cross compilation for Unix, macOS, Windows on ARM, Intel, RISC-V. The targets were inherited from Go implementation roots.\n\nIn my dream I remember forking Go 1.18 and first replacing the front end of the compiler. I remember it was a challenge understanding the implementation and generate a Go compatible AST. The mapping between Oberon-07 and Go had its challenges. I remember first sticking to a strict Oberon-07 compiler targeting POSIX before enhancing module imports. I remember several failed attempts at getting module imports \"right\". I remember being on the fence about a map data type and going with a Maps module.  I don't remember how introspection worked but saying it was based on an ETH paper for Oberon 2.  I remember the compiler, like Go, eventually became self hosting. It supported a comments based DSL to annotating RECORD types making encoding and decoding convenient, an influence of Go and it's tool chain.\n\nI believe the \"Turbo Oberon Editor\" came first and that was followed by the operating system implementation.\n\nI remember talking about a book that influenced me called, \"Operating Systems through compilers\" but don't know who wrote it. I remember a discussion about the debt owed to Prof. Wirth. I remember that the book showed how once you really understood building the compile you could then build the OS. There was a joke riffing on the old Lisp joke but rephrased, \"all applications evolve not to a Lisp but to an embedded OS\".\n\nIt was a pleasant dream, in the dream I was older and already retired but still writing \"TO\" code and having fun with computers. I remember a closing video shot showing me typing away at what looked like the old Turbo Pascal IDE. As Mojo Sam said in **Somewhere Next Door to Reality**, \"it was a sorta a retro future\".\n",
      "data": {
        "author": "rsdoiel@gmail.com (R. S. Doiel)",
        "byline": "R. S. Doiel",
        "copyright": "copyright (c) 2020, R. S. Doiel",
        "date": "2022-07-30",
        "keywords": [
          "Oberon",
          "Wirth",
          "ETH",
          "dreams",
          "compilers",
          "operating systems"
        ],
        "license": "https://creativecommons.org/licenses/by-sa/4.0/",
        "title": "Turbo Oberon, the dream"
      },
      "url": "posts/2022/07/30/Turbo-Oberon.json"
    }
  ]
}