<!doctype html>
<html lang="en-US">
<head>
  <meta charset="utf-8" >
  <meta name="generator" content="antenna/0.0.15" >
  <meta name="date" content="2025-10-14T22:33:29-07:00" >
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
  <meta name="language" content="EN" >
  <title>R. S. Doiel, Software Engineer/Analyst &mdash; Robert's ramblings</title>
  <link rel="altenate" type="text/markdown" title="R. S. Doiel, Software Engineer/Analyst &mdash; Robert's ramblings" href="Simplifying_BlogIt.md" >
  <link rel="stylesheet" type="text/css" href="/css/site.css" >
  <link rel="alternate" title="Recent Blog Post" type="application/rss+xml" href="index.xml" >
  <link rel="alternate" title="Archive of Blog Posts" type="application/rss+xml" href="archive.xml" >
  <link rel="alternate" title="Markdown source for page" type="application/markdown" href="index.md" >
  <link rel="search" type="application/opensearchdescription+xml" title="Robert's Rambling Search Engine" href="osd.xml" >
  <script type="module" src="/modules/copyToClipboard.js" ></script>
</head>
<body>
  <nav>
    <ul>
    <li><a href="/" title="R. S. Doiel"><img class="blog-logo" src="/media/Wee-Free-Doiels-Summer-Reading.svg" alt="Wee Free Doiels, Summer Reading"></a></li>
    <li><a href="/">R. S. Doiel</a></li>
    <li><a href="/about.html">About</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/presentations.html">Presentations</a></li>
    <li><a href="/series/">Series</a></li>
    <li><a href="/search.html">Search</a></li>
    <li><a href="https://github.com/rsdoiel">GitHub</a></li>
    <li><a href="/rss.xml" title="RSS Feed">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9"></path>
    <path d="M4 4a16 16 0 0 1 16 16"></path>
    <circle cx="5" cy="19" r="1"></circle> </svg> RSS </a></li>
    </ul>
  </nav>

  <section>
    <article data-published="2025-07-21" data-link="https://rsdoiel.github.io/blog/2025/07/21/Simplifying_BlogIt.html">
      <h1>Simplifying BlogIt</h1>
      <p>By R. S. Doiel, 2025-07-21</p>
      <p>NOTE: This post was updated to include minor bug fixes, RSD 2025-07-28.</p>
      <p><strong>BlogIt</strong> is a command I've written many times over the years. Previously it was intended to perform two tasks.</p>
      <ol>
      <li>Copy CommonMark documents into a blog directory tree</li>
      <li>Aggregate metadata from the document for my blog</li>
      </ol>
      <p>I am updating the way my website and blog are is built. I am adopting <a href="https://flatlake.app">FlatLake</a> for fulfill the role of aggregator. This changes the role <strong>BlogIt</strong> plays.  Since I am relying on an off the shelf tool to perform front matter aggregation it becomes more important to make the front matter consist. The new priorities for <strong>BlogIt</strong> are.</p>
      <ol>
      <li>Curating the front matter of the CommonMark document</li>
      <li>When ready to publish, update the front matter and Copy CommonMark document into the blog directory tree</li>
      </ol>
      <p>With curating front matter the priority some additional features will be helpful.</p>
      <ul>
      <li>check a file for well formed front matter with the minimum field requirements</li>
      <li>check directories for CommonMark documents and their front matter</li>
      </ul>
      <h2>BlogIt command line</h2>
      <p>Here's what that might look like on the command line.</p>
      <pre><code class="language-shell">blogit [OPTIONS] ACTION COMMONMARK_FILE [DATE_OF_POST]
      </code></pre>
      <h2>OPTIONS</h2>
      <ul>
      <li>help</li>
      <li>version</li>
      <li>license</li>
      <li>prefix BLOG_BASE_PATH (to set an explicit path to the &quot;blog&quot; directory)</li>
      </ul>
      <h2>ACTION</h2>
      <p>The following actions need to be supported in the new implementation.</p>
      <ul>
      <li>check COMMONMARK_FILE | DIRECTORY
      <ul>
      <li>validate the front matter in a file or directory of CommonMark documents</li>
      </ul>
      </li>
      <li>draft
      <ul>
      <li>set the front matter draft attribute to true, clear the published date</li>
      </ul>
      </li>
      <li>edit COMMONMARK_FILE [FRONT_MATTER_FIELD ...]
      <ul>
      <li>edit all or a subset of standard front matter fields</li>
      </ul>
      </li>
      <li>publish COMMONMARK_FILE
      <ul>
      <li>read front matter</li>
      <li>set draft to false</li>
      <li>set publish date and update modified date</li>
      <li>validate front matter</li>
      <li>on success, save the updates then copy into blog directory tree
      <ul>
      <li>prompt if it will overwrite a file</li>
      </ul>
      </li>
      </ul>
      </li>
      </ul>
      <h2>Editing front matter</h2>
      <p><strong>BlogIt</strong> is a terminal application. The programs scans the source CommonMark file for existing front matter. For each expected element the current (or default) value of the element is displayed with a prompt to edit it. If editing is chosen then the value is presented in the default editor for update. The saved value is then used to update the front matter element. A temporary file is used to communicate between <strong>BlogIt</strong> and the system provided text editor.</p>
      <p>Complex fields like keywords are provided to the text edit as YAML. The default should show the desired structure as YAML with placeholder values to be edited.</p>
      <h2>Front Matter</h2>
      <p>The basic front matter I want to use is straight forward as my blog started almost a decade ago. Essentially it is title, author, abstract, dateCreated, dateModified, datePublished and keywords. Some blog items have a series name and number so I will support those fields as well.</p>
      <p><strong>BlogIt</strong> will be written in TypeScript this time. I can cover my bases with the following interfaces.</p>
      <pre><code class="language-TypeScript">/* This describes the front matter metadata object */
      interface Metadata {
          title: string; /* Optional because they are optional in RSS 2 */
          author: string;
          abstract: string; /* Maps to description in RSS 2 */
          dateCreated: string; /* ISO 8601 date */
          dateModified: string; /* ISO 8601 date */
          datePublished?: string; /* ISO 8601 date */
          draft?: boolean /* if true then BlogIt processes document as a draft */
          keywords?: string[];
          series?: string;
          seriesNo?: number;
          copyrightYear?: string; /* Four digit year */
          copyrightHolder?: string;
          license?: string; /* Text of license or a URL pointing at the license */
      }
      </code></pre>
      <p>BlogIt expectations</p>
      <ul>
      <li>working directory contains a directory called &quot;blog&quot; (this is customary but not always the place the blog resides)
      <ul>
      <li>An explicit blog directory can be set using the <code>prefix</code> option</li>
      </ul>
      </li>
      <li>The directory structure is formed as <code>&lt;prefix&gt;/&lt;YEAR&gt;/&lt;MONTH&gt;/&lt;DAY&gt;</code> where year is four digits, month and day are two digits (zero padded).</li>
      <li>the default date is today, may explicitly be provided by the front matter as <code>.datePublished</code></li>
      <li>the date fields automatically supported are <code>dateCreated</code>, <code>dateModified</code> and <code>datePublished</code>. The <code>dateModified</code> should be updated automatically each time <strong>BlogIt</strong> changes the document. <code>dateCreated</code> is set the first time the front matter is created or edited.  <code>datePublished</code> is set the first time the CommonMark document  is &quot;published&quot; into the blog directory tree. This also results in the draft field being removed.</li>
      </ul>
      <p>Recursive blog maintenance could be supported by allowing the tool to walk a directory tree and when it encounters CommonMark documents the front matter is validate. Errors are written to standard out. This feature would ensure that the CommonMark documents are ready for processing by the website build process.</p>
      <h2>Checking for Front Matter</h2>
      <p>Front Matter traditionally is found at the start of the CommonMark file. It starts with the a line matching <code>---</code> and terminates with same <code>---</code> line. Anything between the two is treated as YAML.  Checking the front matter means identifying the YAML source, parsing it and comparing the result with the interface definition. If an expected field is missing then prompt for it and if the response is &quot;y&quot; create a temp file of the content and invoke a default editor for the system. When the editor is exited the source is read back in and the front matter is updated.</p>
      <h2>Processing the Front Matter</h2>
      <p>Aside from extracting the YAML front matter from the text, the standard Deno library (<code>@std/yaml</code>) can be used to populate the interface for validation and editing.</p>
      <p>The task for <strong>BlogIt</strong> is primarily orchestrating the use of existing Deno TypeScript modules implementing the functionality I want from <strong>BlogIt</strong>.</p>
      <h2>Rewriting the CommonMark document</h2>
      <p>If the front matter changes then the CommonMark document should be written to a backup file (e.g. &quot;.bak&quot;). If changes are made the interface should prompt before saving the backup and writing out the updates to the source CommonMark document.</p>
      <h2>Draft versus datePublished</h2>
      <p>If the front matter includes the value <code>draft: true</code> <strong>BlogIt</strong> will exit after updating the front matter.  If <code>draft: true</code> is not in the front matter (e.g. <code>draft: false</code> or doesn't exist), the value  of <code>datePublished</code> needs to be set to the current date if not already populated. The <code>datePublished</code> is used to calculate the target path for coping the CommonMark document.</p>
      <p>The action &quot;draft&quot; will set the <code>draft</code> value to <code>true</code> and clear <code>datePublished</code>.</p>
      <p>The action &quot;publish&quot; will remove the <code>draft</code> attribute setting the publication and modification dates. If the front matter is valid then it will save the updated metadata and proceed to copy the revised CommonMark document into the blog tree.</p>
      <h2>The Program</h2>
      <h3>editor module</h3>
      <p>Calling out to the system's text editor and running the editor as a sub process should be implemented as it's own module. This will allow me to improve the process independently and potentially use it in other applications.</p>
      <pre><code class="language-TypeScript">/**
       * editor.ts module handles the setup and access to a text editor for updating front matter. It is part of BlogIt program.
       *
       *  Copyright (C) 2025  R. S. Doiel
       * 
       *  This program is free software: you can redistribute it and/or modify
       *  it under the terms of the GNU Affero General Public License as
       *  published by the Free Software Foundation, either version 3 of the
       *  License, or (at your option) any later version.
       *
       *  This program is distributed in the hope that it will be useful,
       *  but WITHOUT ANY WARRANTY; without even the implied warranty of
       *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       *  GNU Affero General Public License for more details.
       *
       *  You should have received a copy of the GNU Affero General Public License
       *  along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
       */
      import { exists } from '@std/fs/exists';
      
      /**
       * pickEditor
       * @return string
       */
      function pickEditor(): string {
        let editor: string | undefined = Deno.env.get(&quot;EDITOR&quot;);
        if (editor === undefined) {
          if (Deno.build.os === &quot;windows&quot;) {
            editor = &quot;notepad.exe&quot;;
          } else {
            editor = &quot;nano&quot;;
          }
        }
        return editor as string;
      }
      
      export function getEditorFromEnv(envVar?: string): string {
        const editor: string | undefined = (envVar === undefined)
          ? undefined
          : Deno.env.get(envVar);
        if (editor === undefined) {
          return pickEditor();
        }
        return editor as string;
      }
      
      // editor.ts assumes Micro Editor in order to simplify testing.
      const editor: string = pickEditor();
      
      // editFile takes an editor name and filename. It runs the editor using the
      // filename (e.g. micro, nano, code) and returns success or failure based on
      // the the exit status code. If the exit statuss is zero then true is return,
      // otherwise false is returned.
      export async function editFile(
        editor: string,
        filename: string,
      ): Promise&lt;{ ok: boolean; text: string }&gt; {
        const command = new Deno.Command(editor, {
          args: [filename],
          stdin: &quot;inherit&quot;,
          stdout: &quot;inherit&quot;,
          stderr: &quot;inherit&quot;,
        });
        const child = command.spawn();
        const status = await child.status;
        if (status.success) {
          const txt = await Deno.readTextFile(filename);
          return { ok: status.success, text: txt };
        }
        return { ok: status.success, text: &quot;&quot; };
      }
      
      // editTempData will take data in string form, write it
      // to a temp file, open the temp file for editing and
      // return the result. If a problem occurs then an undefined
      // value is returns otherwise is the contents of the text file
      // as a string.
      export async function editTempData(val: string): Promise&lt;string&gt; {
        const tmpFilename = await Deno.makeTempFile({
          dir: &quot;./&quot;,
          prefix: &quot;blogit_&quot;,
          suffix: &quot;.tmp&quot;,
        });
        if (val !== &quot;&quot;) {
          await Deno.writeTextFile(tmpFilename, val);
        }
        const res = await editFile(editor, tmpFilename);
        if (await exists(tmpFilename, {isFile: true})) {
          await Deno.remove(tmpFilename);
        }
        if (res.ok) {
          // NOTE: string is returned via standard out not the text of the file.
          return res.text;
        }
        return val;
      }
      
      </code></pre>
      <h3>Front Matter</h3>
      <p>The front matter handling is implemented as it's own TypeScript module, <code>frontMatter.ts</code>. This module defines all the front matter schema and the operations that maybe performed on it including the interactive prompts.</p>
      <pre><code class="language-TypeScript">/**
       * frontMatterEditor.ts module curates front matter for Common Mark or Markdown documents. It is part of the BlogIt project. 
       * 
       *  Copyright (C) 2025  R. S. Doiel
       * 
       *  This program is free software: you can redistribute it and/or modify
       *  it under the terms of the GNU Affero General Public License as
       *  published by the Free Software Foundation, either version 3 of the
       *  License, or (at your option) any later version.
       *
       *  This program is distributed in the hope that it will be useful,
       *  but WITHOUT ANY WARRANTY; without even the implied warranty of
       *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       *  GNU Affero General Public License for more details.
       *
       *  You should have received a copy of the GNU Affero General Public License
       *  along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
       */
      import { parse, stringify } from &quot;@std/yaml&quot;;
      import { CommonMarkDoc } from &quot;./commonMarkDoc.ts&quot;;
      import { editTempData } from &quot;./editor.ts&quot;;
      
      export const metadataFields: Array&lt;keyof Metadata&gt; = [
        &quot;title&quot;,
        &quot;author&quot;,
        &quot;contributor&quot;,
        &quot;abstract&quot;,
        &quot;draft&quot;,
        &quot;dateCreated&quot;,
        &quot;dateModified&quot;,
        &quot;datePublished&quot;,
        &quot;keywords&quot;,
        &quot;series&quot;,
        &quot;seriesNo&quot;,
        &quot;copyrightYear&quot;,
        &quot;copyrightHolder&quot;,
        &quot;license&quot;
      ];
      
      
      export interface Metadata {
        title?: string;
        author: string;
        contributor?: string;
        abstract: string;
        dateCreated: string;
        dateModified: string;
        datePublished?: string;
        draft?: boolean;
        keywords?: string[];
        series?: string;
        seriesNo?: number;
        pubType?: string;
        copyrightYear?: number;
        copyrightHolder?: string;
        license?: string | URL;
      }
      
      
      function yyyymmdd(s: string): boolean {
        const dateFormatRegex = /^\d{4}-\d{2}-\d{2}$/;
        return dateFormatRegex.test(s);
      }
      
      function assignValue&lt;T extends keyof Metadata&gt;(
        frontMatter: Record&lt;string, unknown&gt;,
        field: T,
        newValue: string,
      ) {
        let seriesNo = 0;
        if (newValue.trim() === '') {
          delete frontMatter[field];
          return;
        }
        switch (field) {
          case &quot;abstract&quot;:
            frontMatter[field] = newValue;
            break;
          case &quot;draft&quot;:
            if (newValue.toLowerCase() === &quot;true&quot;) {
              frontMatter[field] = true;
            }
            break;
          case &quot;keywords&quot;:
            frontMatter[field] = parse(newValue);
            //FIXME: if there are no keywords then we could remove the field
            break;
          case &quot;series&quot;:
            frontMatter[field] = newValue;
            break;
          case &quot;seriesNo&quot;:
            seriesNo = Number(newValue) || 0;
            if (seriesNo &gt; 0) {
              frontMatter.seriesNo = seriesNo;
            } else {
              delete frontMatter.seriesNo;
            }
            break;
          case &quot;copyrightYear&quot;:
            if (newValue.trim() === '') {
              delete frontMatter.copyrightYear;
            } else {
              frontMatter[field] = Number(newValue);
            }
            break;
          case &quot;dateCreated&quot;:
          case &quot;dateModified&quot;:
          case &quot;datePublished&quot;:
            if (newValue.trim() !== '' &amp;&amp; yyyymmdd(newValue.trim())) {
              frontMatter[field] = newValue.trim();
              delete frontMatter['draft'];
            } else {
              delete frontMatter[field];
            }
            break;
          default:
            frontMatter[field] = newValue.trim();
            break;
        }
      }
      
      function getDefaultValueAsString(frontMatter: Record&lt;string, unknown&gt;, field: string): string {
        switch (field) {
          case &quot;draft&quot;:
      	  if (frontMatter.datePublished === undefined || frontMatter.datePublished === null || frontMatter.datePublished === '') {
            	//NOTE: The default value is draft === true
            	return &quot;true&quot;;
      	  }
      	  return '';
          case &quot;dateCreated&quot;:
          case &quot;dateModified&quot;:
            return (new Date()).toISOString().split(&quot;T&quot;)[0];
          default:
            return &quot;&quot;;
        }
      }
      
      function getAttributeAsString(
        frontMatter: Record&lt;string, unknown&gt;,
        field: string,
      ): string {
        if (frontMatter[field] === undefined) {
          return '';
        }
        switch (field) {
          case &quot;keywords&quot;:
            return stringify(frontMatter[field]);
          case &quot;seriesNo&quot;:
          case &quot;copyrightYear&quot;:
          case &quot;draft&quot;:
            return `${frontMatter[field]}`;
        }
        return frontMatter[field] as string;
      }
      
      async function promptToEditFields(
        cmarkDoc: CommonMarkDoc,
        fields: Array&lt;keyof Metadata&gt;,
      ) {
        let keys = metadataFields;
        if (fields.length &gt; 0) {
          keys = fields;
        }
      
        let changed = false;
        for (const key of keys) {
          // dateModified gets updated when the changed record is saved. We can skip it.
          if (key === 'dateModified') {
            continue
          }
          if (cmarkDoc.frontMatter[key] === undefined) {
            assignValue(cmarkDoc.frontMatter, key, getDefaultValueAsString(cmarkDoc.frontMatter, key));
          }
          // NOTE: draft and pub date are connected. A draft can't have a datePublished
          if (key === 'draft' &amp;&amp; cmarkDoc.frontMatter.draft)  {
            delete cmarkDoc.frontMatter.datePublished;
          }
          // NOTE: Need to handle the case where draft has been set to false and a pub date is not yet set.
          // It should default to today like dateCreated and dateModified do.
          if (key === 'datePublished' &amp;&amp; cmarkDoc.frontMatter.datePublished === '') {
            if (cmarkDoc.frontMatter.draft === undefined || cmarkDoc.frontMatter.draft === false) {
              cmarkDoc.frontMatter.datePublished = (new Date()).toISOString().split(&quot;T&quot;)[0];
            }
          }
          // NOTE: we need to display the value in string form to prompt for editing.
          let val: string = getAttributeAsString(cmarkDoc.frontMatter, key);
          if (confirm(`${key}:\n${val}\nedit ${key}?`)) {
            const oldVal = val;
            //FIXME: call the editor to edit the value then convert it back usign assignValue
            val = await editTempData(val);
            if (oldVal !== val) {
              changed = true;
              assignValue(cmarkDoc.frontMatter, key, val);
            }
          }
        }
        cmarkDoc.changed = changed;
        // Make sure that date modified is updated on change
        if (cmarkDoc.changed &amp;&amp; cmarkDoc.frontMatter !== undefined &amp;&amp; cmarkDoc.frontMatter.dateModified !== &quot;&quot;) {
          cmarkDoc.frontMatter.dateModified = (new Date()).toISOString().split(&quot;T&quot;)[0];
        }
      }
      
      export async function editFrontMatter(
        cmarkDoc: CommonMarkDoc,
        fields: Array&lt;keyof Metadata&gt;,
      ) {
        await promptToEditFields(cmarkDoc, fields);
      }
      
      export function applyDefaults(cmarkDoc: CommonMarkDoc, defaults: Record&lt;string, unknown&gt;) {
        for (const k of Object.keys(defaults)) {
          switch (cmarkDoc.frontMatter[k]) {
            case undefined:
              cmarkDoc.frontMatter[k] = defaults[k];
              cmarkDoc.changed = true;
              break;
            case null:
              cmarkDoc.frontMatter[k] = defaults[k];
              cmarkDoc.changed = true;
              break;
            case '':
              cmarkDoc.frontMatter[k] = defaults[k];
              cmarkDoc.changed = true;
              break;
            case 0:
              cmarkDoc.frontMatter[k] = defaults[k];
              cmarkDoc.changed = true;
              break;
          }
        }
      }
      
      </code></pre>
      <h3>CommonMark module</h3>
      <p>My website is implemented using CommonMark documents that include front matter. It is helpful to be able to handle the documents
      in a uniform way. This is accomplished through a TypeScript module called <code>commonMarkDoc.ts</code>.  It defines an interface, <code>CommonMarkDoc</code> that contains three attributes, <code>frontMatter</code>, <code>markdown</code> and <code>changed</code>. The latter is a boolean flag that is set when something changes in either <code>frontMatter</code> or <code>markdown</code>.</p>
      <p>The module also supports an Object called CMarkDoc that include a pre-processor function called <code>process</code> providing two useful features.</p>
      <ul>
      <li>mapping of &quot;.md&quot; file links to &quot;.html&quot; file links</li>
      <li>including code blocks from external files</li>
      </ul>
      <pre><code class="language-TypeScript">/**
       * commonMarkDoc.ts is a module for handling CommomMark and Markdown documents with front matter.
       * It is part of the BlogIt project.
       * 
       *  Copyright (C) 2025  R. S. Doiel
       * 
       *  This program is free software: you can redistribute it and/or modify
       *  it under the terms of the GNU Affero General Public License as
       *  published by the Free Software Foundation, either version 3 of the
       *  License, or (at your option) any later version.
       *
       *  This program is distributed in the hope that it will be useful,
       *  but WITHOUT ANY WARRANTY; without even the implied warranty of
       *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       *  GNU Affero General Public License for more details.
       *
       *  You should have received a copy of the GNU Affero General Public License
       *  along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
       */
      import { parse, stringify } from &quot;@std/yaml&quot;;
      
      export interface CommonMarkDoc {
        frontMatter: Record&lt;string, unknown&gt;;
        markdown: string;
        changed: boolean;
      }
      
      /**
       * stringToCommonMarkDoc takes a string and splits it into a record with frontmatter and markdown
       * @param content string, the text string to transform into a CommonMarkDoc type.
       * @return `{frontMatter: Record&lt;string, unknown&gt;; markdown: string }`
       */
      export function stringToCommonMarkDoc(
        content: string,
      ): CommonMarkDoc {
        const frontMatterRegex = /^---([\s\S]+?)---/;
        const match = content.match(frontMatterRegex);
        let frontMatter: Record&lt;string, unknown&gt; = {};
        let markdown: string = content;
        if (match) {
          frontMatter = parse(match[1]) as Record&lt;string, unknown&gt;;
          markdown = content.slice(match[0].length).trim();
        }
        return { frontMatter: frontMatter, markdown: markdown, changed: false };
      }
      
      /**
       * commonMarkDocToString takes a CommonMarkDoc object and renders it into string prefixed by the front matter block.
       * @param cmarkDoc CommonMarkDoc
       * @return string
       */
      export function commonMarkDocToString(
        cmarkDoc: CommonMarkDoc,
      ): string {
        if (Object.keys(cmarkDoc.frontMatter).length &gt; 0) {
          return `---
      ${stringify(cmarkDoc.frontMatter)}---
      
      ${cmarkDoc.markdown}`;
        }
        return cmarkDoc.markdown;
      }
      
      /**
       * commonMarkDocPreprocessor takes a CommonMarkDoc object and maps the &quot;.md&quot; links to &quot;.html&quot; links
       * and includes code blocks using the `@include-code-block` directive.
       *
       * @param cmarkDoc: CommmonMarkDoc
       * @return string
       */
      export function commonMarkDocPreprocessor(
        cmarkDoc: CommonMarkDoc,
      ): string {
            // Convert markdown links to HTML links
          const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+\.md)\)/g;
          let processedMarkdown = cmarkDoc.markdown.replace(markdownLinkRegex, (_fullMatch, linkText, filePath) =&gt; {
            const htmlFilePath = filePath.replace(/\.md$/, '.html');
            return `[${linkText}](${htmlFilePath})`;
          });
      
          // include code blocks from external files
          const insertCodeBlockRegex = /@include-code-block\s+([^\s]+)(?:\s+(\w+))?/g;
          processedMarkdown = processedMarkdown.replace(insertCodeBlockRegex, (_fullMatch, filePath, language = '') =&gt; {
            let fileContent = '';
            try {
              fileContent = Deno.readTextFileSync(filePath);
            } catch (error) {
              return `Error reading ${filePath}, ${error}`;
            }
            if (fileContent !== '') {
              return `~~~${language}\n${fileContent}\n~~~`;
            } else {
              return `Error inserting block from ${filePath}`;
            }
          });
          // include code blocks from external files
          const insertTextBlockRegex = /@include-text-block\s+([^\s]+)(?:\s+(\w+))?/g;
          processedMarkdown = processedMarkdown.replace(insertTextBlockRegex, (_fullMatch, filePath, language = '') =&gt; {
            let fileContent = '';
            try {
              fileContent = Deno.readTextFileSync(filePath);
            } catch (error) {
              return `Error reading ${filePath}, ${error}`;
            }
            if (fileContent !== '') {
              return fileContent;
            } else {
              return `Error inserting block from ${filePath}`;
            }
          });
          if (processedMarkdown !== cmarkDoc.markdown) {
            return commonMarkDocToString({
                frontMatter: cmarkDoc.frontMatter,
                markdown: processedMarkdown,
                changed: true
            });
          }
          return commonMarkDocToString(cmarkDoc);
      }
      
      /**
       * CMarkDoc implements the interface CommonMarkDoc
       * It supports working with CommonMark documents that contain front matter
       */
      export class CMarkDoc implements CommonMarkDoc {
        frontMatter: Record&lt;string, unknown&gt; = {};
        markdown: string = '';
        changed: boolean = false;
      
        /**
         * parse takes a string hold CommonMark text and parses it into the CMarkDoc object structure.
         */
        parse(src: string): boolean {
          const cmarkDoc: CommonMarkDoc = stringToCommonMarkDoc(src);
          this.frontMatter = cmarkDoc.frontMatter;
          this.markdown = cmarkDoc.markdown;
          return (this.markdown.length &gt; 0);
        }
        
        /**
         * stringify takes this object and returns a CommonMark representation including front matter.
         */
        stringify(): string {
          return commonMarkDocToString(this);
        }
      
        /**
         * processSync is a CommonMark pre-processor implementing two features. It performs two
         * fucntions.
         *   1. converts links to markdown files (ext. &quot;.md&quot;) to their HTML file counter parts
         *   2. Any `@include-code-block` will include a source code file block in the resulting
         *      source document.
         */
        processSync(): string {
          return commonMarkDocPreprocessor(this);
        }
      }
      
      
      </code></pre>
      <h3>Main</h3>
      <p>The main module, <code>mod.ts</code>, will allow for processing the command line option and performing the requested actions.</p>
      <pre><code class="language-TypeScript">/**
       * mod.ts - The main entry point for BlogIt, a Common Mark front matter validator and curation tool. It is part of the BlogIt project.
       *
       *  Copyright (C) 2025  R. S. Doiel
       * 
       *  This program is free software: you can redistribute it and/or modify
       *  it under the terms of the GNU Affero General Public License as
       *  published by the Free Software Foundation, either version 3 of the
       *  License, or (at your option) any later version.
       *
       *  This program is distributed in the hope that it will be useful,
       *  but WITHOUT ANY WARRANTY; without even the implied warranty of
       *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       *  GNU Affero General Public License for more details.
       *
       *  You should have received a copy of the GNU Affero General Public License
       *  along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
       */
      // mod.ts
      import { parse as parseArgs } from &quot;@std/flags&quot;;
      import { exists } from &quot;@std/fs/exists&quot;;
      import * as yaml from &quot;@std/yaml&quot;;
      import { checkDirectory, checkFile, createBackup, publishFile, showFrontMatter } from &quot;./src/blogit.ts&quot;;
      import { Metadata, editFrontMatter, applyDefaults } from &quot;./src/frontMatter.ts&quot;;
      import {
        CommonMarkDoc,
        commonMarkDocPreprocessor,
        commonMarkDocToString,
        stringToCommonMarkDoc,
      } from &quot;./src/commonMarkDoc.ts&quot;;
      import { licenseText, releaseDate, releaseHash, version } from &quot;./version.ts&quot;;
      import { helpText, fmtHelp } from &quot;./helptext.ts&quot;;
      
      async function main() {
        const appName = 'BlogIt';
        const args = parseArgs(Deno.args, {
          boolean: [&quot;help&quot;, &quot;version&quot;, &quot;license&quot;, &quot;draft&quot;, &quot;check&quot;, &quot;edit&quot;, &quot;publish&quot;, &quot;process&quot;, &quot;show&quot; ],
          string: [&quot;prefix&quot;, &quot;apply&quot;],
          alias: {
            h: &quot;help&quot;,
            v: &quot;version&quot;,
            l: &quot;license&quot;,
            a: &quot;apply&quot;,
            p: &quot;prefix&quot;,
            c: &quot;check&quot;,
            d: &quot;draft&quot;,
            e: &quot;edit&quot;,
            P: &quot;process&quot;,
            s: &quot;show&quot;,
          },
          default: {
            prefix: &quot;blog&quot;,
            apply: &quot;&quot;,
          },
        });
      
        if (args.help) {
          console.log(
            fmtHelp(helpText, appName, version, releaseDate, releaseHash)
          );
          Deno.exit(0);
        }
      
        if (args.version) {
          console.log(`${appName} ${version} ${releaseDate} ${releaseHash}`);
          Deno.exit(0);
        }
      
        if (args.license) {
          console.log(licenseText);
          Deno.exit(0);
        }
      
        // Handle verb commands without dash prefix.
        switch (args._[0] as string) {
          case &quot;apply&quot;:
            // Shift &quot;apply&quot; off the args, then assign the value from the next parameter
            args._.shift();
            if (args._[0] !== undefined) {
              args.apply = args._.shift() as string;
            } else {
              console.error(`Missing defaults YAML filename`);
              Deno.exit(1);
            }
            break;
          case &quot;check&quot;:
            args.check = true;
            args._.shift();
            break;
          case &quot;edit&quot;:
            args.edit = true;
            args._.shift();
            break;
          case &quot;draft&quot;:
            args.draft = true;
            args._.shift();
            break;
          case &quot;process&quot;:
            args.process = true;
            args._.shift();
            break;
          case &quot;publish&quot;:
            args.publish = true
            args._.shift();
            break;
          case &quot;show&quot;:
            args.show = true
            args._.shift();
            break;
        }
      
        const filePath = args._[0] as string; // Explicitly assert filePath as string
        const dateOfPost = args._[1] as string | undefined; // Explicitly assert dateOfPost as string or undefined
      
        if (args.check) {
          if (await exists(filePath, {isDirectory: true})) {
            console.log(`Checking the directory ${filePath}`);
            await checkDirectory(filePath);
          }
          if (await exists(filePath, { isFile: true})) {
            console.log(`Checking the file ${filePath}`);
            await checkFile(filePath)
          }
          Deno.exit(0);
        }
      
      
        if (!filePath) {
          console.error(&quot;No file specified.&quot;);
          Deno.exit(1);
        }
      
        // Make sure file exists and is readable before proceeding.
        if (!await exists(filePath, { isFile: true, isReadable: true })) {
          console.error(`Cannot find ${filePath}`);
          Deno.exit(1);
        }
      
        const content = await Deno.readTextFile(filePath);
        const cmarkDoc: CommonMarkDoc = stringToCommonMarkDoc(content);
      
        if (args.draft || args.edit || args.apply !== &quot;&quot;) {
          // Set to draft is args.draft is true
          if (args.draft) {
            if (cmarkDoc.frontMatter.draft === false) {
              cmarkDoc.frontMatter.draft = true;
              delete cmarkDoc.frontMatter.datePublished;
              cmarkDoc.changed = true;
            }
          }
      
          // Apply defaults if requested
          if (args.apply !== &quot;&quot;) {
            const data = await Deno.readTextFile(args.apply);
            const dafaults: Record&lt;string, unknown&gt; = yaml.parse(data) as Record&lt;string, unknown&gt;;
            applyDefaults(cmarkDoc, dafaults);
          }
      
          // if args.edit then edit the front matter
          if (args.edit) {
            const fields = args._.slice(1) as Array&lt;keyof Metadata&gt;; // Explicitly assert fields as string array
            await editFrontMatter(cmarkDoc, fields);
          }
      
        	// Display the front matter
          showFrontMatter(cmarkDoc);
          // NOTE: either edit or draft setting caused a change, backup, write it out and exit
          if (cmarkDoc.changed) {
            if (confirm(`save ${filePath}?`)) {
              // Backup original file
              await createBackup(filePath);
              // Write output updated version
              await Deno.writeTextFile(filePath, commonMarkDocToString(cmarkDoc));
              console.log(`Wrote ${filePath}`);
            }
          }
          Deno.exit(0);
        }
      
        if (args.show) {
          // Display the front matter
          showFrontMatter(cmarkDoc);
          Deno.exit(0);
        }
      
        if (args.publish) {
          // OK, we must intend to engage the publication process.
          await publishFile(filePath, args.prefix, args.process, dateOfPost);
          Deno.exit(0);
        }
      
        // If args.process then run the preprocessor and write the output to standard out
        if (args.process) {
          let src: string = '';
          try {
            src = commonMarkDocPreprocessor(cmarkDoc);
          } catch (err) {
            console.error(err);
            Deno.exit(1);
          }
          if (src === '') {
            console.error(`no content after preprocessor ran for ${filePath}`)
            Deno.exit(1);
          }
          console.log(src);
          Deno.exit(0);
        }
      }
      
      if (import.meta.main) {
        main().catch(console.error);
      }
      
      </code></pre>
      <h2>Reference</h2>
      <ul>
      <li><a href="https://github.com/rsdoiel/BlogIt">https://github.com/rsdoiel/BlogIt</a></li>
      <li><a href="https://rsdoiel.github.io/BlogIt">Website</a></li>
      </ul>
      
    </article>
  </section>
  <footer>
    <footer>
    <p>copyright © 2016 - 2025 R. S. Doiel<br /> <a
    href="/rssfeed.html">RSS</a> feeds and website built with <a
    href="https://rsdoiel.github.io/antennaApp">antennaApp</a>.
    </footer>
    <script type="module">
      await import('/pagefind/pagefind-highlight.js');
      new PagefindHighlight({ highlightParam: "highlight" });
    </script>
  </footer>
</body>
</html>
