<!doctype html>
<html lang="en-US">
<head>
  <meta charset="UTF-8" />
  <link  rel="alternate" type="text/markdown" href="Mostly-Oberon-Modules.md" title=""/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/css/site.css" />
  <meta name="generator" content="antenna/0.0.6">
  <meta name="date" content="2025-09-15T14:18:49-07:00">
</head>
<body>
  <header>
    (date: 2025-09-15 14:18:49)
  </header>
  <nav>
    <ul>
    <li><a href="/" title="R. S. Doiel"><img class="blog-logo" src="/media/Wee-Free-Doiels-Summer-Reading.svg" alt="Wee Free Doiels, Summer Reading"></a></li>
    <li><a href="/">R. S. Doiel</a></li>
    <li><a href="/about.html">About</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/presentations.html">Presentations</a></li>
    <li><a href="/series/">Series</a></li>
    <li><a href="/search.html">Search</a></li>
    <li><a href="https://github.com/rsdoiel">GitHub</a></li>
    <li><a href="/index.xml" title="RSS, recent posts">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9"></path>
    <path d="M4 4a16 16 0 0 1 16 16"></path>
    <circle cx="5" cy="19" r="1"></circle> </svg> RSS </a></li>
    </ul>
  </nav>

  <section>
    <article data-published="2020-04-12" data-link="https://rsdoiel.github.io/blog/2020/04/12/Mostly-Oberon-Modules.html">
      <h1 id="oberon-modules-and-procedures">Oberon Modules and Procedures</h1>
      <p>By R. S. Doiel, 2020-04-12</p>
      <p>This is the second post in the <a href="../11/Mostly-Oberon.html">Mostly Oberon</a> series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit wholes I inevitably fell into.</p>
      <h2 id="modules">Modules</h2>
      <p>The module is a primary code unit of Oberon language. Modules allow you to focus on functional units of code and can be readily composed into larger solutions.<br />
      A module's name should match the filename you are saving it under. A module starts with declaring it's name and ends the declaration with a semicolon<br />
      the statement separator in Oberon. Our simple &quot;Hello World&quot; example<br />
      shows the basic code shape.</p>
      <pre><code class="language-{.oberon}">
          MODULE HelloWorld;
            IMPORT Out;
          BEGIN
            Out.String(&quot;Hello World!&quot;); Out.Ln;
          END HelloWorld.
      
      </code></pre>
      <p>Modules end with a <code>END</code> followed by the module's name and a period.<br />
      Any text following the <code>END</code> statement is ignored by the compiler. This<br />
      turns out to be very useful as a place to write up ideas about the code<br />
      you're working on. You can also write any additional special instructions<br />
      there (e.g. document usage). You can even use it as a scratch pad knowing<br />
      that the compiler will ignore it.</p>
      <p>Here's an example</p>
      <pre><code class="language-{.oberon}">
          MODULE HelloWorld;
            IMPORT Out;
          BEGIN
            Out.String(&quot;Hello World!&quot;); Out.Ln;
          END HelloWorld.
      
          This program isn't very useful. It has no interactive ability.
          It'd be nice if it could be more specific about who it was saying
          hello to.
      
      </code></pre>
      <p>For a module to be really useful you want to have the capability<br />
      of including both private and public code. Public code<br />
      allows us to reuse our code in other modules while the private code<br />
      keeps internal things inside the module safe from colliding with other<br />
      modules private code. This technique is classically known as<br />
      &quot;information hiding&quot; and in computer sciences texts as &quot;scope&quot;. Lets<br />
      create a a more composable module called <code>SayingHi.Mod</code>.  In<br />
      addition to display &quot;Hello World!&quot; we want a public method<br />
      (procedure in Oberon terminology) that can ask for a name and print<br />
      out a salutation. We will use the <code>SayingHi.Mod</code> module along with<br />
      a newer version of <code>HelloWorld.Mod</code> named <code>HelloWorld2.Mod</code>.</p>
      <h2 id="procedures">Procedures</h2>
      <p>How do we write methods in Oberon?  Methods are declared<br />
      using the keyword <code>PROCEDURE</code> followed by their name, a<br />
      declaration of any parameters and if the procedure returns a<br />
      value (i.e. is a function) it also includes that declaration.<br />
      Next we declare any internal variables needed by the procedure.<br />
      This is followed by the procedure's body.  The body of the<br />
      procedure is defined by a <code>BEGIN</code> and <code>END</code> statement structure.<br />
      The body contains the steps the procedure needs to execute.</p>
      <p>We'll create a procedure called &quot;HelloWorld&quot; in our new module.<br />
      Since we will use this procedure from our new <code>HelloWorld2.Mod</code><br />
      our new &quot;HelloWorld&quot; procedure needs to be public.  A public<br />
      procedure in <code>SayingHi.Mod</code> is available for use in our new<br />
      <code>HelloWorld2.Mod</code> (or by another module).  Marking a procedure<br />
      public in Oberon is a little different than in other languages.<br />
      A Module's procedure is public if its name ends with an asterisk.<br />
      Below is a sketch of our module <code>SayingHi.Mod</code> so far.</p>
      <p>NOTE: This technique is also used to mark variables, records and constants as public and available to other modules. Public variables are &quot;read only&quot; in other modules.</p>
      <pre><code class="language-{.oberon}">
          MODULE SayingHi;
            IMPORT Out;
          
            PROCEDURE HelloWorld*;
            BEGIN
              Out.String(&quot;Hello World!&quot;); Out.Ln;
            END HelloWorld;
          END SayingHi.
      
      </code></pre>
      <p>This modules looks allot like <code>HelloWorld.Mod</code> with a couple key<br />
      differences. Rather than relying on the module's begin and end<br />
      statements we declare a procedure with its own begin and end statements.<br />
      Notice the procedures end statement includes the procedure name and<br />
      is terminated by semicolon rather than a period.  Like <code>HelloWorld.Mod</code><br />
      we import the <code>Out</code> module to display our greeting.</p>
      <h2 id="putting-it-all-together">Putting it all together</h2>
      <p>Let's create a new &quot;Hello World&quot; module called <code>HelloWorld2.Mod</code> and<br />
      use our <code>SayingHi</code> module instead of directly importing <code>Out</code>.</p>
      <pre><code class="language-{.oberon}">
          MODULE HelloWorld2;
            IMPORT SayingHi;
          BEGIN
            SayingHi.HelloWorld;
          END HelloWorld2.
      
      </code></pre>
      <p>We can compile our module with OBNC using the command</p>
      <pre><code>
          obnc HelloWorld2.Mod
      
      </code></pre>
      <p>We can run our new &quot;Hello World&quot; with the command</p>
      <pre><code>
          ./HelloWorld2
      
      </code></pre>
      <p>At this point we have a way of saying &quot;Hello World!&quot; whenever<br />
      we need in our Oberon programs. But just printing &quot;Hello World!&quot;<br />
      to the screen isn't very interactive. It'd be nice if we could<br />
      have the computer ask our name and then respond with a greeting.</p>
      <p>We'll modify our SayingHi to include a new procedure called &quot;Greetings&quot;<br />
      and that procedure needs to ask us our name and then display<br />
      an appropriate greeting. &quot;Greetings&quot; will be a public procedure<br />
      marked by an asterisk like &quot;HelloWorld&quot;.</p>
      <p>&quot;Greetings&quot; has three tasks</p>
      <ol>
      <li>Ask politely for our name</li>
      <li>Get the name typed in with our keyboard</li>
      <li>Assemble and display a polite greeting</li>
      </ol>
      <p>To keep our &quot;Greeting&quot; procedure short we'll split this<br />
      up into some private procedures. These will not be available<br />
      outside <code>SayingHi.Mod</code>. Here's a sketch of our improved module.</p>
      <pre><code class="language-{.oberon}">
          MODULE SayingHi;
            IMPORT In, Out;
          
            PROCEDURE HelloWorld*;
            BEGIN
              Out.String(&quot;Hello World!&quot;); Out.Ln;
            END HelloWorld;
          
            PROCEDURE AskOurName;
            BEGIN
              Out.String(&quot;Excuse me, may I ask your name? &quot;);
            END AskOurName;
          
            PROCEDURE GetName(VAR ourName : ARRAY OF CHAR);
            BEGIN
              In.Line(ourName);
            END GetName;
          
            PROCEDURE AssembleGreeting(ourName : ARRAY OF CHAR);
            BEGIN
              Out.String(&quot;Hello &quot;);Out.String(ourName);
              Out.String (&quot;, very nice to meeting you.&quot;); Out.Ln;
            END AssembleGreeting;
          
            PROCEDURE Greetings*;
              VAR ourName : ARRAY 256 OF CHAR;
            BEGIN
              AskOurName;
              GetName(ourName);
              AssembleGreeting(ourName);
            END Greetings;
          END SayingHi.
      
      </code></pre>
      <p>Now let's add our Greetings procedure to <code>HelloWorld2.Mod</code>.</p>
      <pre><code class="language-{.oberon}">
          MODULE HelloWorld2;
            IMPORT SayingHi;
          BEGIN
            SayingHi.HelloWorld;
            SayingHi.Greetings;
          END HelloWorld2.
      
      </code></pre>
      <p>We compile and run it the same way as before</p>
      <pre><code>
          obnc HelloWorld2
          ./HelloWorld2
      
      </code></pre>
      <p>When you run <code>HelloWorld2</code> you should now see something like<br />
      (I've answered &quot;Robert&quot; and pressed return after the second line.</p>
      <pre><code>
         Hello World!
         Excuse me, may I ask your name? Robert
         Hello Robert, very nice to meeting you.
      
      </code></pre>
      <h2 id="reading-our-code">Reading our code</h2>
      <p>While our revised modules are still short they actually exercise<br />
      a number of language features. Let's walk through the code<br />
      block by block and see what is going.</p>
      <p><code>HelloWorld2.Mod</code> is responsible for the general management of<br />
      our program namely say &quot;Hello World!&quot; and also for initiating<br />
      and responding with a more personal greeting.  It does this by<br />
      first importing our <code>SayingHi.Mod</code> module.</p>
      <pre><code>
          IMPORT SayingHi;
      
      </code></pre>
      <p><a href="HelloWorld2.Mod">HelloWorld2.Mod</a> doesn't have any of its own<br />
      procedures and like our original <a href="HelloWorld.Mod">HelloWorld.Mod</a><br />
      relies on the module's initialization block to run our two public<br />
      procedures from <code>SayingHi</code>. It calls first <code>SayingHi.HelloWorld;</code><br />
      then <code>SayingHi.Greetings'</code> before existing. Other than using the<br />
      <code>SayingHi</code> module it is similar in spirit to our first<br />
      <a href="HelloWorld.Mod">HelloWorld.Mod</a>.</p>
      <p>Our second module <a href="SayingHi.Mod">SayingHi.Mod</a> does the heavy lifting.<br />
      It contains both public and private procedures.  If you tried to<br />
      use <code>GetName</code> from <code>SayingHi</code> in <code>HelloWorld2.Mod</code> you would get a<br />
      compiler error. As far as <code>HelloWorld2.Mod</code> is concerned <code>GetName</code><br />
      does not exist. This is called information hiding and is an important<br />
      capability provided by Oberon's Modules system.</p>
      <h3 id="explore-sayinghi-more-deeply">explore <code>SayingHi</code> more deeply</h3>
      <p>In <code>SayingHi.Mod</code> we introduce two important concepts.</p>
      <ol>
      <li>Public and Private procedures</li>
      <li>variables to hold user input</li>
      </ol>
      <p><code>SayingHi.Mod</code> imports two module, <code>In</code> which is for getting<br />
      text input from the keyboard, and <code>Out</code> which is used for displaying<br />
      text to standard output.</p>
      <pre><code class="language-{.oberon}">
          IMPORT In, Out;
      
      </code></pre>
      <p><code>In</code> and <code>Out</code> are to modules you will commonly use to either<br />
      receive input (<code>In</code>) from the keyboard or display output (<code>Out</code>)<br />
      to the terminal or shell. They provide simple methods for working<br />
      with variables and constants and built-in Oberon data types.<br />
      This is a very useful as it lets us focus our procedures<br />
      on operating on data rather than the low level steps needed to<br />
      interact with the operating system and hardware.</p>
      <p>NOTE: <strong>basic types</strong>, Oberon has a number of basic types, BYTE holds a byte as a series of bit, CHAR holds a single ASCII character, INTEGER holds a signed integer value, REAL holds a floating point number and BOOLEAN holds a True/False value.</p>
      <p>The first procedure is <code>HelloWorld</code> and it's pretty straight forward.<br />
      It displays a &quot;Hello World!&quot; message in our terminal. It uses <code>Out</code>.<br />
      <code>Out.String</code> to display the &quot;Hello World!&quot; and <code>Out.Ln</code> to force a new<br />
      line. <code>Out.String</code> is responsible for displaying values that are of type<br />
      <code>ARRAY OF CHAR</code>. This includes text we provided in double quotes.</p>
      <pre><code class="language-{.oberon}">
          PROCEDURE HelloWorld*;
          BEGIN
            Out.String(&quot;Hello World!&quot;); Out.Ln;
          END HelloWorld;
      
      </code></pre>
      <p>The notable thing about <code>HelloWorld*</code> is its annotation <code>*</code>.<br />
      This asterisk indicates to the compiler that this is<br />
      a public procedure and should be made available to other modules.<br />
      Procedures, variables, constants, records (data structures) can be<br />
      made public with this simple annotation.  If we left off the <code>*</code><br />
      then we would not be able to use <code>HelloWorld</code> procedure from other<br />
      module.</p>
      <p>Our second procedure is <code>AskOurName</code>. It's private because it lacks<br />
      the <code>*</code>. It is invisible to <code>HelloWorld2.Mod</code>. It is visible within<br />
      <code>SayingHi</code> module and we'll use it later in <code>Greetings*</code>. Before<br />
      a procedure, variable, constant or record can be used it must be<br />
      declared. That is why we most define <code>AskOurName</code> before we define<br />
      <code>Greetings*</code>. <code>AskOurName</code> is in other respects very similar to<br />
      <code>HelloWorld*</code>.</p>
      <pre><code class="language-{.oberon}">
          PROCEDURE AskOurName;
          BEGIN
            Out.String(&quot;Excuse me, may I ask your name? &quot;);
          END AskOurName;
      
      </code></pre>
      <p>Our third procedure <code>GetName</code> is a little more interesting.<br />
      It demonstrates several features of the Oberon language. Most<br />
      obvious is that it is the first procedure which contains a<br />
      parameter list.</p>
      <pre><code class="language-{.oberon}">
          PROCEDURE GetName(VAR ourName: ARRAY OF CHAR);
      
      </code></pre>
      <p>There is allot packed in this single statement in addition<br />
      to putting a name to our procedure. Specifically it uses<br />
      a <code>VAR</code> in the parameter.  Oberon provides two kinds of parameters<br />
      in declaring procedures. The two are <code>VAR</code> and static.  A <code>VAR</code><br />
      parameter means that the procedure is allowed to up date the value<br />
      in the memory location indicated by the name. A static variable<br />
      (a parameter without the <code>VAR</code> prefix passes in a read only value.<br />
      This allows us to distinguish between those procedures and variables<br />
      where that can be modified by the procedure and those which<br />
      will be left the same. Inside of <code>GetName</code> we call the<br />
      <code>In</code> module using the <code>Line</code>. This retrieves a line of text<br />
      (a sequence of keyboard strokes ended with the return key).</p>
      <pre><code class="language-{.oberon}">
          In.Line(ourName);
      
      </code></pre>
      <p>Because <code>ourName</code> was a variable parameter in <code>GetName</code> it<br />
      can be modified by <code>In.Line</code>.</p>
      <p>Our next procedure <code>AssembleGreeting</code> is private like<br />
      <code>AskOurName</code> and <code>GetName</code>. Like <code>HelloWorld*</code> and <code>AskOurName</code><br />
      it makes use of the <code>Out</code> module to display content.<br />
      Unlike <code>HelloWorld*</code> it has a parameter but this time<br />
      a static one. Notice the missing <code>VAR</code>. This indicates that<br />
      <code>AssembleGreeting</code> doesn't modify, cannot modify <code>ourName</code>.</p>
      <pre><code class="language-{.oberon}">
          PROCEDURE AssembleGreeting(ourName : ARRAY OF CHAR);
          BEGIN
            Out.String(&quot;Hello &quot;);Out.String(ourName);
            Out.String (&quot;, very nice to meeting you.&quot;); Out.Ln;
          END AssembleGreeting;
      
      </code></pre>
      <p>The use of <code>Out.String</code> is more elaborate then before. Notice how<br />
      we use trailing spaces to make the output more readable.</p>
      <p>Our final procedure is public, <code>Greetings*</code>. It does not<br />
      have any parameters.  Importantly it does include a<br />
      variable for use inside the procedure called <code>ourName</code>.<br />
      The <code>VAR</code> line declares <code>ourName</code> as an <code>ARRAY 256 OF CHAR</code>.<br />
      This declaration tells the compiler to allocate memory<br />
      for storing <code>ourName</code> while <code>Greetings*</code> is being executed.<br />
      The declaration tells us three things. First the storage<br />
      is continuous block of memory, that is what <code>ARRAY</code> means.<br />
      The second is the size of this memory block is 256 <code>CHAR</code><br />
      long and the that we will be storing <code>CHAR</code> values in it.</p>
      <p>The memory for <code>ourName</code> will be populated when we pass<br />
      the variable to <code>GetName</code> based on what we type at the<br />
      keyboard. If we type more than 256 ASCII characters they<br />
      will be ignored. After <code>GetName</code> records the typed character<br />
      we use the memory associated with the <code>ourName</code> variable<br />
      we read that memory to display what we typed in<br />
      the procedure named <code>AssembleGreeting</code>.</p>
      <h3 id="going-a-little-deeper">Going a little deeper</h3>
      <p>Oberon is a typed language meaning that<br />
      variables are declared, allocated and checked during compile time<br />
      for specific characteristics. The one variable we created <code>ourName</code><br />
      in the <code>Greetings</code> procedure reserves the space for 256<br />
      <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> characters.<br />
      In Oberon we call a single ASCII character a <code>CHAR</code>.  Since it<br />
      would be useful to work with more than one <code>CHAR</code> in relationship<br />
      to others Oberon also supports a variable type called <code>ARRAY</code>.<br />
      An <code>ARRAY</code> is represented as a block of memory that is allocated<br />
      by the Oberon run time. Because it is allocated ahead of time we<br />
      need to know its size (i.e. how many <code>CHAR</code> are we storing). In<br />
      our case we have declared <code>ARRAY 256 OF CHAR</code>. That means we can<br />
      hold names up to 256 ASCII characters.</p>
      <p><code>Greetings*</code> does three things and the second thing, <code>GetName</code><br />
      receives the characters typed at the keyboard.  <code>GetName</code> has<br />
      a parameter list. In this case the only one parameter is declared<br />
      <code>VAR ourName : ARRAY OF CHAR</code>. Notice the similarity and<br />
      difference between the <code>VAR</code> statement in <code>Greetings</code> versions<br />
      the parameter list.  Our <code>GetName</code> can accept <strong>any</strong> length of<br />
      <code>ARRAY OF CHAR</code> and it <strong>only</strong> can accept an <code>ARRAY OF CHAR</code>.<br />
      If you try to pass another type of variable to <code>GetName</code> the<br />
      compiler will stop with an error message.</p>
      <p>Why is this important?</p>
      <p>We've minimized the memory we've used in our program.  Memory is<br />
      typically allocated on the stack (a block of memory made available<br />
      by the operating system to the program). We've told the operating<br />
      system we need 256 <code>CHAR</code> worth of consecutive memory locations<br />
      when we allocated room the variable <code>ourName</code> in <code>Greetings</code>. When<br />
      we invoke <code>GetName</code> Oberon knows to use that same memory location<br />
      for the value of <code>ourName</code> defined in the parameter.  In turn<br />
      when <code>In.String(ourName);</code> is called the module <code>In</code> knows<br />
      to store the name typed on the keyboard in that location of memory.<br />
      When <code>Out.String(outName);</code> is called the compiler knows to use<br />
      the same location of memory to send the contents to the display.<br />
      When we finally finish the <code>Greetings*</code> procedure the memory is<br />
      released back to the operating system for re-use by this or<br />
      other programs.</p>
      <h3 id="what-weve-explored">What we've explored</h3>
      <ol>
      <li>Using a module to break down a simple problem</li>
      <li>Using a module's ability to have public and private procedures</li>
      <li>Touched on how memory is used in a simple interactive program</li>
      </ol>
      <h3 id="next-and-previous">Next and Previous</h3>
      <ul>
      <li>Next <a href="../18/Mostly-Oberon-Basic-Types.html">Basic Types</a></li>
      <li>Previous <a href="../11/Mostly-Oberon.html">Mostly Oberon</a></li>
      </ul>
      
    </article>
  </section>
  <footer>
    <p>copyright © 2016 - 2025 R. S. Doiel<br /> <a
    href="/rssfeed.html">RSS</a> feeds and website built with <a
    href="https://rsdoiel.github.io/antennaApp">antennaApp</a>, Bash, Make and <a
    href="https://pandoc.org">Pandoc</a>.</p>
  </footer>

    <script type="module" src="/modules/copyToClipboard.js"></script>
    <script type="module">
      await import('/pagefind/pagefind-highlight.js');
      new PagefindHighlight({ highlightParam: "highlight" });
    </script>
</body>
</html>
