<!doctype html>
<html lang="en-US">
<head>
  <meta charset="UTF-8" />
  <link  rel="alternate" type="text/markdown" href="Dynamic-types.md" title=""/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/css/site.css" />
  <meta name="generator" content="antenna/0.0.5">
  <meta name="date" content="2025-09-13T16:30:54-07:00">
</head>
<body>
  <header>
    (date: 2025-09-13 16:30:54)
  </header>
  <nav>
    <ul>
    <li><a href="/" title="R. S. Doiel"><img class="blog-logo" src="/media/Wee-Free-Doiels-Summer-Reading.svg" alt="Wee Free Doiels, Summer Reading"></a></li>
    <li><a href="/">R. S. Doiel</a></li>
    <li><a href="/about.html">About</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/presentations.html">Presentations</a></li>
    <li><a href="/series/">Series</a></li>
    <li><a href="/search.html">Search</a></li>
    <li><a href="https://github.com/rsdoiel">GitHub</a></li>
    <li><a href="/index.xml" title="RSS, recent posts">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9"></path>
    <path d="M4 4a16 16 0 0 1 16 16"></path>
    <circle cx="5" cy="19" r="1"></circle> </svg> RSS </a></li>
    </ul>
  </nav>

  <section>
    <article data-published="2020-05-25" data-link="https://rsdoiel.github.io/blog/2020/05/25/Dynamic-types.html">
      <h1 id="dynamic-types">Dynamic types</h1>
      <p>By R. S. Doiel, 2020-05-25</p>
      <p>This is the eighth post in the <a href="../../04/11/Mostly-Oberon.html">Mostly Oberon</a><br />
      series. Mostly Oberon documents my exploration of the Oberon Language,<br />
      Oberon System and the various rabbit holes I will inevitably fall into.</p>
      <h2 id="dynamic-types-in-oberon">Dynamic Types in Oberon</h2>
      <p>Oberon-07 is a succinct systems language. It provides a minimal<br />
      but useful set of basic static types. Relying on them addresses<br />
      many common programming needs. The Oberon compiler ensures<br />
      static types are efficiently allocated in memory. One of the<br />
      strengths of Oberon is this ability to extend the type system.<br />
      This means when the basic types fall short you can take<br />
      advantage of Oberon's type  extension features. This includes<br />
      creating dynamically allocated data structures. In Oberon-07<br />
      combining Oberon's <code>POINTER TO</code> and <code>RECORD</code> types allows us to<br />
      create complex and dynamic data structures.</p>
      <h2 id="an-example-dynamic-strings">An example, dynamic strings</h2>
      <p>Strings in Oberon-07 are typical declared as an <code>ARRAY OF CHAR</code><br />
      with a specific length. If the length of a string is not<br />
      known a head of time this presents a challenge. One approach is<br />
      to declare a long array but that would allocate allot of memory<br />
      which may not get used. Another approach is to create a dynamic<br />
      data structure. An example is using a linked list of shorter<br />
      <code>ARRAY OF CHAR</code>.  The small fixed strings can combine to<br />
      represent much larger strings. When one fills up we add<br />
      another.</p>
      <h3 id="pointers-and-records-an-oberon-idiom">Pointers and records, an Oberon idiom</h3>
      <p>Our data model is a pointer to a record where the record<br />
      contains an <code>ARRAY OF CHAR</code> and a pointer to the next record.<br />
      A common idiom in Oberon for dynamic types is to declare a<br />
      <code>POINTER TO</code> type and declare a <code>RECORD</code> type which contains<br />
      the <code>POINTER TO</code> type as an attribute.  If you see this idiom<br />
      you are looking at some sort of dynamic data structure. The<br />
      pointer type is usually named for the dynamic type you want<br />
      work with and the record type is declared using the same name<br />
      with a &quot;Desc&quot; suffix. In our case <code>DynamicString</code> will be the<br />
      name of our <code>POINTER TO</code> type and our record type will be<br />
      called <code>DynamicStringDesc</code> following the convention.  In our<br />
      record structure we include a &quot;value&quot; to holding a short<br />
      fixed length <code>ARRAY OF CHAR</code>  and a &quot;next&quot; to holding the<br />
      pointer to our next record.</p>
      <p>In our record the value is declared as a static type. We need<br />
      to know how long our &quot;short&quot; string should be? I.e. What length<br />
      is our <code>ARRAY OF CHAR</code>? It's a question of tuning. If it is too<br />
      short we spend more time allocating new records, too long and<br />
      we are wasting memory in each record. A way to make tuning a<br />
      little simpler is to use a constant value to describe our array<br />
      length. Then if we decide our array is too big<br />
      or too small we can adjust the constant knowing that our record<br />
      structure and the procedures that use that the length<br />
      information will continue to work correctly.</p>
      <p>Let's take a look at actual code (NOTE: vSize is our constant value).</p>
      <pre><code>
          CONST
            vSize = 128; 
          
          TYPE
            DynamicString* = POINTER TO DynamicStringDesc;
            DynamicStringDesc* = RECORD 
              value : ARRAY vSize OF CHAR; 
              next : DymamicString; 
            END;
      
      </code></pre>
      <p>NOTE: Both <code>DynamicString</code> and <code>DynamicStringDesc</code> are defined<br />
      using an <code>*</code>. These are public and will be available<br />
      to other modules.  Inside our record <code>DynamicStringDesc</code> we<br />
      have two private to our module attributes, <code>.value</code> and<br />
      <code>.next</code>. They are private so that we can change our<br />
      implementation in the future without requiring changes in<br />
      modules that use our dynamic strings. Likewise our constant <code>vSize</code><br />
      is private as that is an internal implementation detail. This<br />
      practice is called information hiding.</p>
      <p>NOTE: The asterisk in Oberon decorates procedures, types, variables<br />
      and constants that are &quot;public&quot; to other modules.</p>
      <p>NOTE: Variables are always exported read only.</p>
      <p>NOTE: With information hiding some details of implementation allow us<br />
      to keep a clean division between implementation inside the module and how<br />
      that implementation might be used. With out information hiding we often<br />
      have &quot;leaky&quot; abstractions that become brittle and hard to maintain and<br />
      rely on.</p>
      <h2 id="working-with-dynamicstring">Working with DynamicString</h2>
      <p>Our type definitions describe to the compiler how to layout our<br />
      data in memory. The type system in Oberon-07 also ensures that<br />
      access to that memory is restricted to assignments, operations<br />
      and procedures compatible with that type. To be useful from<br />
      other modules we need a few procedures to help work with<br />
      this new data type. What follows is a minimal set needed to be<br />
      useful.</p>
      <h3 id="newvar-str--dynamicstring"><code>New*(VAR str : DynamicString)</code></h3>
      <p><code>New</code> will initialize a DynamicString object setting <code>.value</code> to<br />
      an empty string.</p>
      <pre><code>
        PROCEDURE New*(VAR str : DynamicString);
        BEGIN NEW(str);
          str.value := &quot;&quot;; 
          str.next := NIL;
        END New;
      
      </code></pre>
      <h3 id="setvar-str--dynamicstring-source--array-of-char"><code>Set*(VAR str : DynamicString; source : ARRAY OF CHAR)</code></h3>
      <p><code>Set</code> copies an <code>ARRAY OF CHAR</code> into an existing DynamicString.<br />
      This requires that we add and link additional records if the<br />
      <code>source</code> is longer than our current dynamic string. Set is a<br />
      bridge procedure between an existing datatype, <code>ARRAY OF CHAR</code><br />
      and our new data type, <code>DynamicString</code>.</p>
      <pre><code>
        PROCEDURE Set*(VAR str : DynamicString; source : ARRAY OF CHAR); 
          VAR cur, next : DynamicString; tmp : ARRAY vSize OF CHAR; 
              i, l : INTEGER;
        BEGIN cur := str; cur.value := &quot;&quot;;
          l := Strings.Length(source);
          i := 0; 
          WHILE i &lt; l DO
            Strings.Extract(source, i, i + vSize, tmp);
            Strings.Append(tmp, cur.value);
            i := i + Strings.Length(tmp);
            IF (i &lt; l) THEN
              IF cur.next = NIL THEN
                New(next); cur.next := next;
              END;
              cur := cur.next;
            END; 
          END;
        END Set;
      
      </code></pre>
      <h3 id="tochararraystr--dynamicstring-var-dest--array-of-char-var-ok--boolean"><code>ToCharArray*(str : DynamicString; VAR dest : ARRAY OF CHAR; VAR ok : BOOLEAN)</code></h3>
      <p><code>ToCharArray</code> copies the contents of our dynamic string into an array<br />
      of char setting <code>ok</code> to TRUE on success or FALSE if truncated.<br />
      Like <code>Set*</code> it is a bridge procedure to let us move data output<br />
      our new dynamic string type.</p>
      <pre><code>
        PROCEDURE ToCharArray*(str : DynamicString; 
                               VAR dest : ARRAY OF CHAR; 
                               VAR ok : BOOLEAN);
          VAR cur : DynamicString; i : INTEGER;
        BEGIN 
          ok := FALSE;
          cur := str; i := 0;
          WHILE cur # NIL DO
            i := i + Strings.Length(cur.value);
            Strings.Append(cur.value, dest);
            cur := cur.next;
          END;
          ok := (i = Strings.Length(dest));
        END ToCharArray;
      
      </code></pre>
      <p>Two additional procedures will likely be needed-- <code>Append</code> and<br />
      <code>AppendCharArray</code>. This first one is trivial, if we want to add<br />
      one dynamic string onto another all we need to do is link the<br />
      last record of the first and point it to a copy of the second string we're appending.</p>
      <h3 id="appendextra--dynamicstring-var-dest--dynamicstring"><code>Append*(extra : DynamicString; VAR dest : DynamicString);</code></h3>
      <p><code>Append</code> adds the <code>extra</code> dynamic string to <code>dest</code> dynamic string. Our<br />
      &quot;input&quot; is <code>extra</code> and our output is a modified dynamic string<br />
      named <code>dest</code>. This parameter order mimics the standard<br />
      <code>Strings</code> module's <code>Append</code>.</p>
      <p>NOTE: Oberon idiom is often input values, modified value and<br />
      result values. Modified and result values are declared in the parameter<br />
      definition using <code>VAR</code>.</p>
      <p>Algorithm:</p>
      <ol>
      <li>Move to the end of <code>dest</code> dynamic string</li>
      <li>Create a new record at <code>cur.next</code>.</li>
      <li>Copy <code>extra.value</code> info.value <code>cur.next.value</code></li>
      <li>Advance <code>extra</code> and <code>cur</code>, repeating steps 2 to 4 as needed.</li>
      </ol>
      <p>Implemented procedure.</p>
      <pre><code>
        PROCEDURE Append*(extra: DynamicString; VAR dest : DynamicString);
          VAR cur : DynamicString;  
        BEGIN
          (* Move to the end of the dest DynamicString *)
          cur := dest;
          WHILE cur.next # NIL DO cur := cur.next; END;
          (* Starting initial pointer of `extra` copy its records
             input new records created in `cur`. *)
          WHILE extra # NIL DO
            (* Create a new record *)
            NEW(cur.next);
            cur.next.value := &quot;&quot;;
            cur.next.next := NIL;
            (* Copy extra.value into new record *)
            Strings.Extract(extra.value, 0, vSize, cur.next.value);
            (* Advance to next record for both cur and extra *)
            extra := extra.next;
            cur := cur.next;
          END;
        END Append;
      
      </code></pre>
      <p>A second procedure for appending an <code>ARRAY OF CHAR</code> also<br />
      becomes trivial. First convert the <code>ARRAY OF CHAR</code> to a dynamic<br />
      string then append it with the previous procedure.</p>
      <h3 id="appendchararraysrc--array-of-char-var-str--dynamicstring"><code>AppendCharArray*(src : ARRAY OF CHAR; VAR str : DynamicString);</code></h3>
      <p>This procedure appends an ARRAY OF CHAR to an existing dynamic string.</p>
      <pre><code>
        PROCEDURE AppendCharArray*(extra: ARRAY OF CHAR; VAR dest : DynamicString);
          VAR extraStr : DynamicString;    
        BEGIN
          (* Convert our extra ARRAY OF CHAR into a DynamicString *)
          New(extraStr); Set(extraStr, extra);
          (* Now we can append. *)
          Append(extraStr, dest);
        END AppendCharArray;
      
      </code></pre>
      <p>At some point we will want to know the length of our dynamic string.</p>
      <h3 id="lengthstr--dynamicstring--integer"><code>Length(str : DynamicString) : INTEGER</code></h3>
      <p>Our <code>Length</code> needs to go through our linked list and total up<br />
      the length of each value. We will use a variable called <code>cur</code><br />
      to point at the current record and add up our total length as<br />
      we walk through the list.</p>
      <pre><code>
        PROCEDURE Length*( source : DynamicString) : INTEGER;
          VAR cur : DynamicString; total : INTEGER;
        BEGIN
          total := 0;
          cur := source;
          WHILE cur # NIL DO
            total := total + Strings.Length(cur.value);
            cur := cur.next;
          END; 
          RETURN total
        END Length;
      
      </code></pre>
      <h2 id="extending-dynamicstrings-module">Extending DynamicStrings module</h2>
      <p>With these few procedures we have a basic means of working with<br />
      dynamic strings. Moving beyond this we can look at the standard<br />
      Oberon <code>Strings</code> module for inspiration.  If we use similar<br />
      procedure signatures we can create a drop in replacement<br />
      for <code>Strings</code> with <code>DynamicStrings</code>.</p>
      <p>NOTE: Procedure signatures refer to procedures type along<br />
      with the order and types of parameters. A quick review of the<br />
      procedure signatures for the standard module <a href="https://miasap.se/obnc/obncdoc/basic/Strings.def.html">Strings</a> is<br />
      provided by the <a href="https://miasap.se/obnc">OBNC</a> compiler docs.</p>
      <p>Let's look at recreating <code>Insert</code> as a potential guide to<br />
      a more fully featured <a href="DynamicStrings.Mod">&quot;DynamicStrings.Mod&quot;</a>.<br />
      In our <code>Insert</code> we modify the procedure signature so the<br />
      source and destinations are dynamic strings.</p>
      <h3 id="insertsource--dynamicstring-pos--integer-var-dest--dynamicstring"><code>Insert(source : DynamicString; pos : INTEGER; VAR dest : DynamicString)</code></h3>
      <p>The <code>Insert</code> procedure inserts a <code>source</code> dynamic string at the<br />
      position provided into our <code>dest</code> dynamic string. We are implementing<br />
      the same signature  for our <code>DynamicStrings.Insert()</code> as<br />
      <code>Strings.Insert()</code>. Only the parameters for source and destination<br />
      are changed to <code>DynamicString</code>.</p>
      <p>Internally our procedure for <code>Insert</code> is a more complicated than<br />
      the ones we've written so far. It needs to do all the housing<br />
      keeping for making sure we add the right content in the correct<br />
      spot.  The general idea is to find the record holding the split<br />
      point. Split that record into two records. The first retains<br />
      the characters before the insert position. The second holds the<br />
      characters after the insert position and points to next record<br />
      in the dynamic string. Once the split is accomplished it then<br />
      is a matter of linking everything up. The record before the<br />
      insert position is set to point at the dynamic string to be<br />
      inserted, the inserted dynamic string is set to point at the<br />
      record that contained the rest of the characters after the<br />
      split.</p>
      <p>It is easy to extract a sub-string from an <code>ARRAY OF CHAR</code><br />
      using the standard <code>Strings</code> module.  We can store the characters<br />
      in the <code>.value</code> of the record after the split in a temporary<br />
      <code>ARRAY OF CHAR</code>.  The temporary <code>ARRAY OF CHAR</code> can be used to<br />
      create a new dynamic string record which will be linked to the<br />
      rest of our destination dynamic string. The record which held<br />
      the characters before the insert position needs to be truncated<br />
      and it needs to be linked to the dynamic string we want to<br />
      insert. NOTE: This will leave a small amount of unused<br />
      memory.</p>
      <p>NOTE: If conserving memory is critical then re-packing the<br />
      dynamic string could be implemented as another procedure. The<br />
      cost would be complexity and time to shift characters between<br />
      later records and earlier ones replacing excess NULL values.</p>
      <p>We need to find the record where the split will occur. In the<br />
      record to be split we need to calculate a relative<br />
      split point. We then can copy the excess characters in that<br />
      split record to a new record and truncate the <code>.value</code>'s<br />
      <code>ARRAY OF CHAR</code> to create our split point. Truncating is easy<br />
      in that we replace the CHAR in the <code>.values</code> that are not<br />
      needed with a NULL character. We can do that with a<br />
      simple loop. Likewise calculating the relative insertion<br />
      position can be done by taking the modulo of the <code>vSize</code> of<br />
      <code>.value</code>.</p>
      <p>NOTE: In Oberon stings are terminated with a NULL<br />
      character. A NULL character holds the ASCII value <code>0X</code>.</p>
      <p>Our algorithm:</p>
      <ol>
      <li>Set <code>cur</code> to point to the start of our destination dynamic string</li>
      <li>Move <code>cur</code> to the record in the link list where the insertion will take place</li>
      <li>Calculate the relative split point in <code>cur.value</code></li>
      <li>Copy the characters in <code>cur.value</code> from relative split point to end of <code>.value</code> into a temporary <code>ARRAY OF CHAR</code></li>
      <li>Make a new record, <code>rest</code>, using the temporary <code>ARRAY OF CHAR</code> and update the value of <code>.next</code> to match that of <code>cur.next</code></li>
      <li>Truncate the record (cur) at the relative split point</li>
      <li>Set <code>cur.next</code> to point to our <code>extra</code> dynamic string.</li>
      <li>Move to the end of extra with <code>cur</code></li>
      <li>Set the <code>cur.next</code> to point at <code>rest</code></li>
      </ol>
      <p>Our procedure:</p>
      <pre><code>
        PROCEDURE Insert*(extra : DynamicString; 
                          pos : INTEGER; 
                          VAR dest : DynamicString);
          VAR cur, rest : DynamicString;
              tmp : ARRAY vSize OF CHAR;
              i, splitPos : INTEGER; continue : BOOLEAN;
        BEGIN
          (* 1. Set `cur` to the start of our `dest` dynamic string *)
          cur := dest;
      
          (* 2. Move to the record which holds the split point *)
          i := 0;
          continue := (i &lt; pos);
          WHILE continue DO
            i := i + Strings.Length(cur.value);
            continue := (i &lt; pos);
            IF continue &amp; (cur.next # NIL) THEN
              cur := cur.next;
            ELSE
              continue := FALSE;
            END;
          END;
      
          (* 3. Copy the characters in `cur.value` from relative
                split point to end of `.value` into a 
                temporary `ARRAY OF CHAR` *)
          splitPos := pos MOD vSize;
          Strings.Extract(cur.value, splitPos,
                          Strings.Length(cur.value), tmp);
      
          (* 4. Make a new record, `rest`, using the temporary 
                `ARRAY OF CHAR` and update the value of `.next` to
                match that of `cur.next` *)
          New(rest); Set(rest, tmp);
          rest.next := cur.next;
      
          (* 5. Truncate `cur.value` at the relative split point *)
          i := splitPos;
          WHILE i &lt; LEN(cur.value) DO
            cur.value[i] := 0X;
            INC(i);
          END;
      
          (* 6. Set `cur.next` to point to our `extra`
                dynamic string. *)
          cur.next := extra;
      
          (* 7. Move to the end of extra with `cur` *)
          WHILE cur.next # NIL DO cur := cur.next; END;
      
          (* 8. Set the `cur.next` to point at `rest` *)
          cur.next := rest;
        END Insert;
      
      </code></pre>
      <p>While our <code>Insert</code> is the longest procedure so far the steps<br />
      are mostly simple. Additionally we can easily extend this to<br />
      support inserting a more traditional <code>ARRAY OF CHAR</code> using our<br />
      previously established design pattern of converting a basic type<br />
      into our dynamic type before calling the dynamic version of the<br />
      function.</p>
      <pre><code>
        PROCEDURE InsertCharArray*(source : ARRAY OF CHAR; 
                                   pos : INTEGER; 
                                   VAR dest : DynamicString);
          VAR extra : DynamicString;
        BEGIN
          New(extra); Set(extra, source);
          Insert(extra, pos, dest);
        END InsertCharArray;
      
      </code></pre>
      <h2 id="where-to-go-next">Where to go next</h2>
      <p>It is possible to extend our &quot;DynamicStrings.Mod&quot; into a drop<br />
      in replacement for the standard <code>Strings</code>.  I've included a<br />
      skeleton of that module as links at the end of this article<br />
      with stubs for the missing implementations such as <code>Extract</code>,<br />
      <code>Replace</code>, <code>Pos</code>, and <code>Cap</code>.  I've also included a<br />
      &quot;DynamicStringsTest.Mod&quot; for demonstrating how it works.</p>
      <p>The procedure I suggest is to mirror <code>Strings</code> replacing the<br />
      parameters that are <code>ARRAY OF CHAR</code> with <code>DynamicString</code>. It<br />
      will be helpful to include some bridging procedures that accept<br />
      <code>ARRAY OF CHAR</code> as inputs too. These will use similar names<br />
      with a suffix of <code>CharArray</code>.</p>
      <h2 id="parameter-conventions-and-order">Parameter conventions and order</h2>
      <p>Oberon is highly composable. The trick to creating a drop in<br />
      replacement module is use the same parameter signatures so<br />
      you only need to make minor changes like updating the <code>IMPORT</code><br />
      statement and using a module alias to map the old module to the<br />
      new one.  The parameter signatures in <code>Strings</code> follow a<br />
      convention you'll see in other Oberon modules. The parameter<br />
      order is based on the &quot;inputs&quot;, &quot;modify parameters&quot;, and<br />
      &quot;output parameters&quot;. Inputs are non-<code>VAR</code> parameters. The<br />
      remaining are <code>VAR</code> parameters. I think of &quot;modify parameters&quot;<br />
      as those objects who reflect side effects. I think of &quot;output&quot;<br />
      as values that in other languages would be returned by<br />
      functions.  This is only a convention. A variation I've<br />
      read in other Oberon modules is &quot;object&quot;, &quot;inputs&quot;, &quot;outputs&quot;.<br />
      &quot;object&quot; and &quot;outputs&quot; are <code>VAR</code> parameters and &quot;inputs&quot; are<br />
      not. This ordering makes sense when we think of records as<br />
      holding an object. In both cases ordering is a convention<br />
      and not enforced by the language.  Convention and consistency is<br />
      helpful but readability is the most important.  Oberon is a<br />
      readable language. It does not reward obfuscation. Readability is<br />
      a great virtue in a programming language. When creating your own<br />
      modules choose readability based on the concepts you want to<br />
      emphasize in the module (e.g. procedural, object oriented).</p>
      <h2 id="the-modules-so-far">The modules so far</h2>
      <p>You can read the full source for the module discussed along<br />
      with a test module in the links that follow.</p>
      <ul>
      <li><a href="DynamicStrings.Mod">DynamicStrings.Mod</a></li>
      <li><a href="DynamicStringsTest.Mod">DynamicStringsTest.Mod</a></li>
      </ul>
      <h3 id="next-and-previous">Next and Previous</h3>
      <ul>
      <li>Next <a href="../../06/20/Procedures-as-parameters.html">Procedures as parameters</a></li>
      <li>Previous <a href="../09/Oberon-07-and-the-filesystem.html">Oberon-07 and the file system</a></li>
      </ul>
      
    </article>
  </section>
  <footer>
    <p>copyright © 2016 - 2025 R. S. Doiel<br /> <a
    href="/rssfeed.html">RSS</a> feeds and website built with <a
    href="https://rsdoiel.github.io/pttk">pttk</a>, Bash, Make and <a
    href="https://pandoc.org">Pandoc</a>.</p>
  </footer>

    <script type="module" src="/modules/copyToClipboard.js"></script>
    <script type="module">
      await import('/pagefind/pagefind-highlight.js');
      new PagefindHighlight({ highlightParam: "highlight" });
    </script>
</body>
</html>
