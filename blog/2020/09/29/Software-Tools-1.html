<!doctype html>
<html lang="en-US">
<head>
  <meta charset="UTF-8" />
  <link  rel="alternate" type="text/markdown" href="Software-Tools-1.md" title=""/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/css/site.css" />
  <meta name="generator" content="antenna/0.0.6">
  <meta name="date" content="2025-09-15T14:18:48-07:00">
</head>
<body>
  <header>
    (date: 2025-09-15 14:18:48)
  </header>
  <nav>
    <ul>
    <li><a href="/" title="R. S. Doiel"><img class="blog-logo" src="/media/Wee-Free-Doiels-Summer-Reading.svg" alt="Wee Free Doiels, Summer Reading"></a></li>
    <li><a href="/">R. S. Doiel</a></li>
    <li><a href="/about.html">About</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/presentations.html">Presentations</a></li>
    <li><a href="/series/">Series</a></li>
    <li><a href="/search.html">Search</a></li>
    <li><a href="https://github.com/rsdoiel">GitHub</a></li>
    <li><a href="/index.xml" title="RSS, recent posts">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9"></path>
    <path d="M4 4a16 16 0 0 1 16 16"></path>
    <circle cx="5" cy="19" r="1"></circle> </svg> RSS </a></li>
    </ul>
  </nav>

  <section>
    <article data-published="2020-09-29" data-link="https://rsdoiel.github.io/blog/2020/09/29/Software-Tools-1.html">
      <h1 id="software-tools-getting-started">Software Tools, Getting Started</h1>
      <h2 id="overview">Overview</h2>
      <p>This post is the first in a series revisiting the<br />
      programs described in the 1981 book by Brian W. Kernighan and<br />
      P. J. Plauger's called <a href="https://archive.org/details/softwaretoolsinp00kern">Software Tools in Pascal</a>.<br />
      The book is available from the <a href="https://openlibrary.org/">Open Library</a><br />
      and physical copies are still (2020) commonly available from used book<br />
      sellers.  The book was an early text on creating portable command<br />
      line programs.</p>
      <p>In this series I present the K &amp; P (i.e. Software Tools in Pascal)<br />
      programs re-implemented in Oberon-07. I have testing my implementations<br />
      using Karl Landström's <a href="http://miasap.se/obnc/">OBNC</a><br />
      compiler and his implementation of the Oakwood Guide's modules<br />
      for portable Oberon programs. Karl also provides a few additional<br />
      modules for working in a POSIX environment (e.g. BSD, macOS, Linux,<br />
      Windows 10 with Linux subsystem). I have also tested these<br />
      programs with Mike Spivey's <a href="http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler">Oxford Oberon Compiler</a> an aside<br />
      from the differences file extensions that both compilers use<br />
      the source code works the same.</p>
      <p>NOTE: OBNC compiler is the work of Karl Langström, it is portable across many systems where the C tool chain is available.</p>
      <p>NOTE: POSIX defines a standard of compatibility inspired by <a href="https://en.wikipedia.org/wiki/Unix">UNIX</a>, see <a href="https://en.wikipedia.org/wiki/POSIX">https://en.wikipedia.org/wiki/POSIX</a></p>
      <h2 id="getting-started">Getting Started.</h2>
      <p>Chapter one in K &amp; P is the first chapter that presents code. It introduces<br />
      some challenges and constraints creating portable Pascal suitable for use<br />
      across hardware architectures and operating systems. In 1981 this included<br />
      mainframes, minicomputers as well as the recent evolution of the microcomputer.<br />
      The programs presented build up from simple to increasingly complex as<br />
      you move through the book.  They provide example documentation and discuss<br />
      their implementation choices. It is well worth reading the book for those<br />
      discussions, while specific to the era, mirror the problems program authors<br />
      face today in spite of the wide spread success of the POXIS model, the<br />
      consolidation of CPU types and improvements made in development tools in<br />
      the intervening decades.</p>
      <p>Through out K &amp; P you'll see the bones of many POSIX commands we have today.</p>
      <p>Programs from this chapter include:</p>
      <ol>
      <li><strong>copyprog</strong>, this is like &quot;cat&quot; in a POSIX system</li>
      <li><strong>charcount</strong>, this is like the &quot;wc&quot; POSIX command using the &quot;-c&quot; option</li>
      <li><strong>linecount</strong>, this is like the &quot;wc&quot; POSIX command using the &quot;-l&quot; option</li>
      <li><strong>wordcount</strong>, this is like the &quot;wc&quot; POSIX command using the &quot;-w&quot; option</li>
      <li><strong>detab</strong>, converts tabs to spaces using tab stops every four characters in a line</li>
      </ol>
      <p>All programs in this chapter rely solely on standard input and output.<br />
      Today's reader will notice an absence to common concepts in today's<br />
      command line programs.  First is the lack of interaction with command line<br />
      parameters, the second is no example take advantage of environment variables.<br />
      These operating system features were not always available across<br />
      operating systems of the early 1980s. Finally I'd like to point out a<br />
      really nice feature included in the book. It is often left out as a topic<br />
      in programming books.  K &amp; P provide example documentation. It's structure<br />
      like an early UNIX man page. It very clear and short. This is something<br />
      I wish all programming texts at least mentioned. Documentation is important<br />
      to the program author because it clarifies scope of the problem being<br />
      tackled and to the program user so they understand what they are using.</p>
      <h3 id="11-file-copyinghttpsarchiveorgdetailssoftwaretoolsinp00kernpage7mode1up"><a href="https://archive.org/details/softwaretoolsinp00kern/page/7/mode/1up">1.1. File Copying</a></h3>
      <p>Here's how K &amp; P describe &quot;copyprog.pas&quot; (referred to as &quot;copy&quot; in<br />
      the documentation).</p>
      <pre><code>
      PROGRAM
      
          copy    copy input to output
      
      USAGE
      
          copy
      
      FUNCTION
      
          copy copies its input to its output unchanged. It is useful for copying
          from a terminal to a file, from file to file, or even from terminal to
          terminal. It may be used for displaying the contents of a file, without
          interpretation or formatting, by copying from the file to terminal.
      
      EXAMPLE
      
          To echo lines type at your terminal.
      
          copy
          hello there, are you listening?
          **hello there, are you listening?**
          yes, I am.
          **yes, I am.**
          &lt;ENDFILE&gt;
      
      </code></pre>
      <p>The source code for &quot;copyprog.pas&quot; is shown on<br />
      <a href="https://archive.org/details/softwaretoolsinp00kern/page/9/mode/1up">page 9</a><br />
      of K &amp; P.  First the authors introduce the <strong>copy</strong> procedure<br />
      then a complete the section introducing it in context of the complete Pascal<br />
      program. After this first example K &amp; P leave implementation of the full<br />
      program up to the reader.</p>
      <p>The body of the Pascal program invokes a procedure called<br />
      <a href="https://archive.org/details/softwaretoolsinp00kern/page/8/mode/1up">copy</a><br />
      which reads from standard input character by character and writes<br />
      to standard output character by character without modification.  Two<br />
      supporting procedures are introduced, &quot;getc&quot; and &quot;putc&quot;. These are shown<br />
      in the complete program listing on page 9. They are repeatedly used<br />
      through out the book. One of the really good aspects of this simple<br />
      program is relying on the idea of standard input and output. This makes<br />
      &quot;copyprog.pas&quot; a simple filter and template for writing many of the programs<br />
      that follow. K &amp; P provide a good explanation for this simple approach.<br />
      Also note K &amp; P's rational for working character by character versus<br />
      line by line.</p>
      <p>My Oberon-07 version takes a similar approach. The module looks remarkably<br />
      similar to the Pascal but is shorter because reading and writing characters are<br />
      provided for by Oberon's standard modules &quot;In&quot; and &quot;Out&quot;.<br />
      I have chosen to use a &quot;REPEAT/UNTIL&quot; loop over the &quot;WHILE&quot;<br />
      loop used by K &amp; P is the attempt to read from standard input needs to happen<br />
      at least once. Note in my &quot;REPEAT/UNTIL&quot; loop's terminating condition.<br />
      The value of <code>In.Done</code> is true on successful read and false<br />
      otherwise (e.g. you hit an end of the file). That means our loop must<br />
      terminate on <code>In.Done # TRUE</code> rather than <code>In.Done = TRUE</code>. This appears<br />
      counter intuitive unless you keep in mind our loop stops when we having<br />
      nothing more to read, rather than when we can continue to read.<br />
      It <code>In.Done</code> means the read was successful and does not<br />
      mean &quot;I'm done and can exit now&quot;. Likewise before writing out the character<br />
      we read, it is good practice to check the <code>In.Done</code> value. If <code>In.Done</code> is<br />
      TRUE, I know can safely display the character using <code>Out.Char(c);</code>.</p>
      <pre><code>
      MODULE CopyProg;
      IMPORT In, Out;
      
      PROCEDURE copy;
      VAR
        c : CHAR;
      BEGIN
        REPEAT
          In.Char(c);
          IF In.Done THEN
              Out.Char(c);
          END;
        UNTIL In.Done # TRUE;
      END copy;
      
      BEGIN
        copy();
      END CopyProg.
      
      </code></pre>
      <h4 id="limitations">Limitations</h4>
      <p>This program only works with standard input and output. A more generalized<br />
      version would work with named files.</p>
      <h3 id="12-counting-charactershttpsarchiveorgdetailssoftwaretoolsinp00kernpage13mode1up"><a href="https://archive.org/details/softwaretoolsinp00kern/page/13/mode/1up">1.2 Counting Characters</a></h3>
      <pre><code>
      PROGRAM
      
        charcount count characters in input
      
      USAGE
      
        charcount
      
      FUNCTION
      
        charcount counts the characters in its input and writes the total
        as a single line of text to the output. Since each line of text is
        internally delimited by a NEWLINE character, the total count is the
        number of lines plus the number of characters within each line.
      
      EXAMPLE
      
        charcount
        A single line of input.
        &lt;ENDFILE&gt;
        24
      
      </code></pre>
      <p><a href="https://archive.org/details/softwaretoolsinp00kern/page/13/mode/1up">On page 13</a><br />
      K &amp; P introduces their second program, <strong>charcount</strong>. It is based on a single<br />
      procedure that reads from standard input and counts up the number of<br />
      characters encountered then writes the total number found to standard out<br />
      followed by a newline. In the text only the procedure is shown, it is<br />
      assumed you'll write the outer wrapper of the program yourself as<br />
      was done with the <strong>copyprog</strong> program. My Oberon-07 version is very similar<br />
      to the Pascal. Like in the our first &quot;CopyProg&quot; we will make use of the<br />
      &quot;In&quot; and &quot;Out&quot; modules. Since we will<br />
      need to write an INTEGER value we'll also use &quot;Out.Int()&quot; procedure which<br />
      is very similar to K &amp; P's &quot;putdec()&quot;. Aside from the counting this is very<br />
      simple  like our first program.</p>
      <pre><code>
      MODULE CharCount;
      IMPORT In, Out;
      
      PROCEDURE CharCount;
      VAR
        nc : INTEGER;
        c : CHAR;
      BEGIN
        nc := 0;
      
        REPEAT
          In.Char(c);
          IF In.Done THEN
            nc := nc + 1;
          END;
        UNTIL In.Done # TRUE;
        Out.Int(nc, 1);
        Out.Ln();
      END CharCount;
      
      BEGIN
        CharCount();
      END CharCount.
      
      </code></pre>
      <h4 id="limitations-1">Limitations</h4>
      <p>The primary limitation in counting characters is most readers are<br />
      interested in visible character count. In our implementation<br />
      even non-printed characters are counted. Like our first program<br />
      this only works on standard input and output. Ideally this should<br />
      be written so it works on any file including standard input and<br />
      output. If the reader implements that it could become part of a<br />
      package on statistical analysis of plain text files.</p>
      <h3 id="13-counting-lineshttpsarchiveorgdetailssoftwaretoolsinp00kernpage14mode1up"><a href="https://archive.org/details/softwaretoolsinp00kern/page/14/mode/1up">1.3 Counting Lines</a></h3>
      <pre><code>
      PROGRAM
      
        linecount count lines in input
      
      USAGE
      
        linecount
      
      FUNCTION
      
        linecount counts the lines in its input and write the total as a
        line of text to the output.
      
      EXAMPLE
      
        linecount
        A single line of input.
        &lt;ENDFILE&gt;
        1
      
      </code></pre>
      <p><strong>linecount</strong>, from <a href="https://archive.org/details/softwaretoolsinp00kern/page/15/mode/1up">page 15</a><br />
      is very similar to <strong>charcount</strong> except adding a<br />
      conditional count in the loop for processing the file. In<br />
      our Oberon-07 implementation we'll check if the <code>In.Char(c)</code><br />
      call was successful but we'll add a second condition to see if the<br />
      character read was a NEWLINE. If it was I increment<br />
      our counter variable.</p>
      <pre><code>
      MODULE LineCount;
      IMPORT In, Out;
      
      PROCEDURE LineCount;
      CONST
        NEWLINE = 10;
      
      VAR
        nl : INTEGER;
        c : CHAR;
      BEGIN
        nl := 0;
        REPEAT
          In.Char(c);
          IF In.Done &amp; (ORD(c) = NEWLINE) THEN
            nl := nl + 1;
          END;
        UNTIL In.Done # TRUE;
        Out.Int(nl, 1);
        Out.Ln();
      END LineCount;
      
      BEGIN
        LineCount();
      END LineCount.
      
      </code></pre>
      <h4 id="limitations-2">Limitations</h4>
      <p>This program assumes that NEWLINE is ASCII value 10. Line delimiters<br />
      vary between operating systems.  If your OS used carriage returns<br />
      without a NEWLINE then this program would not count lines correctly.<br />
      The reader could extend the checking to support carriage returns,<br />
      new lines, and carriage return with new lines and cover most versions<br />
      of line endings.</p>
      <h3 id="14-counting-wordshttpsarchiveorgdetailssoftwaretoolsinp00kernpage14mode1up"><a href="https://archive.org/details/softwaretoolsinp00kern/page/14/mode/1up">1.4 Counting Words</a></h3>
      <pre><code>
      PROGRAM
      
        wordcount count words in input
      
      USAGE
      
        wordcount
      
      FUNCTION
      
        wordcount counts the words in its input and write the total as a
        line of text to the output. A &quot;word&quot; is a maximal sequence of characters
        not containing a blank or tab or newline.
      
      EXAMPLE
      
        wordcount
        A single line of input.
        &lt;ENDFILE&gt;
        5
      
      BUGS
      
        The definition of &quot;word&quot; is simplistic.
      
      </code></pre>
      <p><a href="https://archive.org/details/softwaretoolsinp00kern/page/17/mode/1up">Page 17</a><br />
      brings us to the <strong>wordcount</strong> program. Counting words can be<br />
      very nuanced but here K &amp; P have chosen a simple definition<br />
      which most of the time is &quot;good enough&quot; for languages like English.<br />
      A word is defined simply as an run of characters separated by<br />
      a space, tab or newline characters.  In practice most documents<br />
      will work with this minimal definition. It also makes the code<br />
      straight forward.  This is a good example of taking the simple<br />
      road if you can. It keeps this program short and sweet.</p>
      <p>If you follow along in the K &amp; P book note their rational<br />
      and choices in arriving at there solutions. There solutions<br />
      will often balance readability and clarity over machine efficiency.<br />
      While the code has progressed from &quot;if then&quot; to &quot;if then else if&quot;<br />
      logical sequence, the solution's modeled remains<br />
      clear. This means the person reading the source code can easily verify<br />
      if the approach chosen was too simple to meet their needs or it was<br />
      &quot;good enough&quot;.</p>
      <p>My Oberon-07 implementation is again very simple. Like in previous programs<br />
      I still have an outer check to see if the read worked (i.e. &quot;In.Done = TRUE&quot;),<br />
      otherwise the conditional logic is the same as the Pascal implementation.</p>
      <pre><code>
      MODULE WordCount;
      IMPORT In, Out;
      
      PROCEDURE WordCount;
      CONST
        NEWLINE = 10;
        BLANK = 32;
        TAB = 9;
      
      VAR
        nw : INTEGER;
        c : CHAR;
        inword : BOOLEAN;
      BEGIN
        nw := 0;
        inword := FALSE;
        REPEAT
          In.Char(c);
          IF In.Done THEN
            IF ((ORD(c) = BLANK) OR (ORD(c) = NEWLINE) OR (ORD(c) = TAB)) THEN
              inword := FALSE;
            ELSIF (inword = FALSE) THEN
              inword := TRUE;
              nw := nw + 1;
            END;
          END;
        UNTIL In.Done # TRUE;
        Out.Int(nw, 1);
        Out.Ln();
      END WordCount;
      
      BEGIN
        WordCount();
      END WordCount.
      
      </code></pre>
      <h2 id="15-removing-tabshttpsarchiveorgdetailssoftwaretoolsinp00kernpage20mode1up"><a href="https://archive.org/details/softwaretoolsinp00kern/page/20/mode/1up">1.5 Removing Tabs</a></h2>
      <pre><code>
      PROGRAM
      
        detab convert tabs into blanks
      
      USAGE
      
        detab
      
      FUNCTION
      
        detab copies its input to its output, expanding the horizontal
        tabs to blanks along the way, so that the output is visually
        the same as the input, but contains no tab characters. Tab stops
        are assumed to be set every four columns (i.e. 1, 5, 9, ...), so
        each tab character is replaced by from one to four blanks.
      
      EXAMPLE
      
        Usaing &quot;-&gt;&quot; as a visible tab:
      
        detab
        -&gt;col 1-&gt;2-&gt;34-&gt;rest
            col 1   2   34  rest
      
      BUGS
      
        detab is naive about backspaces, vertical motions, and
        non-printing characters.
      
      </code></pre>
      <p>The source code for &quot;detab&quot; can be found on<br />
      <a href="https://archive.org/details/softwaretoolsinp00kern/page/24/mode/1up">page 24</a><br />
      in the last section of chapter 1. <strong>detab</strong> removes<br />
      tabs and replaces them with spaces. Rather than a simple &quot;tab&quot;<br />
      replaced with four spaces <strong>detab</strong> preserves a concept found on<br />
      typewriters called &quot;tab stops&quot;. In 1981 typewrites were still widely<br />
      used though word processing software would become common. Supporting the<br />
      &quot;tab stop&quot; model means the program works with what office workers would<br />
      expect from older tools like the typewriter or even the computer's<br />
      teletype machine. I think this shows an important aspect of writing<br />
      programs. Write the program for people, support existing common concepts<br />
      they will likely know.</p>
      <p>K &amp; P implementation includes separate source files<br />
      for setting tab stops and checking a tab stop.  The Pascal K &amp; P<br />
      wrote for didn't support separate source files or program modules. Recent Pascal<br />
      versions did support the concept of modularization (e.g. UCSD Pascal). Since<br />
      and significant goal of K &amp; P was portability they needed to come up<br />
      with a solution that worked on the &quot;standard&quot; Pascal compilers available on<br />
      minicomputers and mainframes and not write their solution to a specific<br />
      Pascal system like UCSD Pascal (see Appendix, &quot;IMPLEMENTATION<br />
      PRIMITIVES <a href="https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/315/mode/1up">page 315</a>).<br />
      Modularization facilitates code reuse and like information hiding is an<br />
      import software technique. Unfortunately the preprocessor approach doesn't<br />
      support information hiding.</p>
      <p>To facilitate code reuse the K &amp; P book includes a preprocessor as part<br />
      of the Pascal development tools (see <a href="https://archive.org/stream/softwaretoolsinp00kern?ref=ol#page/71/mode/1up">page 71</a><br />
      for implementation). The preprocessor written<br />
      in Pascal was based on the early versions of the &quot;C&quot; preprocessor<br />
      they had available in the early UNIX systems. Not terribly Pascal<br />
      like but it worked and allowed the two files to be shared between<br />
      this program and one in the next chapter.</p>
      <p>Oberon-07 of course benefits from all of Wirth's language improvements<br />
      that came after Pascal. Oberon-07 supports modules and as such<br />
      there is no need for a preprocessor.  Because of Oberon-07's module<br />
      support I've implemented the Oberon version using two files<br />
      rather than three. My main program file is &quot;Detab.Mod&quot;,<br />
      the supporting library module is &quot;Tabs.Mod&quot;. &quot;Tabs&quot; is where I<br />
      define our tab stop data structure as well as the<br />
      procedures that operating on that data structure.</p>
      <p>Let's look at the first part, &quot;Detab.Mod&quot;. This is the module<br />
      that forms the program and it features an module level &quot;BEGIN/END&quot; block.<br />
      In that block I call &quot;Detab();&quot; which implements the program's functionality.<br />
      I import &quot;In&quot;, &quot;Out&quot; as before but I also import &quot;Tabs&quot; which I will show next.<br />
      Like my previous examples I validate the read was successful before proceeding<br />
      with the logic presented in the original Pascal and deciding<br />
      what to write to standard output.</p>
      <pre><code>
      MODULE Detab;
        IMPORT In, Out, Tabs;
      
      CONST
        NEWLINE = 10;
        TAB = 9;
        BLANK = 32;
      
      PROCEDURE Detab;
      VAR
        c : CHAR;
        col : INTEGER;
        tabstops : Tabs.TabType;
      BEGIN
        Tabs.SetTabs(tabstops); (* set initial tab stops *)
        col := 1;
        REPEAT
          In.Char(c);
          IF In.Done THEN
            IF (ORD(c) = TAB) THEN
              REPEAT
                Out.Char(CHR(BLANK));
                col := col + 1;
              UNTIL Tabs.TabPos(col, tabstops);
            ELSIF (ORD(c) = NEWLINE) THEN
              Out.Char(c);
              col := 1;
            ELSE
              Out.Char(c);
              col := col + 1;
            END;
          END;
        UNTIL In.Done # TRUE;
      END Detab;
      
      BEGIN
        Detab();
      END Detab.
      
      </code></pre>
      <p>Our second module is &quot;Tabs.Mod&quot;. It provides the supporting procedures<br />
      and definition of the our &quot;TabType&quot; data structure. For us this<br />
      is the first time we write a module which &quot;exports&quot; procedures<br />
      and type definitions. If you are new to Oberon, expected constants,<br />
      variables and procedures names have a trailing &quot;*&quot;. Otherwise the<br />
      Oberon compiler will assume a local use only. This is a very<br />
      powerful information hiding capability and what allows you to<br />
      evolve a modules' internal implementation independently of the<br />
      programs that rely on it.</p>
      <pre><code>
      MODULE Tabs;
      
      CONST
        MAXLINE = 1000; (* or whatever *)
      
      TYPE
        TabType* = ARRAY MAXLINE OF BOOLEAN;
      
      (* TabPos -- return TRUE if col is a tab stop *)
      PROCEDURE TabPos*(col : INTEGER; VAR tabstops : TabType) : BOOLEAN;
        VAR res : BOOLEAN;
      BEGIN
        res := FALSE; (* Initialize our internal default return value *)
        IF (col &gt;= MAXLINE) THEN
          res := TRUE;
        ELSE
          res := tabstops[col];
        END;
        RETURN res
      END TabPos;
      
      (* SetTabs -- set initial tab stops *)
      PROCEDURE SetTabs*(VAR tabstops: TabType);
      CONST
        TABSPACE = 4; (* 4 spaces per tab *)
      VAR
        i : INTEGER;
      BEGIN
        (* NOTE: Arrays in Oberon start at zero, we want to
           stop at the last cell *)
        FOR i := 0 TO (MAXLINE - 1) DO
          tabstops[i] := ((i MOD TABSPACE) = 0);
        END;
      END SetTabs;
      
      END Tabs.
      
      </code></pre>
      <p>NOTE: This module is used by &quot;Detab.Mod&quot; and &quot;Entab.Mod&quot;<br />
      and provides for common type definitions and code reuse.<br />
      We exported <code>TabType</code>, <code>TabPos</code> and <code>SetTabs</code>. Everything else<br />
      is private to this module.</p>
      <h2 id="in-closing">In closing</h2>
      <p>This post briefly highlighted ports of the programs<br />
      presented in Chapter 1 of &quot;Software Tools in Pascal&quot;.<br />
      Below are links to my source files of the my<br />
      implementations inspired by the K &amp; P book. Included<br />
      in each Oberon module source after the module definition<br />
      is transcribed text of the program documentation as well<br />
      as transcribed text of the K &amp; P Pascal implementations.<br />
      Each file should compiler without modification using the<br />
      OBNC compiler.  By default the OBNC compiler will use the<br />
      module's name as the name of the executable version. I<br />
      I have used mixed case module names, if you prefer lower<br />
      case executable names use the &quot;-o&quot; option with the OBNC<br />
      compiler.</p>
      <pre><code>
          obnc -o copy CopyProg.Mod
          obnc -o charcount CharCount.Mod
          obnc -o linecount LineCount.Mod
          obnc -o wordcount WordCount.Mod
          obnc -o detab Detab.Mod
      
      </code></pre>
      <p>If you happen to be using The <a href="http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler">Oxford Oberon Compiler</a><br />
      you need to rename the files ending in &quot;.Mod&quot; to &quot;.m&quot;<br />
      and you can compiler with the following command.</p>
      <pre><code>    obc -07 -o copyprog CopyProg.m
          obc -07 -o charcount CharCount.m
          obc -07 -o linecount LineCount.m
          obc -07 -o wordcount WordCount.m
          obc -07 -o detab Tabs.m Detab.m
      </code></pre>
      <p>Note the line for compiling &quot;Detab&quot; with <strong>obc</strong>, your<br />
      local modules need to become before the module calling them.</p>
      <ul>
      <li><a href="CopyProg.Mod">CopyProg</a></li>
      <li><a href="CharCount.Mod">CharCount</a></li>
      <li><a href="LineCount.Mod">LineCount</a></li>
      <li><a href="WordCount.Mod">WordCount</a></li>
      <li><a href="Detab.Mod">Detab</a>
      <ul>
      <li><a href="Tabs.Mod">Tabs</a>, this one we'll revisit in next installment.</li>
      </ul>
      </li>
      </ul>
      <h1 id="next">Next</h1>
      <ul>
      <li><a href="../../10/31/Filters.html">Filters</a></li>
      </ul>
      
    </article>
  </section>
  <footer>
    <p>copyright © 2016 - 2025 R. S. Doiel<br /> <a
    href="/rssfeed.html">RSS</a> feeds and website built with <a
    href="https://rsdoiel.github.io/antennaApp">antennaApp</a>, Bash, Make and <a
    href="https://pandoc.org">Pandoc</a>.</p>
  </footer>

    <script type="module" src="/modules/copyToClipboard.js"></script>
    <script type="module">
      await import('/pagefind/pagefind-highlight.js');
      new PagefindHighlight({ highlightParam: "highlight" });
    </script>
</body>
</html>
