<!doctype html>
<html lang="en-US">
<head>
  <meta charset="utf-8" >
  <meta name="generator" content="antenna/0.0.15" >
  <meta name="date" content="2025-10-14T22:54:35-07:00" >
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
  <meta name="language" content="EN" >
  <title>R. S. Doiel, Software Engineer/Analyst &mdash; Robert's ramblings</title>
  <link title="R. S. Doiel, Software Engineer/Analyst &mdash; Robert's ramblings" href="Dates-and-Clock.md" rel="altenate" type="text/markdown" >
  <link rel="stylesheet" type="text/css" href="/css/site.css" >
  <link rel="alternate" title="Recent Blog Post" type="application/rss+xml" href="index.xml" >
  <link title="Archive of Blog Posts" type="application/rss+xml" href="archive.xml" rel="alternate" >
  <link rel="alternate" title="Markdown source for page" type="application/markdown" href="index.md" >
  <link rel="search" type="application/opensearchdescription+xml" title="Robert's Rambling Search Engine" href="osd.xml" >
  <script type="module" src="/modules/copyToClipboard.js" ></script>
</head>
<body>
  <nav>
    <ul>
    <li><a href="/" title="R. S. Doiel"><img class="blog-logo" src="/media/Wee-Free-Doiels-Summer-Reading.svg" alt="Wee Free Doiels, Summer Reading"></a></li>
    <li><a href="/">R. S. Doiel</a></li>
    <li><a href="/about.html">About</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/presentations.html">Presentations</a></li>
    <li><a href="/series/">Series</a></li>
    <li><a href="/search.html">Search</a></li>
    <li><a href="https://github.com/rsdoiel">GitHub</a></li>
    <li><a href="/rss.xml" title="RSS Feed">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9"></path>
    <path d="M4 4a16 16 0 0 1 16 16"></path>
    <circle cx="5" cy="19" r="1"></circle> </svg> RSS </a></li>
    </ul>
  </nav>

  <section>
    <article data-published="2020-11-27" data-link="https://rsdoiel.github.io/blog/2020/11/27/Dates-and-Clock.html">
      <h1>Dates and Clock</h1>
      <p>By R. S. Doiel, 2020-11-27</p>
      <p>The <a href="http://www.edm2.com/index.php/The_Oakwood_Guidelines_for_Oberon-2_Compiler_Developers#The_Oakwood_Guidelines">Oakwood</a>
      guidelines specified a common set of modules for Oberon-2 for writing
      programs outside of an Oberon System. A missing module from the Oakwood
      guidelines is modules for working with dates and the system clock.
      Fortunately the A2 Oberon System<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> provides a template for that
      functionality. In this article I am exploring implementing the<a href="Dates.Mod">Dates</a> and <a href="Clock.Mod">Clock</a> modules for Oberon-07. I
      also plan to go beyond the A2 implementations and provide additional
      functionality such as parsing procedures and the ability to work with
      either the date or time related attributes separately in the<code>Dates.DateTime</code> record.</p>
      <h2>Divergences</h2>
      <p>One of the noticeable differences between Oberon-07 and Active Oberon
      is the types that functional procedures can return. We cannot return
      an Object in Oberon-07. This is not much of a handicap as we have
      variable procedure parameters.  Likewise Active Oberon provides
      a large variety of integer number types. In Oberon-07 we have only
      INTEGER. Where I've create new procedures I've used the Oberon idiom
      of read only input parameters followed by variable parameters with
      side effects and finally parameters for the target record or values
      to be updated.</p>
      <h2>Similarities</h2>
      <p>In spite of the divergence I have split the module into two.
      The <a href="Dates.html">Dates</a> module is the one you would include in your
      program, it provides a DateTime record type which holds the integer
      values for year, month, day, hour, minute and second. It provides the
      means of parsing a date or time string, comparison, difference and addition
      of dates.  The second module <a href="Clock.html">Clock</a> provides a mechanism
      to retrieve the real time clock value from the host system and map the
      C based time object into our own DateTime record.  Clock is specific to
      OBNC method of interfacing to the C standard libraries of the host system.
      If you were to use a different Oberon compiled such as the Oxford
      Oberon Compiler you would need to re-implement Clock. Dates itself
      should be system independent and work with Oberon-07 compilers generally.</p>
      <h2>Clock</h2>
      <p>The Clock module is built from a skeleton in Oberon-07 describing the
      signatures of the procedure and an implementation in <a href="Clock.c">C</a> that
      is built using the technique for discussed in my post<a href="../../05/01/Combining-Oberon-and-C.html">Combining Oberon-07 and C with OBNC</a>. In that article I outline Karl's three step process to create a
      module that will be an interface to C code.  In Step one I create
      the Oberon module. Normally I'd leave all procedures empty and
      develop them in C. In this specific case I went ahead and wrote
      the procedure called <code>Get</code> in Oberon and left the procedure <code>GetRtcTime</code>
      blank. This allowed OBNC to generate the C code for <code>Get</code> saving
      me some time and create the skeleton for <code>GetRtcTime</code> which does
      the work interfacing with the system clock via C library calls.</p>
      <p>The interface Oberon module looked like this:</p>
      <pre><code class="language-{.oberon}">
      MODULE Clock;
      
      PROCEDURE GetRtcTime*(VAR second, minute, hour, day, month, year : INTEGER);
      BEGIN
      END GetRtcTime;
      
      PROCEDURE Get*(VAR time, date : INTEGER);
      VAR
          second, minute, hour, day, month, year : INTEGER;
      BEGIN
      	GetRtcTime(second, minute, hour, day, month, year);
      	time = ((hour * 4096) + (minute * 64)) + second;
      	date = ((year * 512) + (month * 32)) + day;
      END Get;
      
      END Clock.
      
      </code></pre>
      <p>I wrote the <code>Get</code> procedure code in Oberon-07 is the OBNC
      compiler will render the Oberon as C during the
      compilation process. I save myself writing some C code
      in by leveraging OBNC.</p>
      <p>Step two was to write <a href="ClockTest.Mod">ClockTest.Mod</a> in Oberon-07.</p>
      <pre><code class="language-{.oberon}">
      MODULE ClockTest;
      
      IMPORT Tests, Chars, Clock; (* , Out; *)
      
      CONST
          MAXSTR = Chars.MAXSTR;
      
      VAR
          title : ARRAY MAXSTR OF CHAR;
          success, errors : INTEGER;
      
      PROCEDURE TestGetRtcTime() : BOOLEAN;
      VAR second, minute, hour, day, month, year : INTEGER; 
          test, expected, result: BOOLEAN;
      BEGIN
          test := TRUE;
          second := 0; minute := 0; hour := 0;
          day := 0; month := 0; year := 0;
          expected := TRUE;
          Clock.GetRtcTime(second, minute, hour, day, month, year);
      
      
          result := (year &gt; 1900);
          Tests.ExpectedBool(expected, result, 
                &quot;year should be greater than 1900&quot;, test);
          result := (month &gt;= 0) &amp; (month &lt;= 11);
          Tests.ExpectedBool(expected, result,
                &quot;month should be [0, 11]&quot;, test);
          result := (day &gt;= 1) &amp; (day &lt;= 31);
          Tests.ExpectedBool(expected, result,
                &quot;day should be non-zero&quot;, test);
      
          result := (hour &gt;= 0) &amp; (hour &lt;= 23);
          Tests.ExpectedBool(expected, result,
                &quot;hour should be [0, 23]&quot;, test);
          result := (minute &gt;= 0) &amp; (minute &lt;= 59);
          Tests.ExpectedBool(expected, result, 
                &quot;minute should be [0, 59]&quot;, test);
          result := (second &gt;= 0) &amp; (second &lt;= 60);
          Tests.ExpectedBool(expected, result,
                &quot;second year should be [0,60]&quot;, test);
          RETURN test
      END TestGetRtcTime;
      
      PROCEDURE TestGet() : BOOLEAN;
      VAR time, date : INTEGER; 
          test, expected, result : BOOLEAN;
      BEGIN
          test := TRUE;
          time := 0;
          date := 0;
          Clock.Get(time, date);
          expected := TRUE;
          result := (time &gt; 0);
          Tests.ExpectedBool(expected, result,
              &quot;time should not be zero&quot;, test);
          result := (date &gt; 0);
          Tests.ExpectedBool(expected, result,
              &quot;date should not be zero&quot;, test);
      
          RETURN test
      END TestGet;
      
      BEGIN
          Chars.Set(&quot;Clock module test&quot;, title);
          success := 0; errors := 0;
          Tests.Test(TestGetRtcTime, success, errors);
          Tests.Test(TestGet, success, errors);
          Tests.Summarize(title, success, errors);
      END ClockTest.
      
      </code></pre>
      <p>ClockTest is a simple test module for <a href="Clock.Mod">Clock.Mod</a>.
      It also serves the role when compiled with OBNC to create the
      template C code for <a href="Clock.c">Clock.c</a>. Here's the steps we
      take to generate <code>Clock.c</code> with OBNC:</p>
      <pre><code class="language-{.shell}">
      obnc ClockTest.Mod
      mv .obnc/Clock.c ./
      vi Clock.c
      
      </code></pre>
      <p>After compiling <code>.obnc/Clock.c</code> I then moved <code>.obnc/Clock.c</code>
      to my working directory. Filled in the C version of<code>GetRtcTime</code> function and modified my <a href="Clock.Mod">Clock.Mod</a>
      to contain my empty procedure.</p>
      <p>The finally version of Clock.c looks like (note how we need to
      include &quot;Clock.h&quot; in the head of the our C source file).</p>
      <pre><code class="language-{.c}">
      /*GENERATED BY OBNC 0.16.1*/
      
      #include &quot;.obnc/Clock.h&quot;
      #include &lt;obnc/OBNC.h&gt;
      #include &lt;time.h&gt;
      
      #define OBERON_SOURCE_FILENAME &quot;Clock.Mod&quot;
      
      void Clock__GetRtcTime_(OBNC_INTEGER *second_, OBNC_INTEGER *minute_,
           OBNC_INTEGER *hour_, OBNC_INTEGER *day_,
           OBNC_INTEGER *month_, OBNC_INTEGER *year_)
      {
          time_t now;
          struct tm *time_info;
          now = time(NULL);
          time_info = localtime(&amp;now);
          *second_ = time_info-&gt;tm_sec;
          *minute_ = time_info-&gt;tm_min;
          *hour_ = time_info-&gt;tm_hour;
          *day_ = time_info-&gt;tm_mday;
          *month_ = time_info-&gt;tm_mon;
          *year_ = (time_info-&gt;tm_year) + 1900;
      }
      
      
      void Clock__Get_(OBNC_INTEGER *time_, OBNC_INTEGER *date_)
      {
      	OBNC_INTEGER second_, minute_, hour_, day_, month_, year_;
      
      	Clock__GetRtcTime_(&amp;second_, &amp;minute_, 
                             &amp;hour_, &amp;day_, &amp;month_, &amp;year_);
      	(*time_) = ((hour_ * 4096) + (minute_ * 64)) + second_;
      	(*date_) = ((year_ * 512) + (month_ * 32)) + day_;
      }
      
      
      void Clock__Init(void)
      {
      }
      
      </code></pre>
      <p>The final version of Clock.Mod looks like</p>
      <pre><code class="language-{.oberon}">
      MODULE Clock;
      
      PROCEDURE GetRtcTime*(VAR second, minute, 
                            hour, day, month, year : INTEGER);
      BEGIN
      END GetRtcTime;
      
      PROCEDURE Get*(VAR time, date : INTEGER);
      BEGIN
      END Get;
      
      END Clock.
      
      </code></pre>
      <p>Step three was to re-compile <code>ClockTest.Mod</code> and run the tests.</p>
      <pre><code class="language-{.shell}">
          obnc ClockTest.Mod
          ./ClockTest
      
      </code></pre>
      <h2>Dates</h2>
      <p>The dates module provides a rich variety of
      procedures for working with dates. This includes parsing
      date strings into <code>DateTime</code> records, testing strings for
      supported date formats, setting dates or time in a <code>DateTime</code>
      record as well as comparison, difference and addition
      (both addition and subtraction) of dates. Tests for the Dates
      module is implemented in <a href="DatesTest.Mod">DatesTest.Mod</a>.</p>
      <pre><code class="language-{.oberon}">
      MODULE Dates;
      IMPORT Chars, Strings, Clock, Convert := extConvert;
      
      CONST
          MAXSTR = Chars.MAXSTR;
          SHORTSTR = Chars.SHORTSTR;
      
          YYYYMMDD* = 1; (* YYYY-MM-DD format *)
          MMDDYYYY* = 2; (* MM/DD/YYYY format *)
          YYYYMMDDHHMMSS* = 3; (* YYYY-MM-DD HH:MM:SS format *)
      
      TYPE
          DateTime* = RECORD
              year*, month*, day*, hour*, minute*, second* : INTEGER
          END;
      
      VAR
          (* Month names, January = 0, December = 11 *)
          Months*: ARRAY 23 OF ARRAY 10 OF CHAR;
          (* Days of week, Monday = 0, Sunday = 6 *)
          Days*: ARRAY 7 OF ARRAY 10 OF CHAR;
          DaysInMonth: ARRAY 12 OF INTEGER;
      
      
      (* Set -- initialize a date record year, month and day values *)
      PROCEDURE Set*(year, month, day, hour, minute, second : INTEGER; 
                     VAR dt: DateTime);
      BEGIN
          dt.year := year;
          dt.month := month;
          dt.day := day;
          dt.hour := hour;
          dt.minute := minute;
          dt.second := second;
      END Set;
      
      (* SetDate -- set a Date record's year, month and day attributes *)
      PROCEDURE SetDate*(year, month, day : INTEGER; VAR dt: DateTime);
      BEGIN
          dt.year := year;
          dt.month := month;
          dt.day := day;
      END SetDate;
      
      (* SetTime -- set a Date record's hour, minute, second attributes *)
      PROCEDURE SetTime*(hour, minute, second : INTEGER; VAR dt: DateTime);
      BEGIN
          dt.hour := hour;
          dt.minute := minute;
          dt.second := second;
      END SetTime;
      
      (* Copy -- copy the values from one date record to another *)
      PROCEDURE Copy*(src : DateTime; VAR dest : DateTime);
      BEGIN
          dest.year := src.year;
          dest.month := src.month;
          dest.day := src.day;
          dest.hour := src.hour;
          dest.minute := src.minute;
          dest.second := src.second;
      END Copy;
      
      (* ToChars -- converts a date record into an array of chars using
      the format constant. Formats supported are YYYY-MM-DD HH:MM:SS
      or MM/DD/YYYY HH:MM:SS. *)
      PROCEDURE ToChars*(dt: DateTime; fmt : INTEGER;
                         VAR src : ARRAY OF CHAR);
      VAR ok : BOOLEAN;
      BEGIN
          Chars.Clear(src);
          IF fmt = YYYYMMDD THEN
              Chars.AppendInt(dt.year, 4, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;-&quot;, src);
              Chars.AppendInt(dt.month, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;-&quot;, src);
              Chars.AppendInt(dt.day, 2, &quot;0&quot;, src);
          ELSIF fmt = MMDDYYYY THEN
              Chars.AppendInt(dt.month, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;/&quot;, src);
              Chars.AppendInt(dt.day, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;/&quot;, src);
              Chars.AppendInt(dt.year, 4, &quot;0&quot;, src);
          ELSIF fmt = YYYYMMDDHHMMSS THEN
              Chars.AppendInt(dt.year, 4, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;-&quot;, src);
              Chars.AppendInt(dt.month, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;-&quot;, src);
              Chars.AppendInt(dt.day, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot; &quot;, src);
              Chars.AppendInt(dt.hour, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;:&quot;, src);
              Chars.AppendInt(dt.minute, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;:&quot;, src);
              Chars.AppendInt(dt.second, 2, &quot;0&quot;, src);
          END;
      END ToChars;
      
      (*
       * Date and Time functions very much inspired by A2 but
       * adapted for use in Oberon-07 and OBNC compiler.
       *)
      
      (* LeapYear -- returns TRUE if 'year' is a leap year *)
      PROCEDURE LeapYear*(year: INTEGER): BOOLEAN;
      BEGIN
      	RETURN (year &gt; 0) &amp; (year MOD 4 = 0) &amp; 
                 (~(year MOD 100 = 0) OR (year MOD 400 = 0))
      END LeapYear;
      
      (* NumOfDays -- number of days, returns the number of 
      days in that month *)
      PROCEDURE NumOfDays*(year, month: INTEGER): INTEGER;
      VAR result : INTEGER;
      BEGIN
          result := 0;
      	DEC(month);
      	IF ((month &gt;= 0) &amp; (month &lt; 12)) THEN
      	    IF (month = 1) &amp; LeapYear(year) THEN
                  result := DaysInMonth[1]+1;
      	    ELSE
                  result := DaysInMonth[month];
      	    END;
          END;
          RETURN result
      END NumOfDays;
      
      (* IsValid -- checks if the attributes set in a 
      DateTime record are valid *)
      PROCEDURE IsValid*(dt: DateTime): BOOLEAN;
      BEGIN
      	RETURN ((dt.year &gt; 0) &amp; (dt.month &gt; 0) &amp;
                 (dt.month &lt;= 12) &amp; (dt.day &gt; 0) &amp;
                 (dt.day &lt;= NumOfDays(dt.year, dt.month)) &amp;
                 (dt.hour &gt;= 0) &amp; (dt.hour &lt; 24) &amp; (dt.minute &gt;= 0) &amp;
                 (dt.minute &lt; 60) &amp; (dt.second &gt;= 0) &amp; (dt.second &lt; 60))
      END IsValid;
      
      (* IsValidDate -- checks to see if a datetime record 
      has valid day, month and year attributes *)
      PROCEDURE IsValidDate*(dt: DateTime) : BOOLEAN;
      BEGIN
      	RETURN (dt.year &gt; 0) &amp; (dt.month &gt; 0) &amp;
                 (dt.month &lt;= 12) &amp; (dt.day &gt; 0) &amp;
                 (dt.day &lt;= NumOfDays(dt.year, dt.month))
      END IsValidDate;
      
      (* IsValidTime -- checks if the hour, minute, second
      attributes set in a DateTime record are valid *)
      PROCEDURE IsValidTime*(dt: DateTime): BOOLEAN;
      BEGIN
      	RETURN (dt.hour &gt;= 0) &amp; (dt.hour &lt; 24) &amp;
                 (dt.minute &gt;= 0) &amp; (dt.minute &lt; 60) &amp;
                 (dt.second &gt;= 0) &amp; (dt.second &lt; 60)
      END IsValidTime;
      
      
      (* OberonToDateTime -- convert an Oberon date/time 
      to a DateTime structure *)
      PROCEDURE OberonToDateTime*(Date, Time: INTEGER; 
                                  VAR dt : DateTime);
      BEGIN
      	dt.second := Time MOD 64; Time := Time DIV 64;
      	dt.minute := Time MOD 64; Time := Time DIV 64;
      	dt.hour := Time MOD 24;
      	dt.day := Date MOD 32; Date := Date DIV 32;
      	dt.month := (Date MOD 16) + 1; Date := Date DIV 16;
      	dt.year := Date;
      END OberonToDateTime;
      
      (* DateTimeToOberon -- convert a DateTime structure
      to an Oberon date/time *)
      PROCEDURE DateTimeToOberon*(dt: DateTime;
                                  VAR date, time: INTEGER);
      BEGIN
      	IF IsValid(dt) THEN
      	date := (dt.year)*512 + dt.month*32 + dt.day;
      	time := dt.hour*4096 + dt.minute*64 + dt.second
          ELSE
              date := 0;
              time := 0;
          END;
      END DateTimeToOberon;
      
      (* Now -- returns the current date and time as a
      DateTime record. *)
      PROCEDURE Now*(VAR dt: DateTime);
      VAR d, t: INTEGER;
      BEGIN
      	Clock.Get(t, d);
      	OberonToDateTime(d, t, dt);
      END Now;
      
      
      (* WeekDate -- returns the ISO 8601 year number,
      week number &amp; week day (Monday=1, ....Sunday=7)
      Algorithm is by Rick McCarty, 
      http://personal.ecu.edu/mccartyr/ISOwdALG.txt
      *)
      PROCEDURE WeekDate*(dt: DateTime; 
                          VAR year, week, weekday: INTEGER);
      VAR doy, i, yy, c, g, jan1: INTEGER; leap: BOOLEAN;
      BEGIN
      	IF IsValid(dt) THEN
      		leap := LeapYear(dt.year);
      		doy := dt.day; i := 0;
      		WHILE (i &lt; (dt.month - 1)) DO
                  doy := doy + DaysInMonth[i];
                  INC(i);
              END;
      		IF leap &amp; (dt.month &gt; 2) THEN
                  INC(doy);
              END;
      		yy := (dt.year - 1) MOD 100;
              c := (dt.year - 1) - yy;
              g := (yy + yy) DIV 4;
      		jan1 := 1 + (((((c DIV 100) MOD 4) * 5) + g) MOD 7);
      
      		weekday := 1 + (((doy + (jan1 - 1)) - 1) MOD 7);
              (* does doy fall in year-1 ? *)
      		IF (doy &lt;= (8 - jan1)) &amp; (jan1 &gt; 4) THEN 
      			year := dt.year - 1;
      			IF (jan1 = 5) OR ((jan1 = 6) &amp; LeapYear(year)) THEN
                      week := 53;
      			ELSE
                      week := 52;
      			END;
      		ELSE
      			IF leap THEN
                      i := 366;
                  ELSE
                      i := 365;
                  END;
      			IF ((i - doy) &lt; (4 - weekday)) THEN
      				year := dt.year + 1;
      				week := 1;
      			ELSE
      				year := dt.year;
      				i := doy + (7-weekday) + (jan1-1);
      				week := i DIV 7;
      				IF (jan1 &gt; 4) THEN
                          DEC(week);
                      END;
      			END;
      		END;
      	ELSE
      		year := -1; week := -1; weekday := -1;
      	END;
      END WeekDate;
      
      (* Equal -- compare to date records to see if they 
      are equal values *)
      PROCEDURE Equal*(t1, t2: DateTime) : BOOLEAN;
      BEGIN
      	RETURN ((t1.second = t2.second) &amp;
                  (t1.minute = t2.minute) &amp; (t1.hour = t2.hour) &amp;
                  (t1.day = t2.day) &amp; (t1.month = t2.month) &amp;
                  (t1.year = t2.year))
      END Equal;
      
      (* compare -- used in Compare only for comparing
      specific values, returning an appropriate -1, 0, 1 *)
      PROCEDURE compare(t1, t2 : INTEGER) : INTEGER;
      VAR result : INTEGER;
      BEGIN
      	IF (t1 &lt; t2) THEN
              result := -1;
      	ELSIF (t1 &gt; t2) THEN
              result := 1;
      	ELSE
              result := 0;
      	END;
      	RETURN result
      END compare;
      
      (* Compare -- returns -1 if (t1 &lt; t2), 
      0 if (t1 = t2) or 1 if (t1 &gt;  t2) *)
      PROCEDURE Compare*(t1, t2: DateTime) : INTEGER;
      VAR result : INTEGER;
      BEGIN
      	result := compare(t1.year, t2.year);
      	IF (result = 0) THEN
      		result := compare(t1.month, t2.month);
      		IF (result = 0) THEN
      			result := compare(t1.day, t2.day);
      			IF (result = 0) THEN
      				result := compare(t1.hour, t2.hour);
      				IF (result = 0) THEN
      					result := compare(t1.minute, t2.minute);
      					IF (result = 0) THEN
      						result := compare(t1.second, t2.second);
      					END;
      				END;
      			END;
      		END;
      	END;
      	RETURN result
      END Compare;
      
      (* CompareDate -- compare day, month and year
      values only *)
      PROCEDURE CompareDate*(t1, t2: DateTime) : INTEGER;
      VAR result : INTEGER;
      BEGIN
      	result := compare(t1.year, t2.year);
      	IF (result = 0) THEN
      		result := compare(t1.month, t2.month);
      		IF (result = 0) THEN
      			result := compare(t1.day, t2.day);
      		END;
      	END;
      	RETURN result
      END CompareDate;
      
      (* CompareTime -- compare second, minute and
      hour values only *)
      PROCEDURE CompareTime*(t1, t2: DateTime) : INTEGER;
      VAR result : INTEGER;
      BEGIN
      	result := compare(t1.hour, t2.hour);
      	IF (result = 0) THEN
      		result := compare(t1.minute, t2.minute);
      		IF (result = 0) THEN
      			result := compare(t1.second, t2.second);
      		END;
      	END;
      	RETURN result
      END CompareTime;
      
      
      
      (* TimeDifferences -- returns the absolute time
      difference between
      t1 and t2.
      
      Note that leap seconds are not counted,
      see http://www.eecis.udel.edu/~mills/leap.html *)
      PROCEDURE TimeDifference*(t1, t2: DateTime;
                    VAR days, hours, minutes, seconds : INTEGER);
      CONST 
          SecondsPerMinute = 60; 
          SecondsPerHour = 3600; 
          SecondsPerDay = 86400;
      VAR start, end: DateTime; year, month, second : INTEGER;
      BEGIN
      	IF (Compare(t1, t2) = -1) THEN
              start := t1;
              end := t2;
          ELSE
              start := t2;
              end := t1;
          END;
      	IF (start.year = end.year) &amp; (start.month = end.month) &amp;
             (start.day = end.day) THEN
      		second := end.second - start.second + 
                        ((end.minute - start.minute) * SecondsPerMinute) +
                        ((end.hour - start.hour) * SecondsPerHour);
      		days := 0;
              hours := 0;
              minutes := 0;
      	ELSE
      		(* use start date/time as reference point *)
      		(* seconds until end of the start.day *)
      		second := (SecondsPerDay - start.second) -
                        (start.minute * SecondsPerMinute) -
                        (start.hour * SecondsPerHour);
      		IF (start.year = end.year) &amp;
                 (start.month = end.month) THEN
      			(* days between start.day and end.day *)
      			days := (end.day - start.day) - 1;
      		ELSE
      			(* days until start.month ends excluding start.day *)
      			days := NumOfDays(start.year, start.month) - start.day;
      			IF (start.year = end.year) THEN
      				(* months between start.month and end.month *)
      				FOR month := start.month + 1 TO end.month - 1 DO
      					days := days + NumOfDays(start.year, month);
      				END;
      			ELSE
      				(* days until start.year ends (excluding start.month) *)
      				FOR month := start.month + 1 TO 12 DO
      					days := days + NumOfDays(start.year, month);
      				END;
                      (* days between start.years and end.year *)
      				FOR year := start.year + 1 TO end.year - 1 DO
      					IF LeapYear(year) THEN days := days + 366; 
                          ELSE days := days + 365; END;
      				END;
                      (* days until we reach end.month in end.year *)
      				FOR month := 1 TO end.month - 1 DO
      					days := days + NumOfDays(end.year, month);
      				END;
      			END;
      			(* days in end.month until reaching end.day excluding end.day *)
      			days := (days + end.day) - 1;
      		END;
      		(* seconds in end.day *)
      		second := second + end.second +
                        (end.minute * SecondsPerMinute) +
                        (end.hour * SecondsPerHour);
      	END;
      	days := days + (second DIV SecondsPerDay); 
          second := (second MOD SecondsPerDay);
      	hours := (second DIV SecondsPerHour); 
          second := (second MOD SecondsPerHour);
      	minutes := (second DIV SecondsPerMinute);
          second := (second MOD SecondsPerMinute);
      	seconds := second;
      END TimeDifference;
      
      (* AddYear -- Add/Subtract a number of years to/from date *)
      PROCEDURE AddYears*(VAR dt: DateTime; years : INTEGER);
      BEGIN
      	ASSERT(IsValid(dt));
      	dt.year := dt.year + years;
      	ASSERT(IsValid(dt));
      END AddYears;
      
      (* AddMonths -- Add/Subtract a number of months to/from date.
      This will adjust date.year if necessary *)
      PROCEDURE AddMonths*(VAR dt: DateTime; months : INTEGER);
      VAR years : INTEGER;
      BEGIN
      	ASSERT(IsValid(dt));
      	years := months DIV 12;
      	dt.month := dt.month + (months MOD 12);
      	IF (dt.month &gt; 12) THEN
      		dt.month := dt.month - 12;
      		INC(years);
      	ELSIF (dt.month &lt; 1) THEN
      		dt.month := dt.month + 12;
      		DEC(years);
      	END;
      	IF (years # 0) THEN AddYears(dt, years); END;
      	ASSERT(IsValid(dt));
      END AddMonths;
      
      (* AddDays --  Add/Subtract a number of days to/from date.
      This will adjust date.month and date.year if necessary *)
      PROCEDURE AddDays*(VAR dt: DateTime; days : INTEGER);
      VAR nofDaysLeft : INTEGER;
      BEGIN
      	ASSERT(IsValid(dt));
      	IF (days &gt; 0) THEN
      		WHILE (days &gt; 0) DO
      			nofDaysLeft := NumOfDays(dt.year, dt.month) - dt.day;
      			IF (days &gt; nofDaysLeft) THEN
      				dt.day := 1;
      				AddMonths(dt, 1);
                      (* -1 because we consume the first day 
                          of the next month *)
      				days := days - nofDaysLeft - 1;
      			ELSE
      				dt.day := dt.day + days;
      				days := 0;
      			END;
      		END;
      	ELSIF (days &lt; 0) THEN
      		days := -days;
      		WHILE (days &gt; 0) DO
      			nofDaysLeft := dt.day - 1;
      			IF (days &gt; nofDaysLeft) THEN
                      (* otherwise, dt could become an invalid 
                         date if the previous month has less 
                         days than dt.day *)
      				dt.day := 1; 
      				AddMonths(dt, -1);
      				dt.day := NumOfDays(dt.year, dt.month);
                      (* -1 because we consume the last day 
                         of the previous month *)
      				days := days - nofDaysLeft - 1;
      			ELSE
      				dt.day := dt.day - days;
      				days := 0;
      			END;
      		END;
      	END;
      	ASSERT(IsValid(dt));
      END AddDays;
      
      (* AddHours -- Add/Subtract a number of hours to/from date.
      This will adjust date.day, date.month and date.year if necessary *)
      PROCEDURE AddHours*(VAR dt: DateTime; hours : INTEGER);
      VAR days : INTEGER;
      BEGIN
      	ASSERT(IsValid(dt));
      	dt.hour := dt.hour + hours;
      	days := dt.hour DIV 24;
      	dt.hour := dt.hour MOD 24;
      	IF (dt.hour &lt; 0) THEN
      		dt.hour := dt.hour + 24;
      		DEC(days);
      	END;
      	IF (days # 0) THEN AddDays(dt, days); END;
      	ASSERT(IsValid(dt));
      END AddHours;
      
      (* AddMinutes -- Add/Subtract a number of minutes to/from date.
      This will adjust date.hour, date.day, date.month and date.year
      if necessary *)
      PROCEDURE AddMinutes*(VAR dt: DateTime; minutes : INTEGER);
      VAR hours : INTEGER;
      BEGIN
      	ASSERT(IsValid(dt));
      	dt.minute := dt.minute + minutes;
      	hours := dt.minute DIV 60;
      	dt.minute := dt.minute MOD 60;
      	IF (dt.minute &lt; 0) THEN
      		dt.minute := dt.minute + 60;
      		DEC(hours);
      	END;
      	IF (hours # 0) THEN AddHours(dt, hours); END;
      	ASSERT(IsValid(dt));
      END AddMinutes;
      
      (* AddSeconds -- Add/Subtract a number of seconds to/from date.
      This will adjust date.minute, date.hour, date.day, date.month and
      date.year if necessary *)
      PROCEDURE AddSeconds*(VAR dt: DateTime; seconds : INTEGER);
      VAR minutes : INTEGER;
      BEGIN
      	ASSERT(IsValid(dt));
      	dt.second := dt.second + seconds;
      	minutes := dt.second DIV 60;
      	dt.second := dt.second MOD 60;
      	IF (dt.second &lt; 0) THEN
      		dt.second := dt.second + 60;
      		DEC(minutes);
      	END;
      	IF (minutes # 0) THEN AddMinutes(dt, minutes); END;
      	ASSERT(IsValid(dt));
      END AddSeconds;
      
      
      (* IsDateString -- return TRUE if the ARRAY OF CHAR is 10 characters
      long and is either in the form of YYYY-MM-DD or MM/DD/YYYY where
      Y, M and D are digits.
      NOTE: is DOES NOT check the ranges of the digits. *)
      PROCEDURE IsDateString*(inline : ARRAY OF CHAR) : BOOLEAN;
      VAR
          test : BOOLEAN; i, pos : INTEGER;
          src : ARRAY MAXSTR OF CHAR;
      BEGIN
          Chars.Set(inline, src);
          Chars.TrimSpace(src);
          test := FALSE;
          IF Strings.Length(src) = 10 THEN
              pos := Strings.Pos(&quot;-&quot;, src, 0);
              IF pos &gt; 0 THEN
                  IF (src[4] = &quot;-&quot;) &amp; (src[7] = &quot;-&quot;) THEN
                      test := TRUE;
                      FOR i := 0 TO 9 DO
                          IF (i # 4) &amp; (i # 7) THEN
                             IF Chars.IsDigit(src[i]) = FALSE THEN
                                 test := FALSE;
                             END;
                          END;
                      END;
                  ELSE
                      test := FALSE;
                  END;
              END;
              pos := Strings.Pos(&quot;/&quot;, src, 0);
              IF pos &gt; 0 THEN
                  IF (src[2] = &quot;/&quot;) &amp; (src[5] = &quot;/&quot;) THEN
                      test := TRUE;
                      FOR i := 0 TO 9 DO
                          IF (i # 2) &amp; (i # 5) THEN
                              IF Chars.IsDigit(src[i]) = FALSE THEN
                                  test := FALSE;
                              END;
                          END;
                      END;
                  ELSE
                      test := FALSE;
                  END;
              END;
          END;
          RETURN test
      END IsDateString;
      
      (* IsTimeString -- return TRUE if the ARRAY OF CHAR has 4 to 8
      characters in the form of H:MM, HH:MM, HH:MM:SS where H, M and S
      are digits. *)
      PROCEDURE IsTimeString*(inline : ARRAY OF CHAR) : BOOLEAN;
      VAR
          test : BOOLEAN;
          l : INTEGER;
          src : ARRAY MAXSTR OF CHAR;
      BEGIN
          Chars.Set(inline, src);
          Chars.TrimSpace(src);
          (* remove any trailing am/pm suffixes *)
          IF Chars.EndsWith(&quot;m&quot;, src) THEN
              IF Chars.EndsWith(&quot;am&quot;, src) THEN
                  Chars.TrimSuffix(&quot;am&quot;, src);
              ELSE
                  Chars.TrimSuffix(&quot;pm&quot;, src);
              END;
              Chars.TrimSpace(src);
          ELSIF Chars.EndsWith(&quot;M&quot;, src) THEN
              Chars.TrimSuffix(&quot;AM&quot;, src);
              Chars.TrimSuffix(&quot;PM&quot;, src);
              Chars.TrimSpace(src);
          ELSIF Chars.EndsWith(&quot;p&quot;, src) THEN
              Chars.TrimSuffix(&quot;p&quot;, src);
              Chars.TrimSpace(src);
          ELSIF Chars.EndsWith(&quot;P&quot;, src) THEN
              Chars.TrimSuffix(&quot;P&quot;, src);
              Chars.TrimSpace(src);
          ELSIF Chars.EndsWith(&quot;a&quot;, src) THEN
              Chars.TrimSuffix(&quot;a&quot;, src);
              Chars.TrimSpace(src);
          ELSIF Chars.EndsWith(&quot;A&quot;, src) THEN
              Chars.TrimSuffix(&quot;A&quot;, src);
              Chars.TrimSpace(src);
          END;
          Strings.Extract(src, 0, 8, src);
          test := FALSE;
          l := Strings.Length(src);
          IF (l = 4) THEN
              IF Chars.IsDigit(src[0]) &amp; (src[1] = &quot;:&quot;) &amp;
                  Chars.IsDigit(src[2]) &amp; Chars.IsDigit(src[3]) THEN
                  test := TRUE;
              ELSE
                  test := FALSE;
              END;
          ELSIF (l = 5) THEN
              IF Chars.IsDigit(src[0]) &amp; Chars.IsDigit(src[1]) &amp;
                  (src[2] = &quot;:&quot;) &amp;
                  Chars.IsDigit(src[3]) &amp; Chars.IsDigit(src[4]) THEN
                  test := TRUE;
              ELSE
                  test := FALSE;
              END;
          ELSIF (l = 8) THEN
              IF Chars.IsDigit(src[0]) &amp; Chars.IsDigit(src[1]) &amp;
                  (src[2] = &quot;:&quot;) &amp;
                  Chars.IsDigit(src[3]) &amp; Chars.IsDigit(src[4]) &amp;
                  (src[5] = &quot;:&quot;) &amp;
                  Chars.IsDigit(src[6]) &amp; Chars.IsDigit(src[7]) THEN
                  test := TRUE;
              ELSE
                  test := FALSE;
              END;
          ELSE
              test := FALSE;
          END;
          RETURN test
      END IsTimeString;
      
      (* ParseDate -- parses a date string in YYYY-MM-DD or
      MM/DD/YYYY format. *)
      PROCEDURE ParseDate*(inline : ARRAY OF CHAR;
                           VAR year, month, day : INTEGER) : BOOLEAN;
      VAR src, tmp : ARRAY MAXSTR OF CHAR; ok, b : BOOLEAN;
      BEGIN
          Chars.Set(inline, src);
          Chars.Clear(tmp);
          ok := FALSE;
      	IF IsDateString(src) THEN
              (* LIMITATION: Need to allow for more than 4 digit years! *)
              IF (src[2] = &quot;/&quot;) &amp; (src[5] = &quot;/&quot;) THEN
                  ok := TRUE;
                  Strings.Extract(src, 0, 2, tmp);
                  Convert.StringToInt(tmp, month, b);
                  ok := ok &amp; b;
                  Strings.Extract(src, 4, 2, tmp);
                  Convert.StringToInt(tmp, day, b);
                  ok := ok &amp; b;
                  Strings.Extract(src, 6, 4, tmp);
                  Convert.StringToInt(tmp, year, b);
                  ok := ok &amp; b;
              ELSIF (src[4] = &quot;-&quot;) &amp; (src[7] = &quot;-&quot;) THEN
                  ok := TRUE;
                  Strings.Extract(src, 0, 4, tmp);
                  Convert.StringToInt(tmp, year, b);
                  ok := ok &amp; b;
                  Strings.Extract(src, 5, 2, tmp);
                  Convert.StringToInt(tmp, month, b);
                  ok := ok &amp; b;
                  Strings.Extract(src, 8, 2, tmp);
                  Convert.StringToInt(tmp, day, b);
                  ok := ok &amp; b;
              ELSE
                  ok := FALSE;
              END;
          END;
          RETURN ok
      END ParseDate;
      
      (* ParseTime -- procedure for parsing time strings into hour,
      minute, second. Returns TRUE on successful parse, FALSE otherwise *)
      PROCEDURE ParseTime*(inline : ARRAY OF CHAR;
                           VAR hour, minute, second : INTEGER) : BOOLEAN;
      VAR src, tmp : ARRAY MAXSTR OF CHAR;
          ok : BOOLEAN; cur, pos, l : INTEGER;
      BEGIN
          Chars.Set(inline, src);
          Chars.Clear(tmp);
      	IF IsTimeString(src) THEN
              ok := TRUE;
              cur := 0; pos := 0;
              pos := Strings.Pos(&quot;:&quot;, src, cur);
              IF pos &gt; 0 THEN
              (* Get Hour *)
                  Strings.Extract(src, cur, pos - cur, tmp);
                  Convert.StringToInt(tmp, hour, ok);
                  IF ok THEN
                      (* Get Minute *)
                      cur := pos + 1;
                      Strings.Extract(src, cur, 2, tmp);
                      Convert.StringToInt(tmp, minute, ok);
                      IF ok THEN
                          (* Get second, optional, default to zero *)
                          pos := Strings.Pos(&quot;:&quot;, src, cur);
                          IF pos &gt; 0 THEN
                              cur := pos + 1;
                              Strings.Extract(src, cur, 2, tmp);
                              Convert.StringToInt(tmp, second, ok);
                              cur := cur + 2;
                          ELSE
                              second := 0;
                          END;
                          (* Get AM/PM, optional, adjust hour if PM *)
                          l := Strings.Length(src);
                          WHILE (cur &lt; l) &amp; Chars.IsSpace(src[cur]) DO
                              cur := cur + 1;
                          END;
                          Strings.Extract(src, cur, 2, tmp);
                          Chars.TrimSpace(tmp);
                          IF Chars.Equal(tmp, &quot;PM&quot;) OR Chars.Equal(tmp, &quot;pm&quot;) THEN
                              hour := hour + 12;
                          END;
                      ELSE
                          ok := FALSE;
                      END;
                  END;
              ELSE
                  ok := FALSE;
              END;
          ELSE
              ok := FALSE;
          END;
          IF ok THEN
              ok := ((hour &gt;= 0) &amp; (hour &lt;= 23)) &amp;
                  ((minute &gt;= 0) &amp; (minute &lt;= 59)) &amp;
                      ((second &gt;= 0) &amp; (second &lt;= 59));
          END;
          RETURN ok
      END ParseTime;
      
      
      (* Parse accepts a date array of chars in either dates, times
      or dates and times separate by spaces. Date formats supported
      include YYYY-MM-DD, MM/DD/YYYY. Time formats include
      H:MM, HH:MM, H:MM:SS, HH:MM:SS with 'a', 'am', 'p', 'pm'
      suffixes.  Dates and times can also be accepted as JSON
      expressions with the individual time compontents are specified
      as attributes, e.g. {&quot;year&quot;: 1998, &quot;month&quot;: 12, &quot;day&quot;: 10,
      &quot;hour&quot;: 11, &quot;minute&quot;: 4, &quot;second&quot;: 3}.
      Parse returns TRUE on successful parse, FALSE otherwise.
      
      BUG: Assumes a 4 digit year.
      *)
      PROCEDURE Parse*(inline : ARRAY OF CHAR; VAR dt: DateTime) : BOOLEAN;
      VAR src, ds, ts, tmp : ARRAY SHORTSTR OF CHAR; ok, okDate, okTime : BOOLEAN;
          pos, year, month, day, hour, minute, second : INTEGER;
      BEGIN
          dt.year := 0;
          dt.month := 0;
          dt.day := 0;
          dt.hour := 0;
          dt.minute := 0;
          dt.second := 0;
          Chars.Clear(tmp);
          Chars.Set(inline, src);
          Chars.TrimSpace(src);
          (* Split into Date and Time components *)
          pos := Strings.Pos(&quot; &quot;, src, 0);
          IF pos &gt;= 0 THEN
              Strings.Extract(src, 0, pos, ds);
              pos := pos + 1;
              Strings.Extract(src, pos, Strings.Length(src) - pos, ts);
          ELSE
              Chars.Set(src, ds);
              Chars.Set(src, ts);
          END;
          ok := FALSE;
          IF IsDateString(ds) THEN
              ok := TRUE;
              okDate := ParseDate(ds, year, month, day);
              SetDate(year, month, day, dt);
              ok := ok &amp; okDate;
          END;
          IF IsTimeString(ts) THEN
              ok := ok OR okDate;
              okTime := ParseTime(ts, hour, minute, second);
              SetTime(hour, minute, second, dt);
              ok := ok &amp; okTime;
          END;
          RETURN ok
      END Parse;
      
      BEGIN
          Chars.Set(&quot;January&quot;, Months[0]);
          Chars.Set(&quot;February&quot;, Months[1]);
          Chars.Set(&quot;March&quot;, Months[2]);
          Chars.Set(&quot;April&quot;, Months[3]);
          Chars.Set(&quot;May&quot;, Months[4]);
          Chars.Set(&quot;June&quot;, Months[5]);
          Chars.Set(&quot;July&quot;, Months[6]);
          Chars.Set(&quot;August&quot;, Months[7]);
          Chars.Set(&quot;September&quot;, Months[8]);
          Chars.Set(&quot;October&quot;, Months[9]);
          Chars.Set(&quot;November&quot;, Months[10]);
          Chars.Set(&quot;December&quot;, Months[11]);
      
          Chars.Set(&quot;Sunday&quot;, Days[0]);
          Chars.Set(&quot;Monday&quot;, Days[1]);
          Chars.Set(&quot;Tuesday&quot;, Days[2]);
          Chars.Set(&quot;Wednesday&quot;, Days[3]);
          Chars.Set(&quot;Thursday&quot;, Days[4]);
          Chars.Set(&quot;Friday&quot;, Days[5]);
          Chars.Set(&quot;Saturday&quot;, Days[6]);
      
          DaysInMonth[0] := 31; (* January *)
          DaysInMonth[1] := 28; (* February *)
          DaysInMonth[2] := 31; (* March *)
          DaysInMonth[3] := 30; (* April *)
          DaysInMonth[4] := 31; (* May *)
          DaysInMonth[5] := 30; (* June *)
          DaysInMonth[6] := 31; (* July *)
          DaysInMonth[7] := 31; (* August *)
          DaysInMonth[8] := 30; (* September *)
          DaysInMonth[9] := 31; (* October *)
          DaysInMonth[10] := 30; (* November *)
          DaysInMonth[11] := 31; (* December *)
      
      END Dates.
      
      </code></pre>
      <p>Postscript: In this article I included a reference to the module<strong><a href="Chars.html">Chars</a></strong>. This is a non-standard module I wrote
      for Oberon-07. Here is a link to <a href="Chars.Mod">Chars</a>. RSD, 2021-05-06</p>
      <h3>Next, Previous</h3>
      <ul>
      <li>Next <a href="/blog/2021/05/16/Beyond-Oakwood-Modules-and-Aliases.html">Beyond Oakwood, Modules and Aliases</a></li>
      <li>Previous <a href="/blog/2020/10/19/Assemble-pages.html">Assemble Pages</a></li>
      </ul>
      <div class="footnotes" role="doc-endnotes">
      <hr>
      <ol>
      <li id="fn:1">
      <p>A2 information can be found in the <a href="https://en.wikibooks.org/wiki/Oberon#In_A2">Oberon wikibook</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
      </li>
      </ol>
      </div>
      
    </article>
  </section>
  <footer>
    <footer>
    <p>copyright © 2016 - 2025 R. S. Doiel<br /> <a
    href="/rssfeed.html">RSS</a> feeds and website built with <a
    href="https://rsdoiel.github.io/antennaApp">antennaApp</a>.
    </footer>
    <script type="module">
      await import('/pagefind/pagefind-highlight.js');
      new PagefindHighlight({ highlightParam: "highlight" });
    </script>
  </footer>
</body>
</html>
