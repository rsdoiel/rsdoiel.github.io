<!doctype html>
<html lang="en-US">
<head>
  <meta charset="utf-8" >
  <meta content="antenna/0.0.18" name="generator" >
  <meta name="date" content="2025-12-05T14:21:40-08:00" >
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" >
  <meta name="language" content="EN" >
  <title>R. S. Doiel, Software Engineer/Analyst &mdash; Robert's ramblings</title>
  <link rel="altenate" type="text/markdown" title="R. S. Doiel, Software Engineer/Analyst &mdash; Robert's ramblings" href="Dates.md" >
  <link rel="stylesheet" type="text/css" href="/css/site.css" >
  <link rel="alternate" title="Recent Blog Post" type="application/rss+xml" href="index.xml" >
  <link rel="alternate" title="Archive of Blog Posts" type="application/rss+xml" href="archive.xml" >
  <link rel="alternate" title="Markdown source for page" type="application/markdown" href="index.md" >
  <link rel="search" type="application/opensearchdescription+xml" title="Robert's Rambling Search Engine" href="osd.xml" >
  <script type="module" src="/modules/copyToClipboard.js" ></script>
</head>
<body>
  <nav>
    <ul>
    <li><a href="/" title="R. S. Doiel"><img class="blog-logo" src="/media/Wee-Free-Doiels-Summer-Reading.svg" alt="Wee Free Doiels, Summer Reading"></a></li>
    <li><a href="/">R. S. Doiel</a></li>
    <li><a href="/about.html">About</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/presentations.html">Presentations</a></li>
    <li><a href="/series/">Series</a></li>
    <li><a href="/search.html">Search</a></li>
    <li><a href="https://github.com/rsdoiel">GitHub</a></li>
    <li><a href="/rss.xml" title="RSS Feed">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9"></path>
    <path d="M4 4a16 16 0 0 1 16 16"></path>
    <circle cx="5" cy="19" r="1"></circle> </svg> RSS </a></li>
    </ul>
  </nav>

  <section>
    <article data-published="2020-11-27" data-link="https://rsdoiel.github.io/blog/2020/11/27/Dates.html">
      <h1>Dates</h1>
      <p>This module provides minimal date time records and procedures
      for working with dates in YYYY-MM-DD and MM/DD/YYYY format and
      times in H:MM, HH:MM and HH:MM:SS formats.</p>
      <dl>
      <dt>Set</dt>
      <dd>Set a DateTime record providing year, month, day, hour, minute and second as integers and the DateTime record to be populated.</dd>
      <dt>SetDate</dt>
      <dd>Set the date portion of a DateTime record, leaves the hour, minute and second attributes unmodified.</dd>
      <dt>SetTime</dt>
      <dd>Set the time portion of a DateTime record, leaves the year, month, date attributes unmodified.</dd>
      <dt>Copy</dt>
      <dd>Copy the attributes of one DateTime record into another DateTime record</dd>
      <dt>ToChars</dt>
      <dd>Given a DateTime record and a format constant, render the DateTime record to an array of CHAR.</dd>
      <dt>LeapYear</dt>
      <dd>Given a DateTime record check to see if it is a  leap year.</dd>
      <dt>NumOfDays</dt>
      <dd>Given a year and monoth return the number of days in the month.</dd>
      <dt>IsValid</dt>
      <dd>Check to see if the all attributes in a DateTime record are valid.</dd>
      <dt>OberonToDateTime</dt>
      <dd>Convert oberon date and time integer values into a DateTime record</dd>
      <dt>DateTimeToOberon</dt>
      <dd>Convert a DateTime record into Oberon date and time integer values.</dd>
      <dt>Now</dt>
      <dd>Set a DateTime record's attributes to the current time, depends of on the implementation of Clock.Mod.</dd>
      <dt>WeekDate</dt>
      <dd>Given a DateTime record calculates the year, week and weekday as integers values.</dd>
      <dt>Equal</dt>
      <dd>Checks to DateTime records to see if they have equivalent attribute values.</dd>
      <dt>Compare</dt>
      <dd>Compare two DateTime records, if t1 &lt; t2 then return -1, if t1 = t2 return 0 else if t1 &gt; t2 return 1.</dd>
      <dt>CompareDate</dt>
      <dd>Compare the year, month, day attributes of two DateTime records following the approach used in Compare.</dd>
      <dt>CompareTime</dt>
      <dd>Compare the hour, minute, second attributes of two DateTime records following the approach used in Compare.</dd>
      <dt>TimeDifference</dt>
      <dd>Take the differ of two DateTime records setting the difference in integer values for days, hours, minutes and seconds.</dd>
      <dt>AddYears</dt>
      <dd>Add years to a DateTime record. Years is a positive or negative integer.</dd>
      <dt>AddMonths</dt>
      <dd>Add months to a DateTime record. Months is either a positive or negative integer. Months will propogate to year in the DataTime record.</dd>
      <dt>AddDays</dt>
      <dd>Add days to a DateTime record. Days can be either a positive or negative integer.  Days will propogate to month and year attributes of the DateTime record.</dd>
      <dt>AddHours</dt>
      <dd>Add hours to a DateTime record. Hours can be either a positive or negative integer.  Hours will propogate to day, month and year attributes of the DateTime record.</dd>
      <dt>AddMinutes</dt>
      <dd>Add minutes to a DateTime record. Minutes can be either a positive or negative integer. Minutes will propogate to hour, day, month and year attributes of the DateTime record.</dd>
      <dt>AddSeconds</dt>
      <dd>Add seconds to a DateTime record. Seconds can be either a positive or negatice integer.  Seconds will propogate to minute, hour, day, month, year attributes of the DateTime record.</dd>
      <dt>IsValidDate</dt>
      <dd>IsValidDate checks the day, month, year attributes of a DateTime record and validates the values. Returns TRUE if everthing is ok, FALSE otherwise.</dd>
      <dt>IsValidTime</dt>
      <dd>IsValidTime checks the hour, minute, second attributes of a DateTime record and validates the values. Returns TRUE if everthing is ok, FALSE otherwise.</dd>
      <dt>IsDateString</dt>
      <dd>Checks to see if an ARRAY OF CHAR is a parsiable date string (e.g. in 2020-11-26 or 11/26/2020). Returns TRUE if the string is parsable, FALSE otherwise. NOTE: It does NOT check to see if the day, month or year values are valid. It only checks the format of the string.</dd>
      <dt>IsTimeString</dt>
      <dd>Checks to see if an ARRAY OF CHAR is a parsible time string (e.g. 3:32, 14:55, 09:19:22). NOTE: It only checks the format and does not check the hour, minute and second values.</dd>
      <dt>ParseDate</dt>
      <dd>Parse an ARRAY OF CHAR setting the values if year, month and day. Return TRUE on successful parse and FALSE otherwise.</dd>
      <dt>ParseTime</dt>
      <dd>Parse an ARRAY OF CHAR setting the values of hour, minute and second. Return TRUE on succesful parse and FALSE otherwise.</dd>
      <dt>Parse</dt>
      <dd>Parse an ARRAY OF CHAR setting the attributes of a DateTime record. Return TURE on success, FALSE otherwise.</dd>
      </dl>
      <h2>Limitations</h2>
      <p>Dates are presumed to be in the YYYY-DD-MM or MM/DD/YYYY formats.
      Does not handle dates with spelled out months or weekdays.</p>
      <p>Time portion of the date object doesn't include time zone.
      This will need to be rectified at some point.</p>
      <h2>Source code for <strong>Dates.Mod</strong></h2>
      <pre><code>(* Dates -- this module was inspired by the A2's Dates module, adapted
         for Oberon-07 and a POSIX system. It provides an assortment of procedures
         for working with a simple datetime record.
      
      Copyright (C) 2020 R. S. Doiel
      
      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU Affero General Public License as
      published by the Free Software Foundation, either version 3 of the
      License, or (at your option) any later version.
      
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU Affero General Public License for more details.
      
      You should have received a copy of the GNU Affero General Public License
      along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
      
      
      @Author R. S. Doiel, &lt;rsdoiel@gmail.com&gt;
      copyright (c) 2020, all rights reserved.
      This software is released under the GNU AGPL
      See http://www.gnu.org/licenses/agpl-3.0.html
      *)
      MODULE Dates;
      IMPORT Chars, Strings, Clock, Convert := extConvert; (*, Out; **)
      
      CONST
          MAXSTR = Chars.MAXSTR;
          SHORTSTR = Chars.SHORTSTR;
      
          YYYYMMDD* = 1; (* YYYY-MM-DD format *)
          MMDDYYYY* = 2; (* MM/DD/YYYY format *)
          YYYYMMDDHHMMSS* = 3; (* YYYY-MM-DD HH:MM:SS format *)
      
      TYPE
          DateTime* = RECORD
              year*, month*, day*, hour*, minute*, second* : INTEGER
          END;
      
      VAR
          (* Month names, January = 0, December = 11 *)
          Months*: ARRAY 23 OF ARRAY 10 OF CHAR; 
          (* Days of week, Monday = 0, Sunday = 6 *)
          Days*: ARRAY 7 OF ARRAY 10 OF CHAR;
          DaysInMonth: ARRAY 12 OF INTEGER;
      
      
      (* Set -- initialize a date record year, month and day values *)
      PROCEDURE Set*(year, month, day, hour, minute, second : INTEGER; VAR dt: DateTime);
      BEGIN
          dt.year := year;
          dt.month := month;
          dt.day := day;
          dt.hour := hour;
          dt.minute := minute;
          dt.second := second;
      END Set;
      
      (* SetDate -- set a Date record's year, month and day attributes *)
      PROCEDURE SetDate*(year, month, day : INTEGER; VAR dt: DateTime);
      BEGIN
          dt.year := year;
          dt.month := month;
          dt.day := day;
      END SetDate;
      
      (* SetTime -- set a Date record's hour, minute, second attributes *)
      PROCEDURE SetTime*(hour, minute, second : INTEGER; VAR dt: DateTime);
      BEGIN
          dt.hour := hour;
          dt.minute := minute;
          dt.second := second;
      END SetTime;
      
      (* Copy -- copy the values from one date record to another *)
      PROCEDURE Copy*(src : DateTime; VAR dest : DateTime);
      BEGIN
          dest.year := src.year;
          dest.month := src.month;
          dest.day := src.day;
          dest.hour := src.hour;
          dest.minute := src.minute;
          dest.second := src.second;
      END Copy;
      
      (* ToChars -- converts a date record into an array of chars using
      the format constant. Formats supported are YYYY-MM-DD HH:MM:SS
      or MM/DD/YYYY HH:MM:SS. *)
      PROCEDURE ToChars*(dt: DateTime; fmt : INTEGER; VAR src : ARRAY OF CHAR);
      VAR ok : BOOLEAN;
      BEGIN
          Chars.Clear(src);
          IF fmt = YYYYMMDD THEN
              Chars.AppendInt(dt.year, 4, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;-&quot;, src);
              Chars.AppendInt(dt.month, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;-&quot;, src);
              Chars.AppendInt(dt.day, 2, &quot;0&quot;, src);
          ELSIF fmt = MMDDYYYY THEN
              Chars.AppendInt(dt.month, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;/&quot;, src);
              Chars.AppendInt(dt.day, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;/&quot;, src);
              Chars.AppendInt(dt.year, 4, &quot;0&quot;, src);
          ELSIF fmt = YYYYMMDDHHMMSS THEN
              Chars.AppendInt(dt.year, 4, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;-&quot;, src);
              Chars.AppendInt(dt.month, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;-&quot;, src);
              Chars.AppendInt(dt.day, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot; &quot;, src);
              Chars.AppendInt(dt.hour, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;:&quot;, src);
              Chars.AppendInt(dt.minute, 2, &quot;0&quot;, src);
              ok := Chars.AppendChar(&quot;:&quot;, src);
              Chars.AppendInt(dt.second, 2, &quot;0&quot;, src);
          END;
      END ToChars;
      
      (* 
       * Date and Time functions very much inspired by A2 but
       * adapted for use in Oberon-07 and OBNC compiler.
       *)
      
      (* LeapYear -- returns TRUE if 'year' is a leap year *)
      PROCEDURE LeapYear*(year: INTEGER): BOOLEAN;
      BEGIN
      	RETURN (year &gt; 0) &amp; (year MOD 4 = 0) &amp; (~(year MOD 100 = 0) OR (year MOD 400 = 0))
      END LeapYear;
      
      (* NumOfDays -- number of days, returns the number of days in that month *)
      PROCEDURE NumOfDays*(year, month: INTEGER): INTEGER;
      VAR result : INTEGER;
      BEGIN
          result := 0;
      	DEC(month);
      	IF ((month &gt;= 0) &amp; (month &lt; 12)) THEN
      	    IF (month = 1) &amp; LeapYear(year) THEN 
                  result := DaysInMonth[1]+1;
      	    ELSE 
                  result := DaysInMonth[month];
      	    END;
          END;
          RETURN result
      END NumOfDays;
      
      (* IsValid -- checks if the attributes set in a DateTime record are valid *)
      PROCEDURE IsValid*(dt: DateTime): BOOLEAN;
      BEGIN
      	RETURN ((dt.year &gt; 0) &amp; (dt.month &gt; 0) &amp; (dt.month &lt;= 12) &amp; (dt.day &gt; 0) &amp; (dt.day &lt;= NumOfDays(dt.year, dt.month)) &amp; (dt.hour &gt;= 0) &amp; (dt.hour &lt; 24) &amp; (dt.minute &gt;= 0) &amp; (dt.minute &lt; 60) &amp; (dt.second &gt;= 0) &amp; (dt.second &lt; 60))
      END IsValid;
      
      (* IsValidDate -- checks to see if a datetime record has valid day, month and year
      attributes *)
      PROCEDURE IsValidDate*(dt: DateTime) : BOOLEAN;
      BEGIN
      	RETURN (dt.year &gt; 0) &amp; (dt.month &gt; 0) &amp; (dt.month &lt;= 12) &amp; (dt.day &gt; 0) &amp; (dt.day &lt;= NumOfDays(dt.year, dt.month))
      END IsValidDate;
      
      (* IsValidTime -- checks if the hour, minute, second attributes set in a DateTime record are valid *)
      PROCEDURE IsValidTime*(dt: DateTime): BOOLEAN;
      BEGIN
      	RETURN (dt.hour &gt;= 0) &amp; (dt.hour &lt; 24) &amp; (dt.minute &gt;= 0) &amp; (dt.minute &lt; 60) &amp; (dt.second &gt;= 0) &amp; (dt.second &lt; 60)
      END IsValidTime;
      
      
      (* OberonToDateTime -- convert an Oberon date/time to a DateTime 
      structure *)
      PROCEDURE OberonToDateTime*(Date, Time: INTEGER; VAR dt : DateTime);
      BEGIN
      	dt.second := Time MOD 64; Time := Time DIV 64;
      	dt.minute := Time MOD 64; Time := Time DIV 64;
      	dt.hour := Time MOD 24;
      	dt.day := Date MOD 32; Date := Date DIV 32;
      	dt.month := (Date MOD 16) + 1; Date := Date DIV 16;
      	dt.year := Date;
      END OberonToDateTime;
      
      (* DateTimeToOberon -- convert a DateTime structure to an Oberon 
      date/time *)
      PROCEDURE DateTimeToOberon*(dt: DateTime; VAR date, time: INTEGER);
      BEGIN
      	IF IsValid(dt) THEN
      	date := (dt.year)*512 + dt.month*32 + dt.day;
      	time := dt.hour*4096 + dt.minute*64 + dt.second
          ELSE
              date := 0;
              time := 0;
          END;
      END DateTimeToOberon;
      
      (* Now -- returns the current date and time as a DateTime record. *)
      PROCEDURE Now*(VAR dt: DateTime);
      VAR d, t: INTEGER;
      BEGIN
      	Clock.Get(t, d);
      	OberonToDateTime(d, t, dt);
      END Now;
      
      
      (* WeekDate -- returns the ISO 8601 year number, week number &amp;
      week day (Monday=1, ....Sunday=7) 
      Algorithm is by Rick McCarty, http://personal.ecu.edu/mccartyr/ISOwdALG.txt
      *)
      PROCEDURE WeekDate*(dt: DateTime; VAR year, week, weekday: INTEGER);
      VAR doy, i, yy, c, g, jan1: INTEGER; leap: BOOLEAN;
      BEGIN
      	IF IsValid(dt) THEN
      		leap := LeapYear(dt.year);
      		doy := dt.day; i := 0;
      		WHILE (i &lt; (dt.month - 1)) DO 
                  doy := doy + DaysInMonth[i];
                  INC(i);
              END;
      		IF leap &amp; (dt.month &gt; 2) THEN 
                  INC(doy);
              END;
      		yy := (dt.year - 1) MOD 100; 
              c := (dt.year - 1) - yy; 
              g := (yy + yy) DIV 4;
      		jan1 := 1 + (((((c DIV 100) MOD 4) * 5) + g) MOD 7);
      
      		weekday := 1 + (((doy + (jan1 - 1)) - 1) MOD 7);
      
      		IF (doy &lt;= (8 - jan1)) &amp; (jan1 &gt; 4) THEN (* falls in year-1 ? *)
      			year := dt.year - 1;
      			IF (jan1 = 5) OR ((jan1 = 6) &amp; LeapYear(year)) THEN 
                      week := 53;
      			ELSE 
                      week := 52;
      			END;
      		ELSE
      			IF leap THEN 
                      i := 366;
                  ELSE 
                      i := 365;
                  END;
      			IF ((i - doy) &lt; (4 - weekday)) THEN
      				year := dt.year + 1;
      				week := 1;
      			ELSE
      				year := dt.year;
      				i := doy + (7-weekday) + (jan1-1);
      				week := i DIV 7;
      				IF (jan1 &gt; 4) THEN 
                          DEC(week);
                      END;
      			END;
      		END;
      	ELSE
      		year := -1; week := -1; weekday := -1;
      	END;
      END WeekDate;
      
      (* Equal -- compare to date records to see if they are equal values *)
      PROCEDURE Equal*(t1, t2: DateTime) : BOOLEAN;
      BEGIN
      	RETURN ((t1.second = t2.second) &amp; (t1.minute = t2.minute) &amp; (t1.hour = t2.hour) &amp; (t1.day = t2.day) &amp; (t1.month = t2.month) &amp; (t1.year = t2.year))
      END Equal;
      
      (* compare -- used in Compare only for comparing specific values,
          returning an appropriate -1, 0, 1 *)
      PROCEDURE compare(t1, t2 : INTEGER) : INTEGER;
      VAR result : INTEGER;
      BEGIN
      	IF (t1 &lt; t2) THEN 
              result := -1;
      	ELSIF (t1 &gt; t2) THEN 
              result := 1;
      	ELSE 
              result := 0;
      	END;
      	RETURN result
      END compare;
      
      (* Compare -- returns -1 if (t1 &lt; t2), 0 if (t1 = t2) or 1 if (t1 &gt;  t2) *)
      PROCEDURE Compare*(t1, t2: DateTime) : INTEGER;
      VAR result : INTEGER;
      BEGIN
      	result := compare(t1.year, t2.year);
      	IF (result = 0) THEN
      		result := compare(t1.month, t2.month);
      		IF (result = 0) THEN
      			result := compare(t1.day, t2.day);
      			IF (result = 0) THEN
      				result := compare(t1.hour, t2.hour);
      				IF (result = 0) THEN
      					result := compare(t1.minute, t2.minute);
      					IF (result = 0) THEN
      						result := compare(t1.second, t2.second);
      					END;
      				END;
      			END;
      		END;
      	END;
      	RETURN result
      END Compare;
      
      (* CompareDate -- compare day, month and year values only *)
      PROCEDURE CompareDate*(t1, t2: DateTime) : INTEGER;
      VAR result : INTEGER;
      BEGIN
      	result := compare(t1.year, t2.year);
      	IF (result = 0) THEN
      		result := compare(t1.month, t2.month);
      		IF (result = 0) THEN
      			result := compare(t1.day, t2.day);
      		END;
      	END;
      	RETURN result
      END CompareDate;
      
      (* CompareTime -- compare second, minute and hour values only *)
      PROCEDURE CompareTime*(t1, t2: DateTime) : INTEGER;
      VAR result : INTEGER;
      BEGIN
      	result := compare(t1.hour, t2.hour);
      	IF (result = 0) THEN
      		result := compare(t1.minute, t2.minute);
      		IF (result = 0) THEN
      			result := compare(t1.second, t2.second);
      		END;
      	END;
      	RETURN result
      END CompareTime;
      
      
      
      (* TimeDifferences -- returns the absolute time difference between 
      t1 and t2.
      
      Note that leap seconds are not counted, 
      see http://www.eecis.udel.edu/~mills/leap.html *)
      PROCEDURE TimeDifference*(t1, t2: DateTime; VAR days, hours, minutes, seconds : INTEGER);
      CONST SecondsPerMinute = 60; SecondsPerHour = 3600; SecondsPerDay = 86400;
      VAR start, end: DateTime; year, month, second : INTEGER;
      BEGIN
      	IF (Compare(t1, t2) = -1) THEN 
              start := t1; 
              end := t2; 
          ELSE 
              start := t2; 
              end := t1; 
          END;
      	IF (start.year = end.year) &amp; (start.month = end.month) &amp; (start.day = end.day) THEN
      		second := end.second - start.second + ((end.minute - start.minute) * SecondsPerMinute) + ((end.hour - start.hour) * SecondsPerHour);
      		days := 0;
              hours := 0;
              minutes := 0;
      	ELSE
      		(* use start date/time as reference point *)
      		(* seconds until end of the start.day *)
      		second := (SecondsPerDay - start.second) - (start.minute * SecondsPerMinute) - (start.hour * SecondsPerHour);
      		IF (start.year = end.year) &amp; (start.month = end.month) THEN
      			(* days between start.day and end.day *)
      			days := (end.day - start.day) - 1;
      		ELSE
      			(* days until start.month ends excluding start.day *)
      			days := NumOfDays(start.year, start.month) - start.day;
      			IF (start.year = end.year) THEN
      				(* months between start.month and end.month *)
      				FOR month := start.month + 1 TO end.month - 1 DO
      					days := days + NumOfDays(start.year, month);
      				END;
      			ELSE
      				(* days until start.year ends (excluding start.month) *)
      				FOR month := start.month + 1 TO 12 DO
      					days := days + NumOfDays(start.year, month);
      				END;
      				FOR year := start.year + 1 TO end.year - 1 DO (* days between start.years and end.year *)
      					IF LeapYear(year) THEN days := days + 366; ELSE days := days + 365; END;
      				END;
      				FOR month := 1 TO end.month - 1 DO (* days until we reach end.month in end.year *)
      					days := days + NumOfDays(end.year, month);
      				END;
      			END;
      			(* days in end.month until reaching end.day excluding end.day *)
      			days := (days + end.day) - 1;
      		END;
      		(* seconds in end.day *)
      		second := second + end.second + (end.minute * SecondsPerMinute) + (end.hour * SecondsPerHour);
      	END;
      	days := days + (second DIV SecondsPerDay); second := (second MOD SecondsPerDay);
      	hours := (second DIV SecondsPerHour); second := (second MOD SecondsPerHour);
      	minutes := (second DIV SecondsPerMinute); second := (second MOD SecondsPerMinute);
      	seconds := second;
      END TimeDifference;
      
      (* AddYear -- Add/Subtract a number of years to/from date *)
      PROCEDURE AddYears*(VAR dt: DateTime; years : INTEGER);
      BEGIN
      	ASSERT(IsValid(dt));
      	dt.year := dt.year + years;
      	ASSERT(IsValid(dt));
      END AddYears;
      
      (* AddMonths -- Add/Subtract a number of months to/from date.
      This will adjust date.year if necessary *)
      PROCEDURE AddMonths*(VAR dt: DateTime; months : INTEGER);
      VAR years : INTEGER;
      BEGIN
      	ASSERT(IsValid(dt));
      	years := months DIV 12;
      	dt.month := dt.month + (months MOD 12);
      	IF (dt.month &gt; 12) THEN
      		dt.month := dt.month - 12;
      		INC(years);
      	ELSIF (dt.month &lt; 1) THEN
      		dt.month := dt.month + 12;
      		DEC(years);
      	END;
      	IF (years # 0) THEN AddYears(dt, years); END;
      	ASSERT(IsValid(dt));
      END AddMonths;
      
      (* AddDays --  Add/Subtract a number of days to/from date.
      This will adjust date.month and date.year if necessary *)
      PROCEDURE AddDays*(VAR dt: DateTime; days : INTEGER);
      VAR nofDaysLeft : INTEGER;
      BEGIN
      	ASSERT(IsValid(dt));
      	IF (days &gt; 0) THEN
      		WHILE (days &gt; 0) DO
      			nofDaysLeft := NumOfDays(dt.year, dt.month) - dt.day;
      			IF (days &gt; nofDaysLeft) THEN
      				dt.day := 1;
      				AddMonths(dt, 1);
      				days := days - nofDaysLeft - 1; (* -1 because we consume the first day of the next month *)
      			ELSE
      				dt.day := dt.day + days;
      				days := 0;
      			END;
      		END;
      	ELSIF (days &lt; 0) THEN
      		days := -days;
      		WHILE (days &gt; 0) DO
      			nofDaysLeft := dt.day - 1;
      			IF (days &gt; nofDaysLeft) THEN
      				dt.day := 1; (* otherwise, dt could become an invalid date if the previous month has less days than dt.day *)
      				AddMonths(dt, -1);
      				dt.day := NumOfDays(dt.year, dt.month);
      				days := days - nofDaysLeft - 1; (* -1 because we consume the last day of the previous month *)
      			ELSE
      				dt.day := dt.day - days;
      				days := 0;
      			END;
      		END;
      	END;
      	ASSERT(IsValid(dt));
      END AddDays;
      
      (* AddHours -- Add/Subtract a number of hours to/from date.
      This will adjust date.day, date.month and date.year if necessary *)
      PROCEDURE AddHours*(VAR dt: DateTime; hours : INTEGER);
      VAR days : INTEGER;
      BEGIN
      	ASSERT(IsValid(dt));
      	dt.hour := dt.hour + hours;
      	days := dt.hour DIV 24;
      	dt.hour := dt.hour MOD 24;
      	IF (dt.hour &lt; 0) THEN
      		dt.hour := dt.hour + 24;
      		DEC(days);
      	END;
      	IF (days # 0) THEN AddDays(dt, days); END;
      	ASSERT(IsValid(dt));
      END AddHours;
      
      (* AddMinutes -- Add/Subtract a number of minutes to/from date.
      This will adjust date.hour, date.day, date.month and date.year 
      if necessary *)
      PROCEDURE AddMinutes*(VAR dt: DateTime; minutes : INTEGER);
      VAR hours : INTEGER;
      BEGIN
      	ASSERT(IsValid(dt));
      	dt.minute := dt.minute + minutes;
      	hours := dt.minute DIV 60;
      	dt.minute := dt.minute MOD 60;
      	IF (dt.minute &lt; 0) THEN
      		dt.minute := dt.minute + 60;
      		DEC(hours);
      	END;
      	IF (hours # 0) THEN AddHours(dt, hours); END;
      	ASSERT(IsValid(dt));
      END AddMinutes;
      
      (* AddSeconds -- Add/Subtract a number of seconds to/from date.
      This will adjust date.minute, date.hour, date.day, date.month and
      date.year if necessary *)
      PROCEDURE AddSeconds*(VAR dt: DateTime; seconds : INTEGER);
      VAR minutes : INTEGER;
      BEGIN
      	ASSERT(IsValid(dt));
      	dt.second := dt.second + seconds;
      	minutes := dt.second DIV 60;
      	dt.second := dt.second MOD 60;
      	IF (dt.second &lt; 0) THEN
      		dt.second := dt.second + 60;
      		DEC(minutes);
      	END;
      	IF (minutes # 0) THEN AddMinutes(dt, minutes); END;
      	ASSERT(IsValid(dt));
      END AddSeconds;
      
      
      (* IsDateString -- return TRUE if the ARRAY OF CHAR is 10 characters
      long and is either in the form of YYYY-MM-DD or MM/DD/YYYY where
      Y, M and D are digits. 
      NOTE: is DOES NOT check the ranges of the digits. *)
      PROCEDURE IsDateString*(inline : ARRAY OF CHAR) : BOOLEAN;
      VAR 
          test : BOOLEAN; i, pos : INTEGER;
          src : ARRAY MAXSTR OF CHAR;
      BEGIN
          Chars.Set(inline, src);
          Chars.TrimSpace(src);
          test := FALSE;
          IF Strings.Length(src) = 10 THEN
              pos := Strings.Pos(&quot;-&quot;, src, 0);
              IF pos &gt; 0 THEN
                  IF (src[4] = &quot;-&quot;) &amp; (src[7] = &quot;-&quot;) THEN
                      test := TRUE;
                      FOR i := 0 TO 9 DO
                          IF (i # 4) &amp; (i # 7) THEN
                             IF Chars.IsDigit(src[i]) = FALSE THEN
                                 test := FALSE;
                             END;
                          END;
                      END;
                  ELSE
                      test := FALSE;
                  END;
              END;
              pos := Strings.Pos(&quot;/&quot;, src, 0);
              IF pos &gt; 0 THEN
                  IF (src[2] = &quot;/&quot;) &amp; (src[5] = &quot;/&quot;) THEN
                      test := TRUE;
                      FOR i := 0 TO 9 DO
                          IF (i # 2) &amp; (i # 5) THEN
                              IF Chars.IsDigit(src[i]) = FALSE THEN
                                  test := FALSE;
                              END;
                          END;
                      END;
                  ELSE
                      test := FALSE;
                  END;
              END;
          END;
          RETURN test
      END IsDateString;
      
      (* IsTimeString -- return TRUE if the ARRAY OF CHAR has 4 to 8 
      characters in the form of H:MM, HH:MM, HH:MM:SS where H, M and S
      are digits. *)
      PROCEDURE IsTimeString*(inline : ARRAY OF CHAR) : BOOLEAN;
      VAR 
          test : BOOLEAN; 
          l : INTEGER;
          src : ARRAY MAXSTR OF CHAR;
      BEGIN
          Chars.Set(inline, src);
          Chars.TrimSpace(src);
          (* remove any trailing am/pm suffixes *)
          IF Chars.EndsWith(&quot;m&quot;, src) THEN
              IF Chars.EndsWith(&quot;am&quot;, src) THEN
                  Chars.TrimSuffix(&quot;am&quot;, src);
              ELSE
                  Chars.TrimSuffix(&quot;pm&quot;, src);
              END;
              Chars.TrimSpace(src);
          ELSIF Chars.EndsWith(&quot;M&quot;, src) THEN
              Chars.TrimSuffix(&quot;AM&quot;, src);
              Chars.TrimSuffix(&quot;PM&quot;, src);
              Chars.TrimSpace(src);
          ELSIF Chars.EndsWith(&quot;p&quot;, src) THEN
              Chars.TrimSuffix(&quot;p&quot;, src);
              Chars.TrimSpace(src);
          ELSIF Chars.EndsWith(&quot;P&quot;, src) THEN
              Chars.TrimSuffix(&quot;P&quot;, src);
              Chars.TrimSpace(src);
          ELSIF Chars.EndsWith(&quot;a&quot;, src) THEN
              Chars.TrimSuffix(&quot;a&quot;, src);
              Chars.TrimSpace(src);
          ELSIF Chars.EndsWith(&quot;A&quot;, src) THEN
              Chars.TrimSuffix(&quot;A&quot;, src);
              Chars.TrimSpace(src);
          END;
          Strings.Extract(src, 0, 8, src);
          test := FALSE;
          l := Strings.Length(src);
          IF (l = 4) THEN
              IF Chars.IsDigit(src[0]) &amp; (src[1] = &quot;:&quot;) &amp; 
                  Chars.IsDigit(src[2]) &amp; Chars.IsDigit(src[3]) THEN
                  test := TRUE;
              ELSE
                  test := FALSE;
              END;
          ELSIF (l = 5) THEN
              IF Chars.IsDigit(src[0]) &amp; Chars.IsDigit(src[1]) &amp;
                  (src[2] = &quot;:&quot;) &amp; 
                  Chars.IsDigit(src[3]) &amp; Chars.IsDigit(src[4]) THEN
                  test := TRUE;
              ELSE
                  test := FALSE;
              END;
          ELSIF (l = 8) THEN
              IF Chars.IsDigit(src[0]) &amp; Chars.IsDigit(src[1]) &amp;
                  (src[2] = &quot;:&quot;) &amp; 
                  Chars.IsDigit(src[3]) &amp; Chars.IsDigit(src[4]) &amp; 
                  (src[5] = &quot;:&quot;) &amp; 
                  Chars.IsDigit(src[6]) &amp; Chars.IsDigit(src[7]) THEN
                  test := TRUE;
              ELSE
                  test := FALSE;
              END;
          ELSE
              test := FALSE;
          END;
          RETURN test
      END IsTimeString;
      
      (* ParseDate -- parses a date string in YYYY-MM-DD or
      MM/DD/YYYY format. *)
      PROCEDURE ParseDate*(inline : ARRAY OF CHAR; VAR year, month, day : INTEGER) : BOOLEAN;
      VAR src, tmp : ARRAY MAXSTR OF CHAR; ok, b : BOOLEAN;
      BEGIN
          Chars.Set(inline, src);
          Chars.Clear(tmp);
          ok := FALSE;
      	IF IsDateString(src) THEN
              (* FIXME: Need to allow for more than 4 digit years! *)
              IF (src[2] = &quot;/&quot;) &amp; (src[5] = &quot;/&quot;) THEN
                  ok := TRUE;
                  Strings.Extract(src, 0, 2, tmp);
                  Convert.StringToInt(tmp, month, b);
                  ok := ok &amp; b;
                  Strings.Extract(src, 4, 2, tmp);
                  Convert.StringToInt(tmp, day, b);
                  ok := ok &amp; b;
                  Strings.Extract(src, 6, 4, tmp);
                  Convert.StringToInt(tmp, year, b);
                  ok := ok &amp; b;
              ELSIF (src[4] = &quot;-&quot;) &amp; (src[7] = &quot;-&quot;) THEN
                  ok := TRUE;
                  Strings.Extract(src, 0, 4, tmp);
                  Convert.StringToInt(tmp, year, b);
                  ok := ok &amp; b;
                  Strings.Extract(src, 5, 2, tmp);
                  Convert.StringToInt(tmp, month, b);
                  ok := ok &amp; b;
                  Strings.Extract(src, 8, 2, tmp);
                  Convert.StringToInt(tmp, day, b);
                  ok := ok &amp; b;
              ELSE
                  ok := FALSE;
              END;
          END;
          RETURN ok
      END ParseDate;
      
      (* ParseTime -- procedure for parsing time strings into hour,
      minute, second. Returns TRUE on successful parse, FALSE otherwise *)
      PROCEDURE ParseTime*(inline : ARRAY OF CHAR; VAR hour, minute, second : INTEGER) : BOOLEAN;
      VAR src, tmp : ARRAY MAXSTR OF CHAR; ok : BOOLEAN; cur, pos, l : INTEGER;
      BEGIN
          Chars.Set(inline, src);
          Chars.Clear(tmp);
      	IF IsTimeString(src) THEN
              ok := TRUE;
              cur := 0; pos := 0;
              pos := Strings.Pos(&quot;:&quot;, src, cur);
              IF pos &gt; 0 THEN
              (* Get Hour *)
                  Strings.Extract(src, cur, pos - cur, tmp);
                  Convert.StringToInt(tmp, hour, ok);
                  IF ok THEN
                      (* Get Minute *)
                      cur := pos + 1;
                      Strings.Extract(src, cur, 2, tmp);
                      Convert.StringToInt(tmp, minute, ok);
                      IF ok THEN
                          (* Get second, optional, default to zero *)
                          pos := Strings.Pos(&quot;:&quot;, src, cur);
                          IF pos &gt; 0 THEN
                              cur := pos + 1;
                              Strings.Extract(src, cur, 2, tmp);
                              Convert.StringToInt(tmp, second, ok);
                              cur := cur + 2;
                          ELSE
                              second := 0;
                          END;
                          (* Get AM/PM, optional, adjust hour if PM *)
                          l := Strings.Length(src);
                          WHILE (cur &lt; l) &amp; Chars.IsSpace(src[cur]) DO
                              cur := cur + 1;
                          END;
                          Strings.Extract(src, cur, 2, tmp);
                          Chars.TrimSpace(tmp);
                          IF Chars.Equal(tmp, &quot;PM&quot;) OR Chars.Equal(tmp, &quot;pm&quot;) THEN
                              hour := hour + 12;
                          END;
                      ELSE
                          ok := FALSE;
                      END;
                  END;
              ELSE
                  ok := FALSE;
              END;
          ELSE
              ok := FALSE;
          END;
          IF ok THEN
              ok := ((hour &gt;= 0) &amp; (hour &lt;= 23)) &amp;
                  ((minute &gt;= 0) &amp; (minute &lt;= 59)) &amp;
                      ((second &gt;= 0) &amp; (second &lt;= 59));
          END;
          RETURN ok
      END ParseTime;
      
      
      (* Parse accepts a date array of chars in either dates, times
      or dates and times separate by spaces. Date formats supported
      include YYYY-MM-DD, MM/DD/YYYY. Time formats include
      H:MM, HH:MM, H:MM:SS, HH:MM:SS with 'a', 'am', 'p', 'pm' 
      suffixes.  Dates and times can also be accepted as JSON 
      expressions with the individual time compontents are specified 
      as attributes, e.g. `{&quot;year&quot;: 1998, &quot;month&quot;: 12, &quot;day&quot;: 10,
      &quot;hour&quot;: 11, &quot;minute&quot;: 4, &quot;second&quot;: 3}.
      Parse returns TRUE on successful parse, FALSE otherwise.
      
      BUG: Assumes a 4 digit year.
      *) 
      PROCEDURE Parse*(inline : ARRAY OF CHAR; VAR dt: DateTime) : BOOLEAN;
      VAR src, ds, ts, tmp : ARRAY SHORTSTR OF CHAR; ok, okDate, okTime : BOOLEAN; 
          pos, year, month, day, hour, minute, second : INTEGER;
      BEGIN
          dt.year := 0;
          dt.month := 0;
          dt.day := 0;
          dt.hour := 0;
          dt.minute := 0;
          dt.second := 0;
          Chars.Clear(tmp);
          Chars.Set(inline, src);
          Chars.TrimSpace(src);
          (* Split into Date and Time components *)
          pos := Strings.Pos(&quot; &quot;, src, 0);
          IF pos &gt;= 0 THEN
              Strings.Extract(src, 0, pos, ds);
              pos := pos + 1;
              Strings.Extract(src, pos, Strings.Length(src) - pos, ts);
          ELSE
              Chars.Set(src, ds);
              Chars.Set(src, ts);
          END;
          ok := FALSE;
          IF IsDateString(ds) THEN
              ok := TRUE;
              okDate := ParseDate(ds, year, month, day);
              SetDate(year, month, day, dt);
              ok := ok &amp; okDate;
          END;
          IF IsTimeString(ts) THEN
              ok := ok OR okDate;
              okTime := ParseTime(ts, hour, minute, second);
              SetTime(hour, minute, second, dt);
              ok := ok &amp; okTime;
          END;
          RETURN ok
      END Parse;
      
      BEGIN
          Chars.Set(&quot;January&quot;, Months[0]);
          Chars.Set(&quot;February&quot;, Months[1]);
          Chars.Set(&quot;March&quot;, Months[2]);
          Chars.Set(&quot;April&quot;, Months[3]);
          Chars.Set(&quot;May&quot;, Months[4]);
          Chars.Set(&quot;June&quot;, Months[5]);
          Chars.Set(&quot;July&quot;, Months[6]);
          Chars.Set(&quot;August&quot;, Months[7]);
          Chars.Set(&quot;September&quot;, Months[8]);
          Chars.Set(&quot;October&quot;, Months[9]);
          Chars.Set(&quot;November&quot;, Months[10]);
          Chars.Set(&quot;December&quot;, Months[11]);
      
          Chars.Set(&quot;Sunday&quot;, Days[0]);
          Chars.Set(&quot;Monday&quot;, Days[1]);
          Chars.Set(&quot;Tuesday&quot;, Days[2]);
          Chars.Set(&quot;Wednesday&quot;, Days[3]);
          Chars.Set(&quot;Thursday&quot;, Days[4]);
          Chars.Set(&quot;Friday&quot;, Days[5]);
          Chars.Set(&quot;Saturday&quot;, Days[6]);
      
          DaysInMonth[0] := 31; (* January *)
          DaysInMonth[1] := 28; (* February *)
          DaysInMonth[2] := 31; (* March *)
          DaysInMonth[3] := 30; (* April *)
          DaysInMonth[4] := 31; (* May *)
          DaysInMonth[5] := 30; (* June *)
          DaysInMonth[6] := 31; (* July *)
          DaysInMonth[7] := 31; (* August *)
          DaysInMonth[8] := 30; (* September *)
          DaysInMonth[9] := 31; (* October *)
          DaysInMonth[10] := 30; (* November *)
          DaysInMonth[11] := 31; (* December *)
      
      END Dates.
      
      </code></pre>
      
    </article>
  </section>
  <footer>
    <footer>
    <p>copyright Â© 2016 - 2025 R. S. Doiel<br /> <a
    href="/rssfeed.html">RSS</a> feeds and website built with <a
    href="https://rsdoiel.github.io/antennaApp">antennaApp</a>.
    </footer>
    <script type="module">
      await import('/pagefind/pagefind-highlight.js');
      new PagefindHighlight({ highlightParam: "highlight" });
    </script>
  </footer>
</body>
</html>
