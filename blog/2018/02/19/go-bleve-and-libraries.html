<!doctype html>
<html lang="en-US">
<head>
  <meta charset="UTF-8" />
  <link  rel="alternate" type="text/markdown" href="go-bleve-and-libraries.md" title=""/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/css/site.css" />
  <meta name="generator" content="antenna/0.0.6">
  <meta name="date" content="2025-09-15T14:18:49-07:00">
</head>
<body>
  <header>
    (date: 2025-09-15 14:18:49)
  </header>
  <nav>
    <ul>
    <li><a href="/" title="R. S. Doiel"><img class="blog-logo" src="/media/Wee-Free-Doiels-Summer-Reading.svg" alt="Wee Free Doiels, Summer Reading"></a></li>
    <li><a href="/">R. S. Doiel</a></li>
    <li><a href="/about.html">About</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/presentations.html">Presentations</a></li>
    <li><a href="/series/">Series</a></li>
    <li><a href="/search.html">Search</a></li>
    <li><a href="https://github.com/rsdoiel">GitHub</a></li>
    <li><a href="/index.xml" title="RSS, recent posts">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9"></path>
    <path d="M4 4a16 16 0 0 1 16 16"></path>
    <circle cx="5" cy="19" r="1"></circle> </svg> RSS </a></li>
    </ul>
  </nav>

  <section>
    <article data-published="2018-02-19" data-link="https://rsdoiel.github.io/blog/2018/02/19/go-bleve-and-libraries.html">
      <h1 id="go-bleve-and-library-oriented-software">Go, Bleve and Library oriented software</h1>
      <p>By R. S. Doiel, 2018-02-19<br />
      (updated: 2018-02-22)</p>
      <p>In 2016, Stephen Davison, asked me, &quot;Why use Go and Blevesearch for<br />
      our library projects?&quot; After our conversation I wrote up some notes so<br />
      I would remember. It is now 2018 and I am revising these notes. I<br />
      think our choice paid off.  What follows is the current state of my<br />
      reflection on the background, rational, concerns, and risk mitigation<br />
      strategies so far for using <a href="https://golang.org">Go</a> and<br />
      <a href="https://blevesearch.com">Blevesearch</a> for Caltech Library projects.</p>
      <h2 id="background">Background</h2>
      <p>I first came across Go a few years back when it was announced as an<br />
      Open Source project by Google at an Google I/O event (2012). The<br />
      original Go authors were Robert Griesemer, Rob Pike, and Ken<br />
      Thompson. What I remember from that presentation was Go was a rather<br />
      consistent language with the features you need but little else.  Go<br />
      developed at Google as a response to high development costs for C/C++<br />
      and Java in addition to challenges with performance and slow<br />
      compilation times.  As a language I would put Go between C/C++ and<br />
      Java. It comes the ease of writing and reading you find in languages<br />
      like Python. Syntax is firmly in the C/C++ family but heavily<br />
      simplified. Like Java it provides many modern features including rich basic<br />
      data structures and garbage collection. It has a very complete standard<br />
      library and provides very good tooling.  This makes it easy to<br />
      generate code level documentation, format code, test, efficiently profile,<br />
      and debug.</p>
      <p>Often programming languages develop around a specific set of needs.<br />
      This is true for Go. Given the Google origin it should not be<br />
      surprising to find that Go's primary strengths are working with<br />
      structured data, I/O and concurrency. The rich standard<br />
      library is organized around a package concept. These include packages<br />
      supporting network protocols, file and socket I/O as well as various<br />
      encoding and compression scheme. It has particularly strong support<br />
      for XML, JSON, CSV formatted data out of the box. It has a template<br />
      library for working with plain text formats as well as generating safe<br />
      HTML. You can browse Go's standard library <a href="https://golang.org/pkg/">https://golang.org/pkg/</a>.</p>
      <p>An additional feature is Go's consistency. Go code that compiles under<br />
      version 1.0 still compiles under 1.10. Even before 1.0 code changes<br />
      that were breaking came with tooling to automatically updates existing<br />
      code.  Running code is a strong element of Go's evolution.</p>
      <p>Go is unsurprising and has even been called boring.  This turns out to<br />
      be a strength when building sustainable projects in a small team.</p>
      <h2 id="why-do-i-write-go">Why do I write Go?</h2>
      <p>For me Go is a good way to write web services, assemble websites,<br />
      create search appliances and write command line (cli) utilities. When<br />
      a shell script becomes unwieldy Go is often what I turn to.  Go is<br />
      well suited to building tools as well as systems.  Go based command<br />
      line tools are very easy to orchestrate with shell and Python.</p>
      <p>Go runs on all the platforms I actively use - Windows, Mac OS X, Linux<br />
      on both Intel and ARM (e.g. Raspberry Pi, Pine64). It has experimental<br />
      support for Android and iOS.  I've used a tool called<br />
      <a href="http://gopherjs.org">GopherJS</a> to write web browser applications that<br />
      transform my command line tools into web tools with a friendlier user<br />
      interface (see our <a href="https://caltechlibrary.github.io/bibtex/webapp/">BibTeX Tools</a>).</p>
      <p>Go supports cross compiling out of the box. This means a production<br />
      system running on AWS, Google's compute engine or Microsoft's Azure<br />
      can be compiled from Windows, Mac OS or even a Raspberry Pi!<br />
      Deployment is a matter of copying the (self contained) compiled binary<br />
      onto the production system. This contrasts with other<br />
      platforms like Perl, PHP, Python, NodeJS and Ruby where you need to<br />
      install not only your application code but all dependencies. While<br />
      interpretive languages retain an advantage of having a REPL, Go<br />
      based programs have advantages of fast compile times and easy deployment.</p>
      <p>In many of the projects I've written in Go I've only required a few<br />
      (if any) 3rd party libraries (packages in Go's nomenclature). This is<br />
      quite a bit different from my experience with Perl, PHP, Python,<br />
      NodeJS and Ruby. This is in large part a legacy of having grown up at<br />
      Google before become an open source project. While the Go standard<br />
      packages are very good there is a rich ecosystem for 3rd party<br />
      packages for specialized needs. I've found I tend to rely only on a<br />
      few of them. The one I've used the most is<br />
      <a href="http://blevesearch.com">Bleve</a>.</p>
      <p>Bleve is a Go package for building search engines. When I originally<br />
      came across Bleve (around 2014), it was described as &quot;Lucene lite&quot;.<br />
      &quot;Lucene lite&quot; was an apt description, but I find it easier<br />
      to use than Lucene. When I first used Bleve I embedded its<br />
      functionality into the tools I used to process data and present web<br />
      services. It did not have much in the way of stand alone command line<br />
      tooling.  Today I increasingly think of Bleve as &quot;Elastic Search<br />
      lite&quot;. It ships with a set of command line tools that include support<br />
      for building Bleve's indexes.  My current practice is to only embed the search<br />
      portion of the packages. I can use the Bleve command line for the<br />
      rest.  In 2018, Bleve is being actively developed, has a small vibrant<br />
      community and is used by <a href="https://couchbase.com">Couchbase</a>, a well<br />
      established NoSQL player.</p>
      <h2 id="who-is-using-go">Who is using Go?</h2>
      <p>Many companies use Go. The short list includes<br />
      Google, Amazon, Netflix, Dropbox, Box, eBay, Pearsons and even<br />
      Walmart and Microsoft. This came to my attention at developer conferences<br />
      back in 2014.  People from many of these companies started<br />
      presenting at conferences on pilot projects that had been successful<br />
      and moved to production. Part of what drove adoption was the ease<br />
      of development in Go along with good system performance. I also think<br />
      there was a growing disenchantment with alternatives like C++, C sharp<br />
      and Java as well as the weight of the LAMP, Tomcat, and OpenStack.</p>
      <p>Highly visible Go based projects include</p>
      <ul>
      <li><a href="http://docker.org">Docker</a> and <a href="http://www.docker.com">Rocket</a> - Containerization for running process in the cloud</li>
      <li><a href="http://kubernetes.io/">Kubernettes</a> and <a href="https://www.terraform.io/">Terraform</a> - Container orchestration systems</li>
      <li><a href="http://hugo.io">Hugo</a> - the fast/popular static website generator, an alternative to Jekyll, for those who want speed</li>
      <li><a href="https://caddyserver.com/">Caddy</a> - a Go based web server trying to unseat Apache/NGinX focusing on easy of use plus speed</li>
      <li><a href="http://ipfs.io">IPFS</a> - a cutting edge distributed storage system based on block chains</li>
      </ul>
      <h3 id="who-is-using-blevesearch">Who is using Blevesearch?</h3>
      <p>Here's some larger projects using Bleve.</p>
      <ul>
      <li><a href="http://www.couchbase.com">Couchbase</a>, a NoSQL database platform are replacing Lucene with Bleve.  Currently the creator of Bleve works for them.</li>
      <li><a href="http://hugo.io">Hugo</a> can integrate with Bleve for search and index generation</li>
      <li><a href="https://caddyserver.com/">Caddy</a> integrates with Bleve to provide an embedded search capability</li>
      </ul>
      <h2 id="managing-risks">Managing risks</h2>
      <p>In 2014 Go was moving from bleeding to leading edge. Serious capital<br />
      was behind its adoption and it stopped being an exotic conference<br />
      item. In 2014 Bleve was definitely bleeding edge. By late 2015 and early<br />
      2016 the program level API stabilized. People were piloting projects<br />
      with it. This included our small group at Caltech Library. In 2015<br />
      non-English language support appeared followed by a growing list<br />
      of non-European languages in 2016. By mid 2016 we started to see<br />
      missing features like alternative sorting added. While Bleve isn't<br />
      yet 1.0 (Feb. 2018) it is reliable. The primary challenge for the Bleve<br />
      project is documentation targeting the novice and non-Programmer users.<br />
      Bleve has proven effective as an indexing and search platform for<br />
      archival, library, and data repository content.</p>
      <p>Adopting new software comes with risk. We have mitigated this in two ways.</p>
      <ol>
      <li>Identify alternative technology (a plan B)</li>
      <li>Architect our systems for easy decomposition and re-composition</li>
      </ol>
      <p>In the case of Go, packages can be compiled to a C-Shared<br />
      library. This allows us to share working Go packages with languages<br />
      like Python, R, and PHP. We have included shared Go/Python modules<br />
      on our current road map for projects.</p>
      <p>For Blevesearch the two alternatives are Solr and Elastic<br />
      Search. Both are well known, documented, and solid.  The costs would be<br />
      recommitting to a Java stack and its resource requirements. We have<br />
      already identified what we want to index and that could be converted<br />
      to either platform if needed.  If we stick with Go but dropped<br />
      Blevesearch we would swap out the Bleve specific code for Go packages<br />
      supporting Solr and Elastic Search.</p>
      <p>The greatest risk in adopting Go for library and archive projects was<br />
      knowledge transfer. We addressed this<br />
      by knowledge sharing and insuring the Go codebase can<br />
      be used via command line programs.  Additionally<br />
      we are adding support for Go based Python modules.<br />
      Training also is available in the form of books, websites and<br />
      online courses (<a href="https://www.lynda.com/Go-tutorials/Up-Running-Go/412378-2.html">lynda.com</a> offers a &quot;Up Running Go&quot; course).</p>
      <h2 id="what-are-the-benefits">What are the benefits?</h2>
      <p>For library and archives software we have found Go's benefits include<br />
      improved back end systems performance at a lower cost, ease of development,<br />
      ease of deployment, a rich standard library focused on the types of things<br />
      needed in library and archival software.  Go plays nice with<br />
      other systems (e.g. I create an API based service in Go that can easily<br />
      be consumed by a web browser running JavaScript or Perl/PHP/Python<br />
      code running under LAMP). In the library and archives setting Go<br />
      can become a high performance duck tape. We get the performance and<br />
      reliability of C/Java type systems with code simplicity<br />
      similar to Python.</p>
      
    </article>
  </section>
  <footer>
    <p>copyright Â© 2016 - 2025 R. S. Doiel<br /> <a
    href="/rssfeed.html">RSS</a> feeds and website built with <a
    href="https://rsdoiel.github.io/antennaApp">antennaApp</a>, Bash, Make and <a
    href="https://pandoc.org">Pandoc</a>.</p>
  </footer>

    <script type="module" src="/modules/copyToClipboard.js"></script>
    <script type="module">
      await import('/pagefind/pagefind-highlight.js');
      new PagefindHighlight({ highlightParam: "highlight" });
    </script>
</body>
</html>
