<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Accessing Go from Julia</title>

  <link rel="stylesheet" type="text/css"  href="/printfonts/print.css" media="print" />
  <link rel="stylesheet" type="text/css"  href="/webfonts/fonts.css" media="screen" />
  <link rel="stylesheet" type="text/css"  href="/css/site.css" media="screen" />
  <link rel="stylesheet" type="text/css"  href="/css/tables.css" media="screen" />
  <link title="RSS feed for rsdoiel's blog" rel="alternate" type="application/rss+xml" href="https://rsdoiel.github.io/rss.xml" />
  <link rel="alternative" type="application/markdown" href="2018/03/11/accessing-go-from-julia.md">
</head>
<body>
<nav>
<nav>
<ul>
<li><a href="/">R. S. Doiel</a></li>
<li><a href="/blog/">Blog</a></li>
<li><a href="/series/">Series</a></li>
<li><a href="/presentations.html">Presentations</a></li>
<li><a href="/library-terminology.html">Library Jargon</a></li>
<li><a href="/cv.html">CV</a></li>
<li><a href="/resume.html">Resume</a></li>
<li><a href="/search.html">Search</a></li>
<li><a href="https://github.com/rsdoiel">GitHub</a></li>
</ul>
</nav>
</nav>

<section>
  <article>
<h1 id="accessing-go-from-julia">Accessing Go from Julia</h1>
<p>By R. S. Doiel, 2018-03-11</p>
<p>The problem: I’ve started exploring Julia and I would like to leverage existing code I’ve written in Go. Essentially this is a revisit to the problem in my last post <a href="https://rsdoiel.github.io/blog/2018/02/24/go-based-python-modules.html">Go based Python Modules</a> but with the language pairing of Go and Julia.</p>
<h2 id="example-1-libtwice.go-libtwice.jl-and-libtwice_test.jl">Example 1, libtwice.go, libtwice.jl and libtwice_test.jl</h2>
<p>In out first example we send an integer value from Julia to Go and back via a C shared library (written in Go). While Julia doesn’t require type declarations I will be using those for clarity. Like in my previous post I think this implementation this is a good starting point to see how Julia interacts with C shared libraries. Like before I will present our Go code, an explanation followed by the Julia code and commentary.</p>
<p>On the Go side we create a <em>libtwice.go</em> file with an empty <code>main()</code> function. Notice that we also import the <em>C</em> package and use a comment decoration to indicate the function we are exporting (see https://github.com/golang/go/wiki/cgo and https://golang.org/cmd/cgo/ for full story about Go’s <em>C</em> package and <em>cgo</em>). Part of the what <em>cgo</em> and the <em>C</em> package does is use the comment decoration to build the signatures for the function calls in the shared C library. The Go toolchain does all the heavy lifting in making a <em>C</em> shared library based on comment directives like “//export”. We don’t need much for our twice function.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb1-1" title="1">    <span class="kw">package</span> main</a>
<a class="sourceLine" id="cb1-2" title="2">    </a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="kw">import</span> (</a>
<a class="sourceLine" id="cb1-4" title="4">        <span class="st">&quot;C&quot;</span></a>
<a class="sourceLine" id="cb1-5" title="5">    )</a>
<a class="sourceLine" id="cb1-6" title="6">    </a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="co">//export twice</span></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="kw">func</span> twice(i <span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb1-9" title="9">        <span class="kw">return</span> i * <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-10" title="10">    }</a>
<a class="sourceLine" id="cb1-11" title="11">    </a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="kw">func</span> main() {}</a></code></pre></div>
<p>Like in our previous Python implementation we need to build the C shared library before using it from Julia. Here are some example Go build commands for Linux, Windows and Mac OS X. You only need to run the one that applies to your operating system.</p>
<pre class="shell"><code>    go build -buildmode=c-shared -o libtwice.so libtwice.go
    go build -buildmode=c-shared -o libtwice.dll libtwice.go
    go build -buildmode=c-shared -o libtwice.dynlib libtwice.go</code></pre>
<p>Unlike the Python implementation our Julia code will be split into two files. <em>libtwice.jl</em> will hold our module definition and <em>libtwice_test.jl</em> will hold our test code. In the case of <em>libtwice.jl</em> we will access the C exported function via a function named <em>ccall</em>. Julia doesn’t require a separate module to be imported in order to access a C shared library. That makes our module much simpler. We still need to be mindful of type conversion. Both Go and Julia provide for rich data types and structs. But between Go and Julia we have C and C’s basic type system. On the Julia side <em>ccall</em> and Julia’s type system help us managing C’s limitations.</p>
<p>Here’s the Julia module we’ll call <em>libtwice.jl</em>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb3-1" title="1">    <span class="kw">module</span> libtwice</a>
<a class="sourceLine" id="cb3-2" title="2">            </a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="co"># We write our Julia idiomatic function</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="kw">function</span> twice(i::<span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb3-5" title="5">        <span class="kw">ccall</span>((:twice, <span class="st">&quot;./libtwice&quot;</span>), <span class="dt">Int32</span>, (<span class="dt">Int32</span>,), i)</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="kw">end</span></a></code></pre></div>
<p>We’re will put the test code in a file named <em>libtwice_test.jl</em>. Since this isn’t an establish “Package” in Julia we will use Julia’s <em>include</em> statement to get bring the code in then use an <em>import</em> statement to bring the module into our current name space.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb4-1" title="1">    include(<span class="st">&quot;libtwice.jl&quot;</span>)</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">import</span> libtwice</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="co"># We run this test code for libtwice.jl</span></a>
<a class="sourceLine" id="cb4-4" title="4">    println(<span class="st">&quot;Twice of 2 is &quot;</span>, libtwice.twice(<span class="fl">2</span>))</a></code></pre></div>
<p>Our test code can be run with</p>
<pre class="shell"><code>    julia libtwice_test.jl</code></pre>
<p>Notice the amount of lifting that Julia’s <em>ccall</em> does. The Julia code is much more compact as a result of not having to map values in a variable declaration. We still have the challenges that Julia and Go both support richer types than C. In a practical case we should consider the over head of running to two runtimes (Go’s and Julia’s) as well as whether or not implementing as a shared library even makes sense. But if you want to leverage existing Go based code this approach can be useful.</p>
<p>Example 1 is our base recipe. The next examples focus on handling other data types but follow the same pattern.</p>
<h2 id="example-2-libsayhi.go-libsayhi.jl-and-libsayhi_test.jl">Example 2, libsayhi.go, libsayhi.jl and libsayhi_test.jl</h2>
<p>Like Python, passing strings passing to or from Julia and Go is nuanced. Go is expecting UTF-8 strings. Julia also supports UTF-8 but C still looks at strings as a pointer to an address space that ends in a null value. Fortunately in Julia the <em>ccall</em> function combined with Julia’s rich type system gives us straight forward ways to map those value. Go code remains unchanged from our Python example in the previous post. In this example we use Go’s <em>fmt</em> package to display the string. In the next example we will round trip our string message.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb6-1" title="1">    <span class="kw">package</span> main</a>
<a class="sourceLine" id="cb6-2" title="2">    </a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="kw">import</span> (</a>
<a class="sourceLine" id="cb6-4" title="4">        <span class="st">&quot;C&quot;</span></a>
<a class="sourceLine" id="cb6-5" title="5">        <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb6-6" title="6">    )</a>
<a class="sourceLine" id="cb6-7" title="7">    </a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="co">//export say_hi</span></a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="kw">func</span> say_hi(msg *C.char) {</a>
<a class="sourceLine" id="cb6-10" title="10">        fmt.Println(C.GoString(msg))</a>
<a class="sourceLine" id="cb6-11" title="11">    }</a>
<a class="sourceLine" id="cb6-12" title="12">    </a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="kw">func</span> main() { }</a></code></pre></div>
<p>The Go source is the similar to our first recipe. No change from our previous posts’ Python example. It will need to be compiled to create our C shared library just as before. Run the go build line that applies to your operating system (i.e., Linux, Windows and Mac OS X).</p>
<pre class="shell"><code>    go build -buildmode=c-shared -o libsayhi.so libsayhi.go
    go build -buildmode=c-shared -o libsayhi.dll libsayhi.go
    go build -buildmode=c-shared -o libsayhi.dylib libsayhi.go</code></pre>
<p>Our Julia module looks like this.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb8-1" title="1">    <span class="kw">module</span> libsayhi</a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="co"># Now write our Julia idiomatic function using *ccall* to access the shared library</span></a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="kw">function</span> say_hi(txt::AbstractString)</a>
<a class="sourceLine" id="cb8-5" title="5">        <span class="kw">ccall</span>((:say_hi, <span class="st">&quot;./libsayhi&quot;</span>), <span class="dt">Int32</span>, (Cstring,), txt)</a>
<a class="sourceLine" id="cb8-6" title="6">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8">    <span class="kw">end</span></a></code></pre></div>
<p>This code is much more compact than our Python implementation.</p>
<p>Our test code looks like</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb9-1" title="1">    include(<span class="st">&quot;./libsayhi.jl&quot;</span>)</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="kw">import</span> libsayhi</a>
<a class="sourceLine" id="cb9-3" title="3">    libsayhi.say_hi(<span class="st">&quot;Hello again!&quot;</span>)</a></code></pre></div>
<p>We run our tests with</p>
<pre class="shell"><code>    julia libsayhi_test.jl</code></pre>
<h2 id="example-3-libhelloworld.go-and-librhelloworld.cl-and-libhelloworld_test.jl">Example 3, libhelloworld.go and librhelloworld.cl and libhelloworld_test.jl</h2>
<p>In this example we send a string round trip between Julia and Go. Most of the boiler plate we say in Python is gone due to Julia’s type system. In addition to using Julia’s <em>ccall</em> we’ll add a <em>convert</em> and <em>bytestring</em> function calls to bring our <strong>Cstring</strong> back to a <strong>UTF8String</strong> in Julia.</p>
<p>The Go implementation remains unchanged from our previous Go/Python implementation. The heavy lifting is done by the <em>C</em> package and the comment <code>//export</code>. We are using <code>C.GoString()</code> and <code>C.CString()</code> to flip between our native Go and C datatypes.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb11-1" title="1">    <span class="kw">package</span> main</a>
<a class="sourceLine" id="cb11-2" title="2">    </a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="kw">import</span> (</a>
<a class="sourceLine" id="cb11-4" title="4">        <span class="st">&quot;C&quot;</span></a>
<a class="sourceLine" id="cb11-5" title="5">        <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb11-6" title="6">    )</a>
<a class="sourceLine" id="cb11-7" title="7">    </a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="co">//export helloworld</span></a>
<a class="sourceLine" id="cb11-9" title="9">    <span class="kw">func</span> helloworld(name *C.char) *C.char {</a>
<a class="sourceLine" id="cb11-10" title="10">        txt := fmt.Sprintf(<span class="st">&quot;Hello %s&quot;</span>, C.GoString(name))</a>
<a class="sourceLine" id="cb11-11" title="11">        <span class="kw">return</span> C.CString(txt)</a>
<a class="sourceLine" id="cb11-12" title="12">    }</a>
<a class="sourceLine" id="cb11-13" title="13">    </a>
<a class="sourceLine" id="cb11-14" title="14">    <span class="kw">func</span> main() { }</a></code></pre></div>
<p>As always we must build our C shared library from the Go code. Below is the go build commands for Linux, Windows and Mac OS X. Pick the line that applies to your operating system to build the C shared library.</p>
<pre class="shell"><code>    go build -buildmode=c-shared -o libhelloworld.so libhelloworld.go
    go build -buildmode=c-shared -o libhelloworld.dll libhelloworld.go
    go build -buildmode=c-shared -o libhelloworld.dylib libhelloworld.go</code></pre>
<p>In our Julia, <em>libhelloworld.jl</em>, the heavy lifting of type conversion happens in Julia’s type system and in the <em>ccall</em> function call. Additionally we need to handle the conversion from <strong>Cstring</strong> Julian type to <strong>UTF8String</strong> explicitly in our return value via a functions named <em>convert</em> and <em>bytestring</em>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb13-1" title="1">    <span class="kw">module</span> libhelloworld</a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="co"># Now write our Julia idiomatic function</span></a>
<a class="sourceLine" id="cb13-4" title="4">    <span class="kw">function</span> helloworld(txt::AbstractString)</a>
<a class="sourceLine" id="cb13-5" title="5">        value = <span class="kw">ccall</span>((:helloworld, <span class="st">&quot;./libhelloworld&quot;</span>), Cstring, (Cstring,), txt)</a>
<a class="sourceLine" id="cb13-6" title="6">        convert(<span class="dt">UTF8String</span>, bytestring(value))</a>
<a class="sourceLine" id="cb13-7" title="7">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9">    <span class="kw">end</span></a></code></pre></div>
<p>Our test code looks similar to our Python test implementation.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb14-1" title="1">    include(<span class="st">&quot;libhelloworld.jl&quot;</span>)</a>
<a class="sourceLine" id="cb14-2" title="2">    <span class="kw">import</span> libhelloworld</a>
<a class="sourceLine" id="cb14-3" title="3"> </a>
<a class="sourceLine" id="cb14-4" title="4">    <span class="kw">if</span> length(ARGS) &gt; <span class="fl">0</span></a>
<a class="sourceLine" id="cb14-5" title="5">        println(libhelloworld.helloworld(join(ARGS, <span class="st">&quot; &quot;</span>)))</a>
<a class="sourceLine" id="cb14-6" title="6">    <span class="kw">else</span></a>
<a class="sourceLine" id="cb14-7" title="7">        println(libhelloworld.helloworld(<span class="st">&quot;World&quot;</span>))</a>
<a class="sourceLine" id="cb14-8" title="8">    <span class="kw">end</span></a></code></pre></div>
<p>As before we see the Julia code is much more compact than Python’s.</p>
<h2 id="example-4-libjsonpretty.go-libjsonpretty.jl-and-libjsonpretty_test.jl">Example 4, libjsonpretty.go, libjsonpretty.jl and libjsonpretty_test.jl</h2>
<p>In this example we send JSON encode text to the Go package, unpack it in Go’s runtime and repack it using the <code>MarshalIndent()</code> function in Go’s JSON package before sending it back to Julia in C string form. You’ll see the same encode/decode patterns as in our <em>libhelloworld</em> example.</p>
<p>Go code</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb15-1" title="1">    <span class="kw">package</span> main</a>
<a class="sourceLine" id="cb15-2" title="2">    </a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="kw">import</span> (</a>
<a class="sourceLine" id="cb15-4" title="4">        <span class="st">&quot;C&quot;</span></a>
<a class="sourceLine" id="cb15-5" title="5">        <span class="st">&quot;encoding/json&quot;</span></a>
<a class="sourceLine" id="cb15-6" title="6">        <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb15-7" title="7">        <span class="st">&quot;log&quot;</span></a>
<a class="sourceLine" id="cb15-8" title="8">    )</a>
<a class="sourceLine" id="cb15-9" title="9">    </a>
<a class="sourceLine" id="cb15-10" title="10">    <span class="co">//export jsonpretty</span></a>
<a class="sourceLine" id="cb15-11" title="11">    <span class="kw">func</span> jsonpretty(rawSrc *C.char) *C.char {</a>
<a class="sourceLine" id="cb15-12" title="12">        data := <span class="bu">new</span>(<span class="kw">map</span>[<span class="dt">string</span>]<span class="kw">interface</span>{})</a>
<a class="sourceLine" id="cb15-13" title="13">        err := json.Unmarshal([]<span class="dt">byte</span>(C.GoString(rawSrc)), &amp;data)</a>
<a class="sourceLine" id="cb15-14" title="14">        <span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb15-15" title="15">            log.Printf(<span class="st">&quot;%s&quot;</span>, err)</a>
<a class="sourceLine" id="cb15-16" title="16">            <span class="kw">return</span> C.CString(<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb15-17" title="17">        }</a>
<a class="sourceLine" id="cb15-18" title="18">        src, err := json.MarshalIndent(data, <span class="st">&quot;&quot;</span>, <span class="st">&quot;    &quot;</span>)</a>
<a class="sourceLine" id="cb15-19" title="19">        <span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb15-20" title="20">            log.Printf(<span class="st">&quot;%s&quot;</span>, err)</a>
<a class="sourceLine" id="cb15-21" title="21">            <span class="kw">return</span> C.CString(<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb15-22" title="22">        }</a>
<a class="sourceLine" id="cb15-23" title="23">        txt := fmt.Sprintf(<span class="st">&quot;%s&quot;</span>, src)</a>
<a class="sourceLine" id="cb15-24" title="24">        <span class="kw">return</span> C.CString(txt)</a>
<a class="sourceLine" id="cb15-25" title="25">    }</a>
<a class="sourceLine" id="cb15-26" title="26">    </a>
<a class="sourceLine" id="cb15-27" title="27">    <span class="kw">func</span> main() {}</a></code></pre></div>
<p>Build commands for Linux, Windows and Mac OS X are as before, pick the one that matches your operating system.</p>
<pre class="shell"><code>    go build -buildmode=c-shared -o libjsonpretty.so libjsonpretty.go
    go build -buildmode=c-shared -o libjsonpretty.dll libjsonpretty.go
    go build -buildmode=c-shared -o libjsonpretty.dylib libjsonpretty.go</code></pre>
<p>Our Julia module code</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb17-1" title="1">    <span class="kw">module</span> libjsonpretty</a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="co"># Now write our Julia idiomatic function</span></a>
<a class="sourceLine" id="cb17-4" title="4">    <span class="kw">function</span> jsonpretty(txt::AbstractString)</a>
<a class="sourceLine" id="cb17-5" title="5">        value = <span class="kw">ccall</span>((:jsonpretty, <span class="st">&quot;./libjsonpretty&quot;</span>), Cstring, (Cstring,), txt)</a>
<a class="sourceLine" id="cb17-6" title="6">        convert(<span class="dt">UTF8String</span>, bytestring(value))</a>
<a class="sourceLine" id="cb17-7" title="7">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb17-8" title="8">    </a>
<a class="sourceLine" id="cb17-9" title="9">    <span class="kw">end</span></a></code></pre></div>
<p>Our Julia test code</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb18-1" title="1">    include(<span class="st">&quot;./libjsonpretty.jl&quot;</span>)</a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="kw">import</span> libjsonpretty</a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4">    src = <span class="st">&quot;&quot;&quot;{&quot;</span>name<span class="st">&quot;:&quot;</span>fred<span class="st">&quot;,&quot;</span>age<span class="st">&quot;:25,&quot;</span>height<span class="st">&quot;:75,&quot;</span>units<span class="st">&quot;:&quot;</span>inch<span class="st">&quot;,&quot;</span>weight<span class="st">&quot;:&quot;</span><span class="fl">239</span><span class="st">&quot;}&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb18-5" title="5">    println(<span class="st">&quot;Our origin JSON src&quot;</span>, src)</a>
<a class="sourceLine" id="cb18-6" title="6">    value = libjsonpretty.jsonpretty(src)</a>
<a class="sourceLine" id="cb18-7" title="7">    println(<span class="st">&quot;And out pretty version</span><span class="sc">\n</span><span class="st">&quot;</span>, value)</a></code></pre></div>
<p>As before you can run your tests with <code>julia libjsonpretty_test.jl</code>.</p>
<p>In closing I would like to note that to use these examples I am assuming your Julia code is in the same directory as your shared C library. Julia, like Python3, has a feature rich module and Package system. If you are creating a serious Julia project then you need to be familiar with how Julia’s package and module system works and place your code and shared libraries appropriately.</p>
  </article>
</section>

<footer>
<footer>
<p>copyright © 2016 - 2021 R. S. Doiel<br /> <a href="/rssfeed.html">RSS</a> feed and website built with <a href="https://caltechlibrary.github.io/mkpage">mkpage</a>, <a href="https://caltechlibrary.github.io/datatools">datatools</a>, Bash, Make and <a href="https://pandoc.org">Pandoc</a>.</p>
</footer>
</footer>
<!-- START: PrettyFi from https://github.com/google/code-prettify -->
<script>
/* We want to add the class "prettyprint" to all the pre elements */
var pre_list = document.querySelectorAll("pre");

pre_list.forEach(function(elem) {
    elem.classList.add("prettyprint");
    elem.classList.add("linenums");/**/
    elem.classList.add("json"); /**/
});
</script>
<style>
li.L0, li.L1, li.L2, li.L3, li.L4, li.L5, li.L6, li.L7, li.L8, li.L9
{
    color: #555;
    list-style-type: decimal;
}
</style>
<link rel="stylesheet" type="text/css" href="/css/prettify.css">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_
prettify.js"></script>
<!--  END: PrettyFi from https://github.com/google/code-prettify -->

</body>
</html>
