<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:source="https://source.scripting.com/">
  <atom:link href="http://localhost:8000/blogxml" rel="self" type="application/rss+xml" />
  <channel>
    <title>Robert's Ramblings</title>
    <description>
      Recent posts on software development and technology
    </description>
    <link>http://localhost:8000/blogxml</link>
    <lastBuildDate>28 Nov 25 13:02 -0800</lastBuildDate>
    <generator>antenna/0.0.16-gamma</generator>
    <docs>https://cyber.harvard.edu/rss/rss.html</docs>
    <item>
      <title>Upgrade my Raspberry Pi 500+ to Trixie</title>
      <link>https://rsdoiel.github.io/blog/2025/11/29/Upgrade-Pi-500-plus.html</link>
      <description>
        <![CDATA[A brief step by step to upgrading from Raspberry Pi OS 5 to Raspberry Pi OS 6
        for my Raspberry Pi 500+.]]>
      </description>
      <source:markdown># Upgrading my Raspberry Pi 500+ to Trixie

By R. S. Doiel, 2025-11-29

I got a Raspberry Pi 500+ running Raspberry Pi OS 5 (bookworm) earlier this month. It has been a really fun computer for my hobby projects. Raspberry Pi OS 6 is now out (Trixie). The official recommendation to update the OS is to back everything, then re-image the drive. My 500+ boots from an NVME drive by default. I don&#39;t have access to boot from Ethernet or network boot. So how to proceed?

I have a several set process.

1. Using a SD Card and Raspberry Pi Imager, create a bootable SD card
2. Reboot selecting the SD Card as the boot drive
3. Test Trixie via the SD Card
4. If the tests work out then install it on the NVME drive and reboot

This is pretty straight forward and reminds me a bit of the old days with DOS and CP/M.  The question is step 2. 

I&#39;ve need the new boot menu flash by when I boot up the 500+ plus but haven&#39;t payed close attention to it. It just came with the original OS install.  The boot menu provides an option to select a boot drive. This makes it much easier than the old days when you had to edit files to change the boot drive.

The challenge was how to make the choice, what key sequence at boot I needed to type out.  That was less obvious to be given how fast the 500+ boots from the NVME drive.

To pause the boot process in the boot menu start from a cold boot (power all the way down then power back on) and press the space bar. This will present you with some choices.

# Actual steps

1. backup home directory on Raspberry Pi 500+ (home was one NVME drive)
2. Confirm firmware is up to date, following the instruction on Raspberry Pi website
2. Confirm I have the latest Raspberry Pi Imager
2. Using Raspberry Pi Imager image an SD Card with latest Raspberry Pi OS 6
3. Power down Raspberry Pi 500+
4. Power up Raspberry Pi 500+ pressing space bar during boot process
5. Select boot from SD Card with fresh OS
6. Setup Raspberry Pi on SD Card, updating to the latest Raspberry Pi Imager
7. Using the Pi Imager on the SD Card, install a fresh image on the NVME drive (NOTE: This erases the whole drive!!!)
8. Then finished, power down the 500+
9. Remove the SD Card from the 500+
10. Boot 500+ from the NVME, complete the usual setup process
11. Restore my home directory backup, install latest Go, Deno, OBNC, etc.</source:markdown>
    </item>    <item>
      <title>Upgrade my Raspberry Pi 500+ to Trixie</title>
      <link>https://rsdoiel.github.io/blog/2025/11/28/Upgrade-Pi-500-plus.html</link>
      <description>
        <![CDATA[A brief step by step to upgrading from Raspberry Pi OS 5 to Raspberry Pi OS 6
        for my Raspberry Pi 500+.]]>
      </description>
      <source:markdown># Upgrading my Raspberry Pi 500+ to Trixie

By R. S. Doiel, 2025-11-28

I has a Raspberry Pi 500+ running Raspberry Pi OS 5 (bookworm). It has been a really fun computer for my hobby projects. Raspberry Pi OS 6 is now out (Trixie). The official recommendation to update the OS is to back everything, then re-image the drive. For the Raspberry Pi 500+ the image is on the NVME drive. I don&#39;t have access to boot from Ethernet for the 500+ so how to proceed? One approach is install Pi OS on an SD Card, boot from it to re-image the NVME drive.

Here&#39;s the multi-step process.

1. Using a SD Card and Raspberry Pi Imager, create a boot-able SD card
2. Reboot selecting the SD Card as the boot drive
3. Test Trixie via the SD Card
4. If the tests work out then install Trixie on the NVME drive and reboot

This is pretty straight forward and reminds me a bit of the old days with DOS and CP/M.  The question is step 2. 

I&#39;ve have seen the new boot menu flash by when I boot up the 500+ plus but haven&#39;t payed close attention to it. It came with the original OS install on the Pi 500+.  The boot menu provides an option to select a boot drive. This makes it much easier than the old days when you had to edit files to change the boot drive. 

My missing bit of information was how to interrupt the regular boot sequence to make the selection. The 500+ boots pretty quickly so it was hard to read the text that flashes by. The answer is **to pause the boot process and enter the boot menu start from a cold boot. Power up and press the space bar**. This will present you with some choices. Select the number for the drive and proceed.

## Actual steps

1. Backup home directory on Raspberry Pi 500+ (home was one NVME drive)
2. Confirm firmware is up to date, following the instruction on Raspberry Pi website
2. Confirm I have the latest Raspberry Pi Imager
2. Using Raspberry Pi Imager image an SD Card with latest Raspberry Pi OS 6
3. Power down Raspberry Pi 500+
4. Power up Raspberry Pi 500+ pressing space bar during boot process
5. Select boot from SD Card with fresh OS
6. Setup Raspberry Pi on SD Card, updating to the latest Raspberry Pi Imager
7. Using the Pi Imager on the SD Card, install a fresh image on the NVME drive (NOTE: This erases the whole drive!!!)
8. Then finished, power down the 500+
9. Remove the SD Card from the 500+
10. Boot 500+ from the NVME, complete the usual setup process
11. Restore my home directory backup, install latest Go, Deno, OBNC, etc.</source:markdown>
      <enclosure url="https://rsdoiel.github.io/blog/2025/11/28/Upgrade-Pi-500-plus.md" length="2849" type="text/markdown" />
    </item>    <item>
      <title>Text fragment links as social expression</title>
      <link>https://rsdoiel.github.io/blog/2025/11/17/text_fragment_links_a_social_expression.html</link>
      <description>
        <![CDATA[An exploration of picking up text fragment links in a Markdown document as a means of generating "comment on" feeds.]]>
      </description>
      <source:markdown># Text fragment links as social expression

By R. S. Doiel, 2025-11-17

Some of the attraction of the walled gardens like Instagram, X, BlueSky and Mastodon was the ease at which you can &#34;re-post&#34;, &#34;reply&#34; or &#34;quote&#34;. Automatic linking provides a smooth process. Two or more decades ago this was innovation, today your web browser supports linking via text fragments.

How do I get a text fragment link? Select a phrase or block of text in a web page. Right click to pull up the context menu. Pick the menu item &#34;copy link to highlight&#34;. This will create the text fragment link on your computer&#39;s clipboard. Where should you paste the link?

Pasting the link into a social media site like BlueSky will focus the conversation there. You can also use the link to direct the conversation to your own site. That&#39;s helpful. I think the text fragment link can be more useful than that.

A text fragment link could be a corner stone used to assert a web of our own. The trick is to fully realize the convenience while maximizing the content expressed in the URL. I think it has a place both in the HTML page but also as an integral part of our RSS feeds.

## text fragment link as a content unit

When you choose, &#34;copy link to highlight&#34;, you&#39;re composing a URL. It is a URL with more then a location. It is a URL that holds textual content. The text fragment link&#39;s syntax means you can target it for additional processing without needing to evaluate every other link that might be in the web page[^1]. That begs the question, what does this type of link enable?

[^1]: A text fragment link is implemented in the query string portion of the URL and that query potion starts with &#34;`#:~:`&#34; sequence. What follows is instructions of highlighted text to be referenced. 

Below is an example of a text fragment link that points to another of my blog posts.  It&#39;s pretty hard to read because the important bits are hidden by URL encoding.

~~~markdown
https://rsdoiel.github.io/blog/2025/11/13/urls_for_text_fragments.html#:~:text=While%20the%20URL%20syntax%20for%20text%20fragments%20is%20verbose%20getting%20a%20link%20to%20one%20is%20pretty%20easy%20with%20a%20desktop%20web%20browser%2E%20Here%27s%20the%20steps%20I%20use%20with%20desktop%20Firefox
~~~

Unpacking it you can find the link to the blog post plus the content that had been selected. If you have a url decoder handy you can break it down into its parts. Example, look at the part of that long, horrible url and look closer at the part after &#34;`#:~:text=`&#34;. That&#39;s a description of the quote. You just need to URL decode the spaces and punctuation to recover the text the tells the web browser what to highlight when the web page is opened. Here&#39;s the decoded text.

~~~
&#34;While the URL syntax for text fragments is verbose getting a link to one is pretty easy with a desktop web browser. Here&#39;s the steps I use with desktop Firefox.&#34;
~~~

That quote and link can form the basis of a post, a reply or a comment. It is enough to provide some context to what I want to highlight or discuss at the original URL. That URL can point anywhere on the web, not just some walled garden. Even better I can include that information as an item in an RSS feed. Syndication offers the opportunity for further discussion.

Because of the unique syntax of that type of URL the link can be easily extracted from both HTML documents and Markdown documents. That means I can turn these text fragments into a dedicated feed of things I&#39;ve commented on.

## text fragment links populating a &#34;commented on&#34; feed

On my site I include a recent posts feed. Many blogs and news sites include a &#34;comments&#34; feed too.  The problem with the &#34;comments&#34; feed is you&#39;re handing off editorial control to someone else. This usually leads to an investment in moderation in order to avoid the inevitable arrival of spam and trolls. An alternative approach is to produce a &#34;commented on&#34; feed. I like this approach.

A &#34;commented on&#34; feed comes with advantages over an old fashioned comment system and feed.

- you own your comment, it is on your own site
- your comments are not subjected to someone elses terms of service
- your comments remain easy to reference by linking or feed
- someone else can choose to follow the things you&#39;ve commented on
- if two or more people mutually subscribe to each other&#39;s &#34;commented on&#34; feeds a dialog can occur

Since both reader and writer have to opt in to the conversation I believe you can have higher quality engagement.

## How do you create a &#34;commented on&#34; feed item?

A single text fragment URL contains the location and the content to be highlighted.  What I do with the text fragment depends on my intent. A re-post would just include the highlighted text along with the link to its source. A reply or comment would be formed by adding more. Here&#39;s an example of a reply style post expressed in Markdown.

~~~markdown

&#62; &#34;While the URL syntax for text fragments is verbose getting a link
&#62; to one is pretty easy with a desktop web browser. Here&#39;s the steps
&#62; I use with desktop Firefox.&#34;

[This looks promising](https://rsdoiel.github.io/blog/2025/11/13/urls_for_text_fragments.html#:~:text=While%20the%20URL%20syntax%20for%20text%20fragments%20is%20verbose%20getting%20a%20link%20to%20one%20is%20pretty%20easy%20with%20a%20desktop%20web%20browser%2E%20Here%27s%20the%20steps%20I%20use%20with%20desktop%20Firefox)

~~~

This simple structure can easily be automated. You could create a text fragment handler in any editor that supports macros or plugins.

The point I am trying to drive home is the text fragment itself provides sufficient content to populate a post or an RSS item element. Add additional text and you have something more meaningful. A text fragment can anchor a discussion. The discussion proceeds by exchanging feed items. A feed reader or aggregator can provide conversation threading by following the trail of text fragment links.

If you use a feed oriented content system the social aspect of posts and replies becomes visible through the in bound and out bound RSS feeds. The social context sort of reveals itself naturally. You don&#39;t need a complex social graph represented by activity pub or ATProto. You use trusty old web pages and RSS feeds. The technology does not require change. We simply change how we use it.

## next steps

Today, I can manually create a post using a text fragment link. It would be better if there was some light weight automation around it. Several approaches come to mind.

- a simple tool that accepts a post filename and the text fragment link, it would then format a simple Markdown document and open it in my favorite editor for further editing
- a Markdown processor could collect text fragment links and generate a feed for that purpose
- a text editor plug-in or macro could transform a text fragment link for using as a post

It is an interesting opportunity. Little needs to be created to test the concept. Simple automation can improve the writing experience when handling text fragment links. The technical cost are limited while the practical content benefits could be large. Time for me to add this to my to do list for [antennaApp](https://github.com/rsdoiel/antennaApp).</source:markdown>
      <enclosure url="https://rsdoiel.github.io/blog/2025/11/17/text_fragment_links_a_social_expression.md" length="7639" type="text/markdown" />
    </item>    <item>
      <title>URLS for text fragments</title>
      <link>https://rsdoiel.github.io/blog/2025/11/13/urls_and_text_fragments.html</link>
      <description>
        <![CDATA[A quick overview of text fragments expressed as URLs.]]>
      </description>
      <source:markdown># URLS for text fragments

By R. S. Doiel, 2025-11-13

A web innovation that I missed was the wide spread support for text fragments expressed as a URL. This is extremely helpful for both citation and quoting sections of a web page in a blog post. The URL syntax is now widely supported by ever green browsers (e.g. Firefox, Safari and Chrome). You can find a nice explanation at [Text fragments](https://developer.mozilla.org/en-US/docs/Web/URI/Reference/Fragment/Text_fragments) on the [MDN](https://developer.mozilla.org/en-US/docs/Web/URI/Reference/Fragment/Text_fragments) website.

The syntax is a little funky. Here&#39;s an example of selecting the second paragraph in my recent blog post [Half-life of Frameworks](https://rsdoiel.github.io/blog/2025/11/07/half-life-of-frameworks.html),

&#60;https://rsdoiel.github.io/blog/2025/11/07/half-life-of-frameworks.html#:~:text=The%20way,choice&#62;

The sequence `#:~:` indicates it is a link to a text fragment. The `text=The%20way,choice` essentially tells the browser to jump to the text block that starts with &#34;The%20way&#34; and ends with &#34;choice&#34;. Using this URL in Firefox will bring up the web page and highlight the text fragment centering it in the view.

It is important to realize that web pages with JavaScript can break this feature. I&#39;ve noticed this on sites like Substack and BlueSky. The link may bring you to the right page but will not behave as expected. Here&#39;s an example of a text fragment link that should work but doesn&#39;t

&#60;https://sarahkendzior.substack.com/notes#:~:text=I%20was%20suspended%20from%20BlueSky%20for%20defending%20the%20honor%20of%20Johnny%20Cash%2E&#62;

This should link to Sarah Kendzoir&#39;s note entry about being banned from BlueSky for her support of rebutting a WSJ article on Johnny Cash. Instead if you want to link to that entry you must resort to a link exposed with the  tiny [&#34;dot dot dot&#34; menu](https://substack.com/@sarahkendzior/note/c-176537092). 

It is not a browser bug. It&#39;s a choice of those who render pages via JavaScript. I get their commercial reasons. One more reason not to link to commercial websites and other walled gardens that break web standards.

## How do you easily generate text fragment link?

While the URL syntax for text fragments is verbose getting a link to one is pretty easy with a desktop web browser.
Here&#39;s the steps I use with desktop Firefox. 

1. navigate to the web page
2. select the text I want a link to
3. using the context menu (e.g. right click with my mouse)
4. click on &#34;Copy Link to Highlight&#34;

I now have a text fragment link saved to my web browser&#39;s clipboard (i.e. the copy buffer). I can now paste it into my Markdown document. These steps work on other popular desktop browsers (e.g. Safari, Orion and Chrome).

On mobile it&#39;s trickier. There isn&#39;t really a context menu like their is on the desktop. I haven&#39;t found a menu that will take a text selection from the web browser and include a &#34;Copy Link to Highlight&#34; option for sharing. That&#39;s shame. While I don&#39;t write blog posts on my phone I do take notes. Maybe mobile OS will catch up to that functionality in the future. I&#39;m not holding by breath.

## text fragment URL possibilities

As commercial social web platforms continue to devolve into muck. The open web can take advantage of features text fragment URLs. This could be an advantage in demonstrating the fluidity of the open web. In my experiments I&#39;ve found it easy to take advantage of text fragment links in Markdown. Their just another link.  If you&#39;re building Markdown processors you could auto-quote the text when you encounter a text fragment link. That&#39;s save some cutting and pasting in the writing process. You could even derive feeds from Markdown documents that include links expressing text fragments.  I&#39;m hoping to have a chance to experiment with these features in my [antennaApp](https://rsdoiel.github.io/antennaApp) project.</source:markdown>
    </item>    <item>
      <title>URLS for text fragments</title>
      <link>https://rsdoiel.github.io/blog/2025/11/13/urls_for_text_fragments.html</link>
      <description>
        <![CDATA[A quick overview of text fragments expressed as URLs.]]>
      </description>
      <source:markdown># URLS for text fragments

By R. S. Doiel, 2025-11-13

A web innovation that I missed was the wide spread support for text fragments expressed as a URL. This is extremely helpful for both citation and quoting sections of a web page in a blog post. The URL syntax is now widely supported by ever green browsers (e.g. Firefox, Safari and Chrome). You can find a nice explanation at [Text fragments](https://developer.mozilla.org/en-US/docs/Web/URI/Reference/Fragment/Text_fragments) on the [MDN](https://developer.mozilla.org/en-US/docs/Web/URI/Reference/Fragment/Text_fragments) website.

The syntax is a little funky. Here&#39;s an example of selecting the second paragraph in my recent blog post [Half-life of Frameworks](https://rsdoiel.github.io/blog/2025/11/07/half-life-of-frameworks.html),

&#60;https://rsdoiel.github.io/blog/2025/11/07/half-life-of-frameworks.html#:~:text=The%20way,choice&#62;

The sequence `#:~:` indicates it is a link to a text fragment. The `text=The%20way,choice` essentially tells the browser to jump to the text block that starts with &#34;The%20way&#34; and ends with &#34;choice&#34;. Using this URL in Firefox will bring up the web page and highlight the text fragment centering it in the view.

It is important to realize that web pages with JavaScript can break this feature. I&#39;ve noticed this on sites like Substack and BlueSky. The link may bring you to the right page but will not behave as expected. Here&#39;s an example of a text fragment link that should work but doesn&#39;t

&#60;https://sarahkendzior.substack.com/notes#:~:text=I%20was%20suspended%20from%20BlueSky%20for%20defending%20the%20honor%20of%20Johnny%20Cash%2E&#62;

This should link to Sarah Kendzoir&#39;s note entry about being banned from BlueSky for her support of rebutting a WSJ article on Johnny Cash. Instead if you want to link to that entry you must resort to a link exposed with the  tiny [&#34;dot dot dot&#34; menu](https://substack.com/@sarahkendzior/note/c-176537092). 

It is not a browser bug. It&#39;s a choice of those who render pages via JavaScript. I get their commercial reasons. One more reason not to link to commercial websites and other walled gardens that break web standards.

## How do you easily generate text fragment link?

While the URL syntax for text fragments is verbose getting a link to one is pretty easy with a desktop web browser.
Here&#39;s the steps I use with desktop Firefox. 

1. navigate to the web page
2. select the text I want a link to
3. using the context menu (e.g. right click with my mouse)
4. click on &#34;Copy Link to Highlight&#34;

I now have a text fragment link saved to my web browser&#39;s clipboard (i.e. the copy buffer). I can now paste it into my Markdown document. These steps work on other popular desktop browsers (e.g. Safari, Orion and Chrome).

On mobile it&#39;s trickier. There isn&#39;t really a context menu like their is on the desktop. I haven&#39;t found a menu that will take a text selection from the web browser and include a &#34;Copy Link to Highlight&#34; option for sharing. That&#39;s shame. While I don&#39;t write blog posts on my phone I do take notes. Maybe mobile OS will catch up to that functionality in the future. I&#39;m not holding by breath.

## text fragment URL possibilities

As commercial social web platforms continue to devolve into muck. The open web can take advantage of features text fragment URLs. This could be an advantage in demonstrating the fluidity of the open web. In my experiments I&#39;ve found it easy to take advantage of text fragment links in Markdown. Their just another link.  If you&#39;re building Markdown processors you could auto-quote the text when you encounter a text fragment link. That&#39;s save some cutting and pasting in the writing process. You could even derive feeds from Markdown documents that include links expressing text fragments.  I&#39;m hoping to have a chance to experiment with these features in my [antennaApp](https://rsdoiel.github.io/antennaApp) project.</source:markdown>
      <enclosure url="https://rsdoiel.github.io/blog/2025/11/13/urls_for_text_fragments.md" length="4226" type="text/markdown" />
    </item>    <item>
      <title>Half-life of Frameworks</title>
      <link>https://rsdoiel.github.io/blog/2025/11/07/half-life-of-frameworks.html</link>
      <description>
        <![CDATA[A discussion of the problems of adopting third part frameworks in programming projects.]]>
      </description>
      <source:markdown># Half-life of Frameworks

By R. S. Doiel, 2025-11-07

[&#34;A Kind of Farewell to the Web&#34;](https://webdirections.org/blog/a-kind-of-farewell-to-the-web/) is an interesting read on front-end development. It&#39;s thoughtful and like other similar blog posts I think important.

Posts like this ask an important question, &#34;What happens when a framework designed to solve a problem is now the problem?&#34;

Software libraries and frameworks often emerge by taking something challenging or tedious and provide a solution that is convenient. If successful, they acquire a specific success problem. The become both a technical solution and a form of cultural identity. This often starts of innocently enough, perhaps a job posting with the framework as a desired skill set. Once the framework is tied to the job though institutionalization sets in. The frameworks is fused into the organizational structure and as a technical solution.  Initially this might seem like a good thing.  Unix I think is a good example of a collection of operating system approaches and libraries that vastly simplified it&#39;s original requirement as a multi user text processing platform. Fast forward to today, and the operating system on your phone, tablet or personal computer to your home thermostat or automobile is running a multi user system. That multi user solution also is, by its nature, vulnerable to attack. Who is controlling your device(s) today is an open question. Is it you, the vendor, a service, an organization like a government or something more nefarious? The success of Unix also created a new set of problems. How do we keep multi user systems safe?  This success issue isn&#39;t unique to operating systems. It holds true for choices of programming languages and the libraries, frameworks and packages associated with them. In my forty years of practice I&#39;ve found it helpful to avoid the cultural linkages when providing software solutions. It&#39;s easy to learn a new library, it&#39;s difficult to change people&#39;s identity, culture and habits. 

The way I avoid it is to first consider the problem I&#39;m trying to solve. Looking at the computing devices, operating system and software languages I have at hand. Account for who I want to collaborate with and their preferences for devices, operating systems and programming languages. Once I know the platform and language take a good look at the standard set of libraries, packages or modules.  If the problem can be **simplified enough** using the standard solutions then they&#39;re usually the right libraries, packages or models to work with.  This has proven true in my experience even when a new shiny package pops on the scene. The new shiny often proves to be but a siren&#39;s song.  That raises the question of why is the standard often the right choice?  

Programming languages, like human languages generally, evolve overtime. Standard libraries tend to evolve with the needs of the language. This results in a relationship of idioms. Idioms make it easier to quickly understand the proposed solution represented in the source code of your program. The idiom turns out to be extremely helpful in communicating with other developers. It is even helpful communicating with your future self.

An often over looked aspect of programming language usage is that it has two audiences. The first audience is people. I think it is the most important. The second is the device and operating system where the program is executed. While the second audience is essential to solving the problem, the first audience is essential to evaluating the solution, implementing the solution and sustaining the correctness of the solution over time. It&#39;s also what us humans interact with. Idioms are important in all human languages included those invented to represent how a computer or computation should proceed. I am not suggesting you never use a non-standard framework. I am suggesting **you must know the cost when choosing a third party framework**.

Another important thing to remember is that choosing a framework doesn&#39;t happen once.  It happens each time you revisit the code. Written programs are like written prose. Almost always the text can be improved. As languages evolve they will pickup features that the communities have already widely adopted in third party frameworks. That is because successful framework address deficits in the language implementation.

jQuery is a good example of a framework addressing browser JavaScript twenty years ago. The jQuery library adopted the CSS selector as a means of identifying elements in the DOM. That single feature made working with the DOM much easier. It also unified and encouraged a closer look at the role of CSS in relationship to the browser experience. JavaScript and CSS came into symbiosis. That feature even became compelling compared to other competing frameworks. The CSS selector syntax eventually became a part of the JavaScript standard DOM implementation, example `let h1Elements = document.querySelectorAll(&#34;h1&#34;);`.  You don&#39;t need jQuery or other framework to work with selectors and the DOM. Today most of the problems jQuery addressed are better solved using plain old JavaScript or CSS.

Recent popular frameworks are also not aging well. Look at the current state of React. jQuery&#39;s success arc is predictive of React&#39;s success arc. Is data binding really an issue today? Web Components are widely supported an address the UI binding issues. Even if you chose React with its limitations it will block your progress towards a better UI. That&#39;s the focus of the article sighted at the start of the post. React has reached problem state. Like jQuery, it&#39;ll still be listed on job requirements or in promotion justifications. It is often recommended when you use a large language model to generate JavaScript and CSS source code. React is beyond it&#39;s half-life.

Today lots of people know React. But does anyone remember [MooTools](https://en.wikipedia.org/wiki/MooTools), [Prototype](https://en.wikipedia.org/wiki/Prototype_JavaScript_Framework) or [YUI](https://en.wikipedia.org/wiki/YUI_Library)?  Anyone remember [Jaxer](https://en.wikipedia.org/wiki/Aptana#Aptana_Jaxer) from Aptana? They were the React of their era. The rise and fall of successful third party frameworks is a cautionary tale.  

By sticking with or returning to the language&#39;s standard modules you accrue an under valued advantage. Languages and the standard libraries tend to remain compatible over long periods of time. Languages grow dormant less frequently than frameworks. The features themselves often see performance improvements or enhancements. A framework beyond its half-life will always struggle to keep up. React, like so many before it, is that that point now.

To be clear, I&#39;m not dogmatically say don&#39;t use a third party framework. I am saying non-standard frameworks have a half-life. You need to evaluate the costs with each 3rd Party framework your project requires. Once you use one you have immediately accrued technical debt. The bill will come due. That the bill comes due far sooner than you&#39;d expect. Always ask can your project afford pay it? Ask yourself how much will it cost to move your source code towards the standard libraries?</source:markdown>
      <enclosure url="https://rsdoiel.github.io/blog/2025/11/07/half-life-of-frameworks.md" length="7608" type="text/markdown" />
    </item>
  </channel>
</rss>
